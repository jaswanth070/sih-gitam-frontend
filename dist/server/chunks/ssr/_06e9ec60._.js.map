{"version":3,"sources":["../../../../node_modules/next/src/shared/lib/router/utils/querystring.ts","../../../../node_modules/next/src/shared/lib/router/utils/format-url.ts","../../../../node_modules/next/src/shared/lib/utils.ts","../../../../node_modules/next/src/shared/lib/router/utils/parse-path.ts","../../../../node_modules/next/src/shared/lib/router/utils/add-path-prefix.ts","../../../../node_modules/next/src/shared/lib/router/utils/remove-trailing-slash.ts","../../../../node_modules/next/src/client/normalize-trailing-slash.ts","../../../../node_modules/next/src/client/add-base-path.ts","../../../../node_modules/next/src/client/components/segment-cache/types.ts","../../../../node_modules/next/src/client/components/segment-cache/cache-key.ts","../../../../node_modules/next/src/shared/lib/app-router-types.ts","../../../../node_modules/next/src/client/components/match-segments.ts","../../../../node_modules/next/src/client/components/app-router-headers.ts","../../../../node_modules/next/src/client/components/router-reducer/router-reducer-types.ts","../../../../node_modules/next/src/shared/lib/is-thenable.ts","../../../../node_modules/next/src/client/components/use-action-queue.ts","../../../../node_modules/next/src/client/app-call-server.ts","../../../../node_modules/next/src/client/app-find-source-map-url.ts","../../../../node_modules/next/src/shared/lib/segment-cache/segment-value-encoding.ts","../../../../node_modules/next/src/client/route-params.ts","../../../../node_modules/next/src/client/components/router-reducer/create-href-from-url.ts","../../../../node_modules/next/src/client/flight-data-helpers.ts","../../../../node_modules/next/src/client/app-build-id.ts","../../../../node_modules/next/src/shared/lib/hash.ts","../../../../node_modules/next/src/shared/lib/router/utils/cache-busting-search-param.ts","../../../../node_modules/next/src/client/components/router-reducer/set-cache-busting-search-param.ts","../../../../node_modules/next/src/client/components/router-reducer/fetch-server-response.ts","../../../../node_modules/next/src/client/components/segment-cache/lru.ts","../../../../node_modules/next/src/client/components/segment-cache/cache-map.ts","../../../../node_modules/next/src/client/components/segment-cache/vary-path.ts","../../../../node_modules/next/src/shared/lib/page-path/ensure-leading-slash.ts","../../../../node_modules/next/src/shared/lib/router/utils/app-paths.ts","../../../../node_modules/next/src/shared/lib/router/utils/interception-routes.ts","../../../../node_modules/next/src/client/components/router-reducer/compute-changed-path.ts","../../../../node_modules/next/src/client/components/router-reducer/handle-mutable.ts","../../../../node_modules/next/src/client/components/router-reducer/create-router-cache-key.ts","../../../../node_modules/next/src/client/components/router-reducer/is-navigating-to-new-root-layout.ts","../../../../node_modules/next/src/client/components/router-reducer/ppr-navigations.ts","../../../../node_modules/next/src/client/components/segment-cache/navigation.ts","../../../../node_modules/next/src/client/components/router-reducer/reducers/navigate-reducer.ts","../../../../node_modules/next/src/shared/lib/segment-cache/output-export-prefetch-encoding.ts","../../../../node_modules/next/src/client/components/segment-cache/cache.ts","../../../../node_modules/next/src/client/components/segment-cache/scheduler.ts","../../../../node_modules/next/src/client/components/links.ts","../../../../node_modules/next/src/shared/lib/router/utils/path-has-prefix.ts","../../../../node_modules/next/src/client/has-base-path.ts","../../../../node_modules/next/src/shared/lib/router/utils/is-local-url.ts","../../../../node_modules/next/src/shared/lib/utils/error-once.ts","../../../../node_modules/next/src/client/app-dir/link.tsx","../../../../components/ui/separator.tsx","../../../../components/ui/sheet.tsx","../../../../node_modules/%40floating-ui/utils/dist/floating-ui.utils.mjs","../../../../node_modules/%40floating-ui/utils/dist/floating-ui.utils.dom.mjs","../../../../node_modules/%40radix-ui/react-popper/dist/index.mjs","../../../../node_modules/%40radix-ui/react-tooltip/dist/index.mjs","../../../../components/ui/tooltip.tsx","../../../../components/ui/sidebar.tsx","../../../../components/navigation/dashboard-navbar.tsx","../../../../components/navigation/dashboard-shell.tsx","../../../../node_modules/%40radix-ui/react-separator/dist/index.mjs","../../../../components/ui/skeleton.tsx","../../../../hooks/use-mobile.ts","../../../../node_modules/%40floating-ui/core/dist/floating-ui.core.mjs","../../../../node_modules/%40radix-ui/react-use-size/dist/index.mjs","../../../../node_modules/%40floating-ui/react-dom/dist/floating-ui.react-dom.mjs","../../../../node_modules/%40radix-ui/react-arrow/dist/index.mjs","../../../../node_modules/%40radix-ui/react-visually-hidden/dist/index.mjs","../../../../node_modules/%40floating-ui/dom/dist/floating-ui.dom.mjs","../../../../node_modules/lucide-react/src/icons/network.ts","../../../../node_modules/lucide-react/src/icons/list-todo.ts","../../../../node_modules/lucide-react/src/icons/layout-dashboard.ts","../../../../node_modules/lucide-react/src/icons/boxes.ts","../../../../node_modules/lucide-react/src/icons/panel-left.ts","../../../../node_modules/lucide-react/src/icons/circle-plus.ts","../../../../node_modules/lucide-react/src/icons/file-text.ts","../../../../node_modules/lucide-react/src/icons/log-out.ts","../../../../node_modules/%40radix-ui/react-use-size/src/useSize.tsx","../../../../node_modules/%40radix-ui/react-popper/src/Popper.tsx","../../../../node_modules/%40radix-ui/react-tooltip/src/Tooltip.tsx"],"sourcesContent":["import type { ParsedUrlQuery } from 'querystring'\n\nexport function searchParamsToUrlQuery(\n  searchParams: URLSearchParams\n): ParsedUrlQuery {\n  const query: ParsedUrlQuery = {}\n  for (const [key, value] of searchParams.entries()) {\n    const existing = query[key]\n    if (typeof existing === 'undefined') {\n      query[key] = value\n    } else if (Array.isArray(existing)) {\n      existing.push(value)\n    } else {\n      query[key] = [existing, value]\n    }\n  }\n  return query\n}\n\nfunction stringifyUrlQueryParam(param: unknown): string {\n  if (typeof param === 'string') {\n    return param\n  }\n\n  if (\n    (typeof param === 'number' && !isNaN(param)) ||\n    typeof param === 'boolean'\n  ) {\n    return String(param)\n  } else {\n    return ''\n  }\n}\n\nexport function urlQueryToSearchParams(query: ParsedUrlQuery): URLSearchParams {\n  const searchParams = new URLSearchParams()\n  for (const [key, value] of Object.entries(query)) {\n    if (Array.isArray(value)) {\n      for (const item of value) {\n        searchParams.append(key, stringifyUrlQueryParam(item))\n      }\n    } else {\n      searchParams.set(key, stringifyUrlQueryParam(value))\n    }\n  }\n  return searchParams\n}\n\nexport function assign(\n  target: URLSearchParams,\n  ...searchParamsList: URLSearchParams[]\n): URLSearchParams {\n  for (const searchParams of searchParamsList) {\n    for (const key of searchParams.keys()) {\n      target.delete(key)\n    }\n\n    for (const [key, value] of searchParams.entries()) {\n      target.append(key, value)\n    }\n  }\n\n  return target\n}\n","// Format function modified from nodejs\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nimport type { UrlObject } from 'url'\nimport type { ParsedUrlQuery } from 'querystring'\nimport * as querystring from './querystring'\n\nconst slashedProtocols = /https?|ftp|gopher|file/\n\nexport function formatUrl(urlObj: UrlObject) {\n  let { auth, hostname } = urlObj\n  let protocol = urlObj.protocol || ''\n  let pathname = urlObj.pathname || ''\n  let hash = urlObj.hash || ''\n  let query = urlObj.query || ''\n  let host: string | false = false\n\n  auth = auth ? encodeURIComponent(auth).replace(/%3A/i, ':') + '@' : ''\n\n  if (urlObj.host) {\n    host = auth + urlObj.host\n  } else if (hostname) {\n    host = auth + (~hostname.indexOf(':') ? `[${hostname}]` : hostname)\n    if (urlObj.port) {\n      host += ':' + urlObj.port\n    }\n  }\n\n  if (query && typeof query === 'object') {\n    query = String(querystring.urlQueryToSearchParams(query as ParsedUrlQuery))\n  }\n\n  let search = urlObj.search || (query && `?${query}`) || ''\n\n  if (protocol && !protocol.endsWith(':')) protocol += ':'\n\n  if (\n    urlObj.slashes ||\n    ((!protocol || slashedProtocols.test(protocol)) && host !== false)\n  ) {\n    host = '//' + (host || '')\n    if (pathname && pathname[0] !== '/') pathname = '/' + pathname\n  } else if (!host) {\n    host = ''\n  }\n\n  if (hash && hash[0] !== '#') hash = '#' + hash\n  if (search && search[0] !== '?') search = '?' + search\n\n  pathname = pathname.replace(/[?#]/g, encodeURIComponent)\n  search = search.replace('#', '%23')\n\n  return `${protocol}${host}${pathname}${search}${hash}`\n}\n\nexport const urlObjectKeys = [\n  'auth',\n  'hash',\n  'host',\n  'hostname',\n  'href',\n  'path',\n  'pathname',\n  'port',\n  'protocol',\n  'query',\n  'search',\n  'slashes',\n]\n\nexport function formatWithValidation(url: UrlObject): string {\n  if (process.env.NODE_ENV === 'development') {\n    if (url !== null && typeof url === 'object') {\n      Object.keys(url).forEach((key) => {\n        if (!urlObjectKeys.includes(key)) {\n          console.warn(\n            `Unknown key passed via urlObject into url.format: ${key}`\n          )\n        }\n      })\n    }\n  }\n\n  return formatUrl(url)\n}\n","import type { HtmlProps } from './html-context.shared-runtime'\nimport type { ComponentType, JSX } from 'react'\nimport type { DomainLocale } from '../../server/config'\nimport type { Env } from '@next/env'\nimport type { IncomingMessage, ServerResponse } from 'http'\nimport type { NextRouter } from './router/router'\nimport type { ParsedUrlQuery } from 'querystring'\nimport type { PreviewData } from '../../types'\nimport type { COMPILER_NAMES } from './constants'\nimport type fs from 'fs'\n\nexport type NextComponentType<\n  Context extends BaseContext = NextPageContext,\n  InitialProps = {},\n  Props = {},\n> = ComponentType<Props> & {\n  /**\n   * Used for initial page load data population. Data returned from `getInitialProps` is serialized when server rendered.\n   * Make sure to return plain `Object` without using `Date`, `Map`, `Set`.\n   * @param context Context of `page`\n   */\n  getInitialProps?(context: Context): InitialProps | Promise<InitialProps>\n}\n\nexport type DocumentType = NextComponentType<\n  DocumentContext,\n  DocumentInitialProps,\n  DocumentProps\n>\n\nexport type AppType<P = {}> = NextComponentType<\n  AppContextType,\n  P,\n  AppPropsType<any, P>\n>\n\nexport type AppTreeType = ComponentType<\n  AppInitialProps & { [name: string]: any }\n>\n\n/**\n * Web vitals provided to _app.reportWebVitals by Core Web Vitals plugin developed by Google Chrome team.\n * https://nextjs.org/blog/next-9-4#integrated-web-vitals-reporting\n */\nexport const WEB_VITALS = ['CLS', 'FCP', 'FID', 'INP', 'LCP', 'TTFB'] as const\nexport type NextWebVitalsMetric = {\n  id: string\n  startTime: number\n  value: number\n  attribution?: { [key: string]: unknown }\n} & (\n  | {\n      label: 'web-vital'\n      name: (typeof WEB_VITALS)[number]\n    }\n  | {\n      label: 'custom'\n      name:\n        | 'Next.js-hydration'\n        | 'Next.js-route-change-to-render'\n        | 'Next.js-render'\n    }\n)\n\nexport type Enhancer<C> = (Component: C) => C\n\nexport type ComponentsEnhancer =\n  | {\n      enhanceApp?: Enhancer<AppType>\n      enhanceComponent?: Enhancer<NextComponentType>\n    }\n  | Enhancer<NextComponentType>\n\nexport type RenderPageResult = {\n  html: string\n  head?: Array<JSX.Element | null>\n}\n\nexport type RenderPage = (\n  options?: ComponentsEnhancer\n) => DocumentInitialProps | Promise<DocumentInitialProps>\n\nexport type BaseContext = {\n  res?: ServerResponse\n  [k: string]: any\n}\n\nexport type NEXT_DATA = {\n  props: Record<string, any>\n  page: string\n  query: ParsedUrlQuery\n  buildId: string\n  assetPrefix?: string\n  nextExport?: boolean\n  autoExport?: boolean\n  isFallback?: boolean\n  isExperimentalCompile?: boolean\n  dynamicIds?: (string | number)[]\n  err?: Error & {\n    statusCode?: number\n    source?: typeof COMPILER_NAMES.server | typeof COMPILER_NAMES.edgeServer\n  }\n  gsp?: boolean\n  gssp?: boolean\n  customServer?: boolean\n  gip?: boolean\n  appGip?: boolean\n  locale?: string\n  locales?: readonly string[]\n  defaultLocale?: string\n  domainLocales?: readonly DomainLocale[]\n  scriptLoader?: any[]\n  isPreview?: boolean\n  notFoundSrcPage?: string\n}\n\n/**\n * `Next` context\n */\nexport interface NextPageContext {\n  /**\n   * Error object if encountered during rendering\n   */\n  err?: (Error & { statusCode?: number }) | null\n  /**\n   * `HTTP` request object.\n   */\n  req?: IncomingMessage\n  /**\n   * `HTTP` response object.\n   */\n  res?: ServerResponse\n  /**\n   * Path section of `URL`.\n   */\n  pathname: string\n  /**\n   * Query string section of `URL` parsed as an object.\n   */\n  query: ParsedUrlQuery\n  /**\n   * `String` of the actual path including query.\n   */\n  asPath?: string\n  /**\n   * The currently active locale\n   */\n  locale?: string\n  /**\n   * All configured locales\n   */\n  locales?: readonly string[]\n  /**\n   * The configured default locale\n   */\n  defaultLocale?: string\n  /**\n   * `Component` the tree of the App to use if needing to render separately\n   */\n  AppTree: AppTreeType\n}\n\nexport type AppContextType<Router extends NextRouter = NextRouter> = {\n  Component: NextComponentType<NextPageContext>\n  AppTree: AppTreeType\n  ctx: NextPageContext\n  router: Router\n}\n\nexport type AppInitialProps<PageProps = any> = {\n  pageProps: PageProps\n}\n\nexport type AppPropsType<\n  Router extends NextRouter = NextRouter,\n  PageProps = {},\n> = AppInitialProps<PageProps> & {\n  Component: NextComponentType<NextPageContext, any, any>\n  router: Router\n  __N_SSG?: boolean\n  __N_SSP?: boolean\n}\n\nexport type DocumentContext = NextPageContext & {\n  renderPage: RenderPage\n  defaultGetInitialProps(\n    ctx: DocumentContext,\n    options?: { nonce?: string }\n  ): Promise<DocumentInitialProps>\n}\n\nexport type DocumentInitialProps = RenderPageResult & {\n  styles?: React.ReactElement[] | Iterable<React.ReactNode> | JSX.Element\n}\n\nexport type DocumentProps = DocumentInitialProps & HtmlProps\n\n/**\n * Next `API` route request\n */\nexport interface NextApiRequest extends IncomingMessage {\n  /**\n   * Object of `query` values from url\n   */\n  query: Partial<{\n    [key: string]: string | string[]\n  }>\n  /**\n   * Object of `cookies` from header\n   */\n  cookies: Partial<{\n    [key: string]: string\n  }>\n\n  body: any\n\n  env: Env\n\n  draftMode?: boolean\n\n  preview?: boolean\n  /**\n   * Preview data set on the request, if any\n   * */\n  previewData?: PreviewData\n}\n\n/**\n * Send body of response\n */\ntype Send<T> = (body: T) => void\n\n/**\n * Next `API` route response\n */\nexport type NextApiResponse<Data = any> = ServerResponse & {\n  /**\n   * Send data `any` data in response\n   */\n  send: Send<Data>\n  /**\n   * Send data `json` data in response\n   */\n  json: Send<Data>\n  status: (statusCode: number) => NextApiResponse<Data>\n  redirect(url: string): NextApiResponse<Data>\n  redirect(status: number, url: string): NextApiResponse<Data>\n\n  /**\n   * Set draft mode\n   */\n  setDraftMode: (options: { enable: boolean }) => NextApiResponse<Data>\n\n  /**\n   * Set preview data for Next.js' prerender mode\n   */\n  setPreviewData: (\n    data: object | string,\n    options?: {\n      /**\n       * Specifies the number (in seconds) for the preview session to last for.\n       * The given number will be converted to an integer by rounding down.\n       * By default, no maximum age is set and the preview session finishes\n       * when the client shuts down (browser is closed).\n       */\n      maxAge?: number\n      /**\n       * Specifies the path for the preview session to work under. By default,\n       * the path is considered the \"default path\", i.e., any pages under \"/\".\n       */\n      path?: string\n    }\n  ) => NextApiResponse<Data>\n\n  /**\n   * Clear preview data for Next.js' prerender mode\n   */\n  clearPreviewData: (options?: { path?: string }) => NextApiResponse<Data>\n\n  /**\n   * Revalidate a specific page and regenerate it using On-Demand Incremental\n   * Static Regeneration.\n   * The path should be an actual path, not a rewritten path. E.g. for\n   * \"/blog/[slug]\" this should be \"/blog/post-1\".\n   * @link https://nextjs.org/docs/app/building-your-application/data-fetching/incremental-static-regeneration#on-demand-revalidation-with-revalidatepath\n   */\n  revalidate: (\n    urlPath: string,\n    opts?: {\n      unstable_onlyGenerated?: boolean\n    }\n  ) => Promise<void>\n}\n\n/**\n * Next `API` route handler\n */\nexport type NextApiHandler<T = any> = (\n  req: NextApiRequest,\n  res: NextApiResponse<T>\n) => unknown | Promise<unknown>\n\n/**\n * Utils\n */\nexport function execOnce<T extends (...args: any[]) => ReturnType<T>>(\n  fn: T\n): T {\n  let used = false\n  let result: ReturnType<T>\n\n  return ((...args: any[]) => {\n    if (!used) {\n      used = true\n      result = fn(...args)\n    }\n    return result\n  }) as T\n}\n\n// Scheme: https://tools.ietf.org/html/rfc3986#section-3.1\n// Absolute URL: https://tools.ietf.org/html/rfc3986#section-4.3\nconst ABSOLUTE_URL_REGEX = /^[a-zA-Z][a-zA-Z\\d+\\-.]*?:/\nexport const isAbsoluteUrl = (url: string) => ABSOLUTE_URL_REGEX.test(url)\n\nexport function getLocationOrigin() {\n  const { protocol, hostname, port } = window.location\n  return `${protocol}//${hostname}${port ? ':' + port : ''}`\n}\n\nexport function getURL() {\n  const { href } = window.location\n  const origin = getLocationOrigin()\n  return href.substring(origin.length)\n}\n\nexport function getDisplayName<P>(Component: ComponentType<P>) {\n  return typeof Component === 'string'\n    ? Component\n    : Component.displayName || Component.name || 'Unknown'\n}\n\nexport function isResSent(res: ServerResponse) {\n  return res.finished || res.headersSent\n}\n\nexport function normalizeRepeatedSlashes(url: string) {\n  const urlParts = url.split('?')\n  const urlNoQuery = urlParts[0]\n\n  return (\n    urlNoQuery\n      // first we replace any non-encoded backslashes with forward\n      // then normalize repeated forward slashes\n      .replace(/\\\\/g, '/')\n      .replace(/\\/\\/+/g, '/') +\n    (urlParts[1] ? `?${urlParts.slice(1).join('?')}` : '')\n  )\n}\n\nexport async function loadGetInitialProps<\n  C extends BaseContext,\n  IP = {},\n  P = {},\n>(App: NextComponentType<C, IP, P>, ctx: C): Promise<IP> {\n  if (process.env.NODE_ENV !== 'production') {\n    if (App.prototype?.getInitialProps) {\n      const message = `\"${getDisplayName(\n        App\n      )}.getInitialProps()\" is defined as an instance method - visit https://nextjs.org/docs/messages/get-initial-props-as-an-instance-method for more information.`\n      throw new Error(message)\n    }\n  }\n  // when called from _app `ctx` is nested in `ctx`\n  const res = ctx.res || (ctx.ctx && ctx.ctx.res)\n\n  if (!App.getInitialProps) {\n    if (ctx.ctx && ctx.Component) {\n      // @ts-ignore pageProps default\n      return {\n        pageProps: await loadGetInitialProps(ctx.Component, ctx.ctx),\n      }\n    }\n    return {} as IP\n  }\n\n  const props = await App.getInitialProps(ctx)\n\n  if (res && isResSent(res)) {\n    return props\n  }\n\n  if (!props) {\n    const message = `\"${getDisplayName(\n      App\n    )}.getInitialProps()\" should resolve to an object. But found \"${props}\" instead.`\n    throw new Error(message)\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (Object.keys(props).length === 0 && !ctx.ctx) {\n      console.warn(\n        `${getDisplayName(\n          App\n        )} returned an empty object from \\`getInitialProps\\`. This de-optimizes and prevents automatic static optimization. https://nextjs.org/docs/messages/empty-object-getInitialProps`\n      )\n    }\n  }\n\n  return props\n}\n\nexport const SP = typeof performance !== 'undefined'\nexport const ST =\n  SP &&\n  (['mark', 'measure', 'getEntriesByName'] as const).every(\n    (method) => typeof performance[method] === 'function'\n  )\n\nexport class DecodeError extends Error {}\nexport class NormalizeError extends Error {}\nexport class PageNotFoundError extends Error {\n  code: string\n\n  constructor(page: string) {\n    super()\n    this.code = 'ENOENT'\n    this.name = 'PageNotFoundError'\n    this.message = `Cannot find module for page: ${page}`\n  }\n}\n\nexport class MissingStaticPage extends Error {\n  constructor(page: string, message: string) {\n    super()\n    this.message = `Failed to load static file for page: ${page} ${message}`\n  }\n}\n\nexport class MiddlewareNotFoundError extends Error {\n  code: string\n  constructor() {\n    super()\n    this.code = 'ENOENT'\n    this.message = `Cannot find the middleware module`\n  }\n}\n\nexport interface CacheFs {\n  existsSync: typeof fs.existsSync\n  readFile: typeof fs.promises.readFile\n  readFileSync: typeof fs.readFileSync\n  writeFile(f: string, d: any): Promise<void>\n  mkdir(dir: string): Promise<void | string>\n  stat(f: string): Promise<{ mtime: Date }>\n}\n\nexport function stringifyError(error: Error) {\n  return JSON.stringify({ message: error.message, stack: error.stack })\n}\n","/**\n * Given a path this function will find the pathname, query and hash and return\n * them. This is useful to parse full paths on the client side.\n * @param path A path to parse e.g. /foo/bar?id=1#hash\n */\nexport function parsePath(path: string) {\n  const hashIndex = path.indexOf('#')\n  const queryIndex = path.indexOf('?')\n  const hasQuery = queryIndex > -1 && (hashIndex < 0 || queryIndex < hashIndex)\n\n  if (hasQuery || hashIndex > -1) {\n    return {\n      pathname: path.substring(0, hasQuery ? queryIndex : hashIndex),\n      query: hasQuery\n        ? path.substring(queryIndex, hashIndex > -1 ? hashIndex : undefined)\n        : '',\n      hash: hashIndex > -1 ? path.slice(hashIndex) : '',\n    }\n  }\n\n  return { pathname: path, query: '', hash: '' }\n}\n","import { parsePath } from './parse-path'\n\n/**\n * Adds the provided prefix to the given path. It first ensures that the path\n * is indeed starting with a slash.\n */\nexport function addPathPrefix(path: string, prefix?: string) {\n  if (!path.startsWith('/') || !prefix) {\n    return path\n  }\n\n  const { pathname, query, hash } = parsePath(path)\n  return `${prefix}${pathname}${query}${hash}`\n}\n","/**\n * Removes the trailing slash for a given route or page path. Preserves the\n * root page. Examples:\n *   - `/foo/bar/` -> `/foo/bar`\n *   - `/foo/bar` -> `/foo/bar`\n *   - `/` -> `/`\n */\nexport function removeTrailingSlash(route: string) {\n  return route.replace(/\\/$/, '') || '/'\n}\n","import { removeTrailingSlash } from '../shared/lib/router/utils/remove-trailing-slash'\nimport { parsePath } from '../shared/lib/router/utils/parse-path'\n\n/**\n * Normalizes the trailing slash of a path according to the `trailingSlash` option\n * in `next.config.js`.\n */\nexport const normalizePathTrailingSlash = (path: string) => {\n  if (!path.startsWith('/') || process.env.__NEXT_MANUAL_TRAILING_SLASH) {\n    return path\n  }\n\n  const { pathname, query, hash } = parsePath(path)\n  if (process.env.__NEXT_TRAILING_SLASH) {\n    if (/\\.[^/]+\\/?$/.test(pathname)) {\n      return `${removeTrailingSlash(pathname)}${query}${hash}`\n    } else if (pathname.endsWith('/')) {\n      return `${pathname}${query}${hash}`\n    } else {\n      return `${pathname}/${query}${hash}`\n    }\n  }\n\n  return `${removeTrailingSlash(pathname)}${query}${hash}`\n}\n","import { addPathPrefix } from '../shared/lib/router/utils/add-path-prefix'\nimport { normalizePathTrailingSlash } from './normalize-trailing-slash'\n\nconst basePath = (process.env.__NEXT_ROUTER_BASEPATH as string) || ''\n\nexport function addBasePath(path: string, required?: boolean): string {\n  return normalizePathTrailingSlash(\n    process.env.__NEXT_MANUAL_CLIENT_BASE_PATH && !required\n      ? path\n      : addPathPrefix(path, basePath)\n  )\n}\n","/**\n * Shared types and constants for the Segment Cache.\n */\n\nexport const enum NavigationResultTag {\n  MPA,\n  Success,\n  NoOp,\n  Async,\n}\n\n/**\n * The priority of the prefetch task. Higher numbers are higher priority.\n */\nexport const enum PrefetchPriority {\n  /**\n   * Assigned to the most recently hovered/touched link. Special network\n   * bandwidth is reserved for this task only. There's only ever one Intent-\n   * priority task at a time; when a new Intent task is scheduled, the previous\n   * one is bumped down to Default.\n   */\n  Intent = 2,\n  /**\n   * The default priority for prefetch tasks.\n   */\n  Default = 1,\n  /**\n   * Assigned to tasks when they spawn non-blocking background work, like\n   * revalidating a partially cached entry to see if more data is available.\n   */\n  Background = 0,\n}\n\nexport const enum FetchStrategy {\n  // Deliberately ordered so we can easily compare two segments\n  // and determine if one segment is \"more specific\" than another\n  // (i.e. if it's likely that it contains more data)\n  LoadingBoundary = 0,\n  PPR = 1,\n  PPRRuntime = 2,\n  Full = 3,\n}\n\n/**\n * A subset of fetch strategies used for prefetch tasks.\n * A prefetch task can't know if it should use `PPR` or `LoadingBoundary`\n * until we complete the initial tree prefetch request, so we use `PPR` to signal both cases\n * and adjust it based on the route when actually fetching.\n * */\nexport type PrefetchTaskFetchStrategy =\n  | FetchStrategy.PPR\n  | FetchStrategy.PPRRuntime\n  | FetchStrategy.Full\n","// TypeScript trick to simulate opaque types, like in Flow.\ntype Opaque<K, T> = T & { __brand: K }\n\n// Only functions in this module should be allowed to create CacheKeys.\nexport type NormalizedPathname = Opaque<'NormalizedPathname', string>\nexport type NormalizedSearch = Opaque<'NormalizedSearch', string>\nexport type NormalizedNextUrl = Opaque<'NormalizedNextUrl', string>\n\nexport type RouteCacheKey = Opaque<\n  'RouteCacheKey',\n  {\n    pathname: NormalizedPathname\n    search: NormalizedSearch\n    nextUrl: NormalizedNextUrl | null\n\n    // TODO: Eventually the dynamic params will be added here, too.\n  }\n>\n\nexport function createCacheKey(\n  originalHref: string,\n  nextUrl: string | null\n): RouteCacheKey {\n  const originalUrl = new URL(originalHref)\n  const cacheKey = {\n    pathname: originalUrl.pathname as NormalizedPathname,\n    search: originalUrl.search as NormalizedSearch,\n    nextUrl: nextUrl as NormalizedNextUrl | null,\n  } as RouteCacheKey\n  return cacheKey\n}\n","/**\n * App Router types - Client-safe types for the Next.js App Router\n *\n * This file contains type definitions that can be safely imported\n * by both client-side and server-side code without circular dependencies.\n */\nimport type { FetchServerResponseResult } from '../../client/components/router-reducer/fetch-server-response'\nimport type React from 'react'\n\nexport type LoadingModuleData =\n  | [React.JSX.Element, React.ReactNode, React.ReactNode]\n  | null\n\n/** viewport metadata node */\nexport type HeadData = React.ReactNode\n\nexport type ChildSegmentMap = Map<string, CacheNode>\n\n/**\n * Cache node used in app-router / layout-router.\n */\nexport type CacheNode = ReadyCacheNode | LazyCacheNode\n\nexport type LazyCacheNode = {\n  /**\n   * When rsc is null, this is a lazily-initialized cache node.\n   *\n   * If the app attempts to render it, it triggers a lazy data fetch,\n   * postpones the render, and schedules an update to a new tree.\n   *\n   * TODO: This mechanism should not be used when PPR is enabled, though it\n   * currently is in some cases until we've implemented partial\n   * segment fetching.\n   */\n  rsc: null\n\n  /**\n   * A prefetched version of the segment data. See explanation in corresponding\n   * field of ReadyCacheNode (below).\n   *\n   * Since LazyCacheNode mostly only exists in the non-PPR implementation, this\n   * will usually be null, but it could have been cloned from a previous\n   * CacheNode that was created by the PPR implementation. Eventually we want\n   * to migrate everything away from LazyCacheNode entirely.\n   */\n  prefetchRsc: React.ReactNode\n\n  /**\n   * A pending response for the lazy data fetch. If this is not present\n   * during render, it is lazily created.\n   */\n  lazyData: Promise<FetchServerResponseResult> | null\n\n  prefetchHead: HeadData | null\n\n  head: HeadData\n\n  loading: LoadingModuleData | Promise<LoadingModuleData>\n\n  /**\n   * Child parallel routes.\n   */\n  parallelRoutes: Map<string, ChildSegmentMap>\n\n  /**\n   * The timestamp of the navigation that last updated the CacheNode's data. If\n   * a CacheNode is reused from a previous navigation, this value is not\n   * updated. Used to track the staleness of the data.\n   */\n  navigatedAt: number\n}\n\nexport type ReadyCacheNode = {\n  /**\n   * When rsc is not null, it represents the RSC data for the\n   * corresponding segment.\n   *\n   * `null` is a valid React Node but because segment data is always a\n   * <LayoutRouter> component, we can use `null` to represent empty.\n   *\n   * TODO: For additional type safety, update this type to\n   * Exclude<React.ReactNode, null>. Need to update createEmptyCacheNode to\n   * accept rsc as an argument, or just inline the callers.\n   */\n  rsc: React.ReactNode\n\n  /**\n   * Represents a static version of the segment that can be shown immediately,\n   * and may or may not contain dynamic holes. It's prefetched before a\n   * navigation occurs.\n   *\n   * During rendering, we will choose whether to render `rsc` or `prefetchRsc`\n   * with `useDeferredValue`. As with the `rsc` field, a value of `null` means\n   * no value was provided. In this case, the LayoutRouter will go straight to\n   * rendering the `rsc` value; if that one is also missing, it will suspend and\n   * trigger a lazy fetch.\n   */\n  prefetchRsc: React.ReactNode\n\n  /**\n   * There should never be a lazy data request in this case.\n   */\n  lazyData: null\n  prefetchHead: HeadData | null\n\n  head: HeadData\n\n  loading: LoadingModuleData | Promise<LoadingModuleData>\n\n  parallelRoutes: Map<string, ChildSegmentMap>\n\n  navigatedAt: number\n}\n\nexport type DynamicParamTypes =\n  | 'catchall'\n  | 'catchall-intercepted-(..)(..)'\n  | 'catchall-intercepted-(.)'\n  | 'catchall-intercepted-(..)'\n  | 'catchall-intercepted-(...)'\n  | 'optional-catchall'\n  | 'dynamic'\n  | 'dynamic-intercepted-(..)(..)'\n  | 'dynamic-intercepted-(.)'\n  | 'dynamic-intercepted-(..)'\n  | 'dynamic-intercepted-(...)'\n\nexport type DynamicParamTypesShort =\n  | 'c'\n  | 'ci(..)(..)'\n  | 'ci(.)'\n  | 'ci(..)'\n  | 'ci(...)'\n  | 'oc'\n  | 'd'\n  | 'di(..)(..)'\n  | 'di(.)'\n  | 'di(..)'\n  | 'di(...)'\n\nexport type Segment =\n  | string\n  | [\n      // Param name\n      paramName: string,\n      // Param cache key (almost the same as the value, but arrays are\n      // concatenated into strings)\n      // TODO: We should change this to just be the value. Currently we convert\n      // it back to a value when passing to useParams. It only needs to be\n      // a string when converted to a a cache key, but that doesn't mean we\n      // need to store it as that representation.\n      paramCacheKey: string,\n      // Dynamic param type\n      dynamicParamType: DynamicParamTypesShort,\n    ]\n\n/**\n * Router state\n */\nexport type FlightRouterState = [\n  segment: Segment,\n  parallelRoutes: { [parallelRouterKey: string]: FlightRouterState },\n  url?: string | null,\n  /**\n   * \"refresh\" and \"refetch\", despite being similarly named, have different\n   * semantics:\n   * - \"refetch\" is used during a request to inform the server where rendering\n   *   should start from.\n   *\n   * - \"refresh\" is used by the client to mark that a segment should re-fetch the\n   *   data from the server for the current segment. It uses the \"url\" property\n   *   above to determine where to fetch from.\n   *\n   * - \"inside-shared-layout\" is used during a prefetch request to inform the\n   *   server that even if the segment matches, it should be treated as if it's\n   *   within the \"new\" part of a navigation — inside the shared layout. If\n   *   the segment doesn't match, then it has no effect, since it would be\n   *   treated as new regardless. If it does match, though, the server does not\n   *   need to render it, because the client already has it.\n   *\n   * - \"metadata-only\" instructs the server to skip rendering the segments and\n   *   only send the head data.\n   *\n   *   A bit confusing, but that's because it has only one extremely narrow use\n   *   case — during a non-PPR prefetch, the server uses it to find the first\n   *   loading boundary beneath a shared layout.\n   *\n   *   TODO: We should rethink the protocol for dynamic requests. It might not\n   *   make sense for the client to send a FlightRouterState, since this type is\n   *   overloaded with concerns.\n   */\n  refresh?:\n    | 'refetch'\n    | 'refresh'\n    | 'inside-shared-layout'\n    | 'metadata-only'\n    | null,\n  isRootLayout?: boolean,\n  /**\n   * Only present when responding to a tree prefetch request. Indicates whether\n   * there is a loading boundary somewhere in the tree. The client cache uses\n   * this to determine if it can skip the data prefetch request.\n   */\n  hasLoadingBoundary?: HasLoadingBoundary,\n]\n\nexport const enum HasLoadingBoundary {\n  // There is a loading boundary in this particular segment\n  SegmentHasLoadingBoundary = 1,\n  // There is a loading boundary somewhere in the subtree (but not in\n  // this segment)\n  SubtreeHasLoadingBoundary = 2,\n  // There is no loading boundary in this segment or any of its descendants\n  SubtreeHasNoLoadingBoundary = 3,\n}\n\n/**\n * Individual Flight response path\n */\nexport type FlightSegmentPath =\n  // Uses `any` as repeating pattern can't be typed.\n  | any[]\n  // Looks somewhat like this\n  | [\n      segment: Segment,\n      parallelRouterKey: string,\n      segment: Segment,\n      parallelRouterKey: string,\n      segment: Segment,\n      parallelRouterKey: string,\n    ]\n\n/**\n * Represents a tree of segments and the Flight data (i.e. React nodes) that\n * correspond to each one. The tree is isomorphic to the FlightRouterState;\n * however in the future we want to be able to fetch arbitrary partial segments\n * without having to fetch all its children. So this response format will\n * likely change.\n */\nexport type CacheNodeSeedData = [\n  node: React.ReactNode | null,\n  parallelRoutes: {\n    [parallelRouterKey: string]: CacheNodeSeedData | null\n  },\n  loading: LoadingModuleData | Promise<LoadingModuleData>,\n  isPartial: boolean,\n  /** TODO: this doesn't feel like it belongs here, because it's only used during build, in `collectSegmentData` */\n  hasRuntimePrefetch: boolean,\n]\n\nexport type FlightDataSegment = [\n  /* segment of the rendered slice: */ Segment,\n  /* treePatch */ FlightRouterState,\n  /* cacheNodeSeedData */ CacheNodeSeedData | null, // Can be null during prefetch if there's no loading component\n  /* head: viewport */ HeadData,\n  /* isHeadPartial */ boolean,\n]\n\nexport type FlightDataPath =\n  // Uses `any` as repeating pattern can't be typed.\n  | any[]\n  // Looks somewhat like this\n  | [\n      // Holds full path to the segment.\n      ...FlightSegmentPath[],\n      ...FlightDataSegment,\n    ]\n\n/**\n * The Flight response data\n */\nexport type FlightData = Array<FlightDataPath> | string\n\nexport type ActionResult = Promise<any>\n\nexport type InitialRSCPayload = {\n  /** buildId */\n  b: string\n  /** initialCanonicalUrlParts */\n  c: string[]\n  /** initialRenderedSearch */\n  q: string\n  /** couldBeIntercepted */\n  i: boolean\n  /** initialFlightData */\n  f: FlightDataPath[]\n  /** missingSlots */\n  m: Set<string> | undefined\n  /** GlobalError */\n  G: [React.ComponentType<any>, React.ReactNode | undefined]\n  /** prerendered */\n  S: boolean\n}\n\n// Response from `createFromFetch` for normal rendering\nexport type NavigationFlightResponse = {\n  /** buildId */\n  b: string\n  /** flightData */\n  f: FlightData\n  /** prerendered */\n  S: boolean\n  /** runtimePrefetch - [isPartial, staleTime]. Only present in runtime prefetch responses. */\n  rp?: [boolean, number]\n}\n\n// Response from `createFromFetch` for server actions. Action's flight data can be null\nexport type ActionFlightResponse = {\n  /** actionResult */\n  a: ActionResult\n  /** buildId */\n  b: string\n  /** flightData */\n  f: FlightData\n}\n\nexport type RSCPayload =\n  | InitialRSCPayload\n  | NavigationFlightResponse\n  | ActionFlightResponse\n","import type { Segment } from '../../shared/lib/app-router-types'\n\nexport const matchSegment = (\n  existingSegment: Segment,\n  segment: Segment\n): boolean => {\n  // segment is either Array or string\n  if (typeof existingSegment === 'string') {\n    if (typeof segment === 'string') {\n      // Common case: segment is just a string\n      return existingSegment === segment\n    }\n    return false\n  }\n\n  if (typeof segment === 'string') {\n    return false\n  }\n  return existingSegment[0] === segment[0] && existingSegment[1] === segment[1]\n}\n","export const RSC_HEADER = 'rsc' as const\nexport const ACTION_HEADER = 'next-action' as const\n// TODO: Instead of sending the full router state, we only need to send the\n// segment path. Saves bytes. Then we could also use this field for segment\n// prefetches, which also need to specify a particular segment.\nexport const NEXT_ROUTER_STATE_TREE_HEADER = 'next-router-state-tree' as const\nexport const NEXT_ROUTER_PREFETCH_HEADER = 'next-router-prefetch' as const\n// This contains the path to the segment being prefetched.\n// TODO: If we change next-router-state-tree to be a segment path, we can use\n// that instead. Then next-router-prefetch and next-router-segment-prefetch can\n// be merged into a single enum.\nexport const NEXT_ROUTER_SEGMENT_PREFETCH_HEADER =\n  'next-router-segment-prefetch' as const\nexport const NEXT_HMR_REFRESH_HEADER = 'next-hmr-refresh' as const\nexport const NEXT_HMR_REFRESH_HASH_COOKIE = '__next_hmr_refresh_hash__' as const\nexport const NEXT_URL = 'next-url' as const\nexport const RSC_CONTENT_TYPE_HEADER = 'text/x-component' as const\n\nexport const FLIGHT_HEADERS = [\n  RSC_HEADER,\n  NEXT_ROUTER_STATE_TREE_HEADER,\n  NEXT_ROUTER_PREFETCH_HEADER,\n  NEXT_HMR_REFRESH_HEADER,\n  NEXT_ROUTER_SEGMENT_PREFETCH_HEADER,\n] as const\n\nexport const NEXT_RSC_UNION_QUERY = '_rsc' as const\n\nexport const NEXT_ROUTER_STALE_TIME_HEADER = 'x-nextjs-stale-time' as const\nexport const NEXT_DID_POSTPONE_HEADER = 'x-nextjs-postponed' as const\nexport const NEXT_REWRITTEN_PATH_HEADER = 'x-nextjs-rewritten-path' as const\nexport const NEXT_REWRITTEN_QUERY_HEADER = 'x-nextjs-rewritten-query' as const\nexport const NEXT_IS_PRERENDER_HEADER = 'x-nextjs-prerender' as const\nexport const NEXT_ACTION_NOT_FOUND_HEADER = 'x-nextjs-action-not-found' as const\nexport const NEXT_REQUEST_ID_HEADER = 'x-nextjs-request-id' as const\nexport const NEXT_HTML_REQUEST_ID_HEADER = 'x-nextjs-html-request-id' as const\n","import type { CacheNode } from '../../../shared/lib/app-router-types'\nimport type {\n  FlightRouterState,\n  FlightSegmentPath,\n} from '../../../shared/lib/app-router-types'\nimport type { FetchServerResponseResult } from './fetch-server-response'\n\nexport const ACTION_REFRESH = 'refresh'\nexport const ACTION_NAVIGATE = 'navigate'\nexport const ACTION_RESTORE = 'restore'\nexport const ACTION_SERVER_PATCH = 'server-patch'\nexport const ACTION_HMR_REFRESH = 'hmr-refresh'\nexport const ACTION_SERVER_ACTION = 'server-action'\n\nexport type RouterChangeByServerResponse = ({\n  navigatedAt,\n  previousTree,\n  serverResponse,\n}: {\n  navigatedAt: number\n  previousTree: FlightRouterState\n  serverResponse: FetchServerResponseResult\n}) => void\n\nexport interface Mutable {\n  mpaNavigation?: boolean\n  patchedTree?: FlightRouterState\n  renderedSearch?: string\n  canonicalUrl?: string\n  scrollableSegments?: FlightSegmentPath[]\n  pendingPush?: boolean\n  cache?: CacheNode\n  hashFragment?: string\n  shouldScroll?: boolean\n  preserveCustomHistoryState?: boolean\n  onlyHashChange?: boolean\n  collectedDebugInfo?: Array<unknown>\n}\n\nexport interface ServerActionMutable extends Mutable {\n  inFlightServerAction?: Promise<any> | null\n}\n\n/**\n * Refresh triggers a refresh of the full page data.\n * - fetches the Flight data and fills rsc at the root of the cache.\n * - The router state is updated at the root.\n */\nexport interface RefreshAction {\n  type: typeof ACTION_REFRESH\n  origin: Location['origin']\n}\n\nexport interface HmrRefreshAction {\n  type: typeof ACTION_HMR_REFRESH\n  origin: Location['origin']\n}\n\nexport type ServerActionDispatcher = (\n  args: Omit<\n    ServerActionAction,\n    'type' | 'mutable' | 'navigate' | 'changeByServerResponse' | 'cache'\n  >\n) => void\n\nexport interface ServerActionAction {\n  type: typeof ACTION_SERVER_ACTION\n  actionId: string\n  actionArgs: any[]\n  resolve: (value: any) => void\n  reject: (reason?: any) => void\n  didRevalidate?: boolean\n}\n\n/**\n * Navigate triggers a navigation to the provided url. It supports two types: `push` and `replace`.\n *\n * `navigateType`:\n * - `push` - pushes a new history entry in the browser history\n * - `replace` - replaces the current history entry in the browser history\n *\n * Navigate has multiple cache heuristics:\n * - page was prefetched\n *  - Apply router state tree from prefetch\n *  - Apply Flight data from prefetch to the cache\n *  - If Flight data is a string, it's a redirect and the state is updated to trigger a redirect\n *  - Check if hard navigation is needed\n *    - Hard navigation happens when a dynamic parameter below the common layout changed\n *    - When hard navigation is needed the cache is invalidated below the flightSegmentPath\n *    - The missing cache nodes of the page will be fetched in layout-router and trigger the SERVER_PATCH action\n *  - If hard navigation is not needed\n *    - The cache is reused\n *    - If any cache nodes are missing they'll be fetched in layout-router and trigger the SERVER_PATCH action\n * - page was not prefetched\n *  - The navigate was called from `next/router` (`router.push()` / `router.replace()`) / `next/link` without prefetched data available (e.g. the prefetch didn't come back from the server before clicking the link)\n *    - Flight data is fetched in the reducer (suspends the reducer)\n *    - Router state tree is created based on Flight data\n *    - Cache is filled based on the Flight data\n *\n * Above steps explain 3 cases:\n * - `soft` - Reuses the existing cache and fetches missing nodes in layout-router.\n * - `hard` - Creates a new cache where cache nodes are removed below the common layout and fetches missing nodes in layout-router.\n * - `optimistic` (explicit no prefetch) - Creates a new cache and kicks off the data fetch in the reducer. The data fetch is awaited in the layout-router.\n */\nexport interface NavigateAction {\n  type: typeof ACTION_NAVIGATE\n  url: URL\n  isExternalUrl: boolean\n  locationSearch: Location['search']\n  navigateType: 'push' | 'replace'\n  shouldScroll: boolean\n}\n\n/**\n * Restore applies the provided router state.\n * - Used for `popstate` (back/forward navigation) where a known router state has to be applied.\n * - Also used when syncing the router state with `pushState`/`replaceState` calls.\n * - Router state is applied as-is from the history state, if available.\n * - If the history state does not contain the router state, the existing router state is used.\n * - If any cache node is missing it will be fetched in layout-router during rendering and the server-patch case.\n * - If existing cache nodes match these are used.\n */\nexport interface RestoreAction {\n  type: typeof ACTION_RESTORE\n  url: URL\n  historyState: AppHistoryState | undefined\n}\n\nexport type AppHistoryState = {\n  tree: FlightRouterState\n  renderedSearch: string\n}\n\n/**\n * Server-patch applies the provided Flight data to the cache and router tree.\n * - Only triggered in layout-router.\n * - Creates a new cache and router state with the Flight data applied.\n */\nexport interface ServerPatchAction {\n  type: typeof ACTION_SERVER_PATCH\n  navigatedAt: number\n  serverResponse: FetchServerResponseResult\n  previousTree: FlightRouterState\n}\n\n/**\n * PrefetchKind defines the type of prefetching that should be done.\n * - `auto` - if the page is dynamic, prefetch the page data partially, if static prefetch the page data fully.\n * - `full` - prefetch the page data fully.\n * - `temporary` - a temporary prefetch entry is added to the cache, this is used when prefetch={false} is used in next/link or when you push a route programmatically.\n */\n\nexport enum PrefetchKind {\n  AUTO = 'auto',\n  FULL = 'full',\n  TEMPORARY = 'temporary',\n}\n\n/**\n * Prefetch adds the provided FlightData to the prefetch cache\n * - Creates the router state tree based on the patch in FlightData\n * - Adds the FlightData to the prefetch cache\n * - In ACTION_NAVIGATE the prefetch cache is checked and the router state tree and FlightData are applied.\n */\n\nexport interface PushRef {\n  /**\n   * If the app-router should push a new history entry in app-router's useEffect()\n   */\n  pendingPush: boolean\n  /**\n   * Multi-page navigation through location.href.\n   */\n  mpaNavigation: boolean\n  /**\n   * Skip applying the router state to the browser history state.\n   */\n  preserveCustomHistoryState: boolean\n}\n\nexport type FocusAndScrollRef = {\n  /**\n   * If focus and scroll should be set in the layout-router's useEffect()\n   */\n  apply: boolean\n  /**\n   * The hash fragment that should be scrolled to.\n   */\n  hashFragment: string | null\n  /**\n   * The paths of the segments that should be focused.\n   */\n  segmentPaths: FlightSegmentPath[]\n  /**\n   * If only the URLs hash fragment changed\n   */\n  onlyHashChange: boolean\n}\n\n/**\n * Handles keeping the state of app-router.\n */\nexport type AppRouterState = {\n  /**\n   * The router state, this is written into the history state in app-router using replaceState/pushState.\n   * - Has to be serializable as it is written into the history state.\n   * - Holds which segments and parallel routes are shown on the screen.\n   */\n  tree: FlightRouterState\n  /**\n   * The cache holds React nodes for every segment that is shown on screen as well as previously shown segments.\n   * It also holds in-progress data requests.\n   */\n  cache: CacheNode\n  /**\n   * Decides if the update should create a new history entry and if the navigation has to trigger a browser navigation.\n   */\n  pushRef: PushRef\n  /**\n   * Decides if the update should apply scroll and focus management.\n   */\n  focusAndScrollRef: FocusAndScrollRef\n  /**\n   * The canonical url that is pushed/replaced.\n   * - This is the url you see in the browser.\n   */\n  canonicalUrl: string\n  renderedSearch: string\n  /**\n   * The underlying \"url\" representing the UI state, which is used for intercepting routes.\n   */\n  nextUrl: string | null\n\n  /**\n   * The previous next-url that was used previous to a dynamic navigation.\n   */\n  previousNextUrl: string | null\n\n  debugInfo: Array<unknown> | null\n}\n\nexport type ReadonlyReducerState = Readonly<AppRouterState>\nexport type ReducerState =\n  | (Promise<AppRouterState> & { _debugInfo?: Array<unknown> })\n  | AppRouterState\nexport type ReducerActions = Readonly<\n  | RefreshAction\n  | NavigateAction\n  | RestoreAction\n  | ServerPatchAction\n  | HmrRefreshAction\n  | ServerActionAction\n>\n","/**\n * Check to see if a value is Thenable.\n *\n * @param promise the maybe-thenable value\n * @returns true if the value is thenable\n */\nexport function isThenable<T = unknown>(\n  promise: Promise<T> | T\n): promise is Promise<T> {\n  return (\n    promise !== null &&\n    typeof promise === 'object' &&\n    'then' in promise &&\n    typeof promise.then === 'function'\n  )\n}\n","import type { Dispatch } from 'react'\nimport React, { use, useMemo } from 'react'\nimport { isThenable } from '../../shared/lib/is-thenable'\nimport type { AppRouterActionQueue } from './app-router-instance'\nimport type {\n  AppRouterState,\n  ReducerActions,\n  ReducerState,\n} from './router-reducer/router-reducer-types'\n\n// The app router state lives outside of React, so we can import the dispatch\n// method directly wherever we need it, rather than passing it around via props\n// or context.\nlet dispatch: Dispatch<ReducerActions> | null = null\n\nexport function dispatchAppRouterAction(action: ReducerActions) {\n  if (dispatch === null) {\n    throw new Error(\n      'Internal Next.js error: Router action dispatched before initialization.'\n    )\n  }\n  dispatch(action)\n}\n\nconst __DEV__ = process.env.NODE_ENV !== 'production'\nconst promisesWithDebugInfo: WeakMap<\n  Promise<AppRouterState>,\n  Promise<AppRouterState> & { _debugInfo?: Array<unknown> }\n> = __DEV__ ? new WeakMap() : (null as any)\n\nexport function useActionQueue(\n  actionQueue: AppRouterActionQueue\n): AppRouterState {\n  const [state, setState] = React.useState<ReducerState>(actionQueue.state)\n\n  // Because of a known issue that requires to decode Flight streams inside the\n  // render phase, we have to be a bit clever and assign the dispatch method to\n  // a module-level variable upon initialization. The useState hook in this\n  // module only exists to synchronize state that lives outside of React.\n  // Ideally, what we'd do instead is pass the state as a prop to root.render;\n  // this is conceptually how we're modeling the app router state, despite the\n  // weird implementation details.\n  if (process.env.NODE_ENV !== 'production') {\n    const { useAppDevRenderingIndicator } =\n      require('../../next-devtools/userspace/use-app-dev-rendering-indicator') as typeof import('../../next-devtools/userspace/use-app-dev-rendering-indicator')\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    const appDevRenderingIndicator = useAppDevRenderingIndicator()\n\n    dispatch = (action: ReducerActions) => {\n      appDevRenderingIndicator(() => {\n        actionQueue.dispatch(action, setState)\n      })\n    }\n  } else {\n    dispatch = (action: ReducerActions) =>\n      actionQueue.dispatch(action, setState)\n  }\n\n  // When navigating to a non-prefetched route, then App Router state will be\n  // blocked until the server responds. We need to transfer the `_debugInfo`\n  // from the underlying Flight response onto the top-level promise that is\n  // passed to React (via `use`) so that the latency is accurately represented\n  // in the React DevTools.\n  const stateWithDebugInfo = useMemo(() => {\n    if (!__DEV__) {\n      return state\n    }\n\n    if (isThenable(state)) {\n      // useMemo can't be used to cache a Promise since the memoized value is thrown\n      // away when we suspend. So we use a WeakMap to cache the Promise with debug info.\n      let promiseWithDebugInfo = promisesWithDebugInfo.get(state)\n      if (promiseWithDebugInfo === undefined) {\n        const debugInfo: Array<unknown> = []\n        promiseWithDebugInfo = Promise.resolve(state).then((asyncState) => {\n          if (asyncState.debugInfo !== null) {\n            debugInfo.push(...asyncState.debugInfo)\n          }\n          return asyncState\n        }) as Promise<AppRouterState> & { _debugInfo?: Array<unknown> }\n        promiseWithDebugInfo._debugInfo = debugInfo\n\n        promisesWithDebugInfo.set(state, promiseWithDebugInfo)\n      }\n\n      return promiseWithDebugInfo\n    }\n    return state\n  }, [state])\n\n  return isThenable(stateWithDebugInfo)\n    ? use(stateWithDebugInfo)\n    : stateWithDebugInfo\n}\n","import { startTransition } from 'react'\nimport { ACTION_SERVER_ACTION } from './components/router-reducer/router-reducer-types'\nimport { dispatchAppRouterAction } from './components/use-action-queue'\n\nexport async function callServer(actionId: string, actionArgs: any[]) {\n  return new Promise((resolve, reject) => {\n    startTransition(() => {\n      dispatchAppRouterAction({\n        type: ACTION_SERVER_ACTION,\n        actionId,\n        actionArgs,\n        resolve,\n        reject,\n      })\n    })\n  })\n}\n","const basePath = process.env.__NEXT_ROUTER_BASEPATH || ''\nconst pathname = `${basePath}/__nextjs_source-map`\n\nexport const findSourceMapURL =\n  process.env.NODE_ENV === 'development'\n    ? function findSourceMapURL(filename: string): string | null {\n        if (filename === '') {\n          return null\n        }\n\n        if (\n          filename.startsWith(document.location.origin) &&\n          filename.includes('/_next/static')\n        ) {\n          // This is a request for a client chunk. This can only happen when\n          // using Turbopack. In this case, since we control how those source\n          // maps are generated, we can safely assume that the sourceMappingURL\n          // is relative to the filename, with an added `.map` extension. The\n          // browser can just request this file, and it gets served through the\n          // normal dev server, without the need to route this through\n          // the `/__nextjs_source-map` dev middleware.\n          return `${filename}.map`\n        }\n\n        const url = new URL(pathname, document.location.origin)\n        url.searchParams.set('filename', filename)\n\n        return url.href\n      }\n    : undefined\n","import { PAGE_SEGMENT_KEY } from '../segment'\nimport type { Segment as FlightRouterStateSegment } from '../app-router-types'\n\n// TypeScript trick to simulate opaque types, like in Flow.\ntype Opaque<K, T> = T & { __brand: K }\n\nexport type SegmentRequestKeyPart = Opaque<'SegmentRequestKeyPart', string>\nexport type SegmentRequestKey = Opaque<'SegmentRequestKey', string>\n\nexport const ROOT_SEGMENT_REQUEST_KEY = '' as SegmentRequestKey\n\nexport const HEAD_REQUEST_KEY = '/_head' as SegmentRequestKey\n\nexport function createSegmentRequestKeyPart(\n  segment: FlightRouterStateSegment\n): SegmentRequestKeyPart {\n  if (typeof segment === 'string') {\n    if (segment.startsWith(PAGE_SEGMENT_KEY)) {\n      // The Flight Router State type sometimes includes the search params in\n      // the page segment. However, the Segment Cache tracks this as a separate\n      // key. So, we strip the search params here, and then add them back when\n      // the cache entry is turned back into a FlightRouterState. This is an\n      // unfortunate consequence of the FlightRouteState being used both as a\n      // transport type and as a cache key; we'll address this once more of the\n      // Segment Cache implementation has settled.\n      // TODO: We should hoist the search params out of the FlightRouterState\n      // type entirely, This is our plan for dynamic route params, too.\n      return PAGE_SEGMENT_KEY as SegmentRequestKeyPart\n    }\n    const safeName =\n      // TODO: FlightRouterState encodes Not Found routes as \"/_not-found\".\n      // But params typically don't include the leading slash. We should use\n      // a different encoding to avoid this special case.\n      segment === '/_not-found'\n        ? '_not-found'\n        : encodeToFilesystemAndURLSafeString(segment)\n    // Since this is not a dynamic segment, it's fully encoded. It does not\n    // need to be \"hydrated\" with a param value.\n    return safeName as SegmentRequestKeyPart\n  }\n\n  const name = segment[0]\n  const paramType = segment[2]\n  const safeName = encodeToFilesystemAndURLSafeString(name)\n\n  const encodedName = '$' + paramType + '$' + safeName\n  return encodedName as SegmentRequestKeyPart\n}\n\nexport function appendSegmentRequestKeyPart(\n  parentRequestKey: SegmentRequestKey,\n  parallelRouteKey: string,\n  childRequestKeyPart: SegmentRequestKeyPart\n): SegmentRequestKey {\n  // Aside from being filesystem safe, segment keys are also designed so that\n  // each segment and parallel route creates its own subdirectory. Roughly in\n  // the same shape as the source app directory. This is mostly just for easier\n  // debugging (you can open up the build folder and navigate the output); if\n  // we wanted to do we could just use a flat structure.\n\n  // Omit the parallel route key for children, since this is the most\n  // common case. Saves some bytes (and it's what the app directory does).\n  const slotKey =\n    parallelRouteKey === 'children'\n      ? childRequestKeyPart\n      : `@${encodeToFilesystemAndURLSafeString(parallelRouteKey)}/${childRequestKeyPart}`\n  return (parentRequestKey + '/' + slotKey) as SegmentRequestKey\n}\n\n// Define a regex pattern to match the most common characters found in a route\n// param. It excludes anything that might not be cross-platform filesystem\n// compatible, like |. It does not need to be precise because the fallback is to\n// just base64url-encode the whole parameter, which is fine; we just don't do it\n// by default for compactness, and for easier debugging.\nconst simpleParamValueRegex = /^[a-zA-Z0-9\\-_@]+$/\n\nfunction encodeToFilesystemAndURLSafeString(value: string) {\n  if (simpleParamValueRegex.test(value)) {\n    return value\n  }\n  // If there are any unsafe characters, base64url-encode the entire value.\n  // We also add a ! prefix so it doesn't collide with the simple case.\n  const base64url = btoa(value)\n    .replace(/\\+/g, '-') // Replace '+' with '-'\n    .replace(/\\//g, '_') // Replace '/' with '_'\n    .replace(/=+$/, '') // Remove trailing '='\n  return '!' + base64url\n}\n\nexport function convertSegmentPathToStaticExportFilename(\n  segmentPath: string\n): string {\n  return `__next${segmentPath.replace(/\\//g, '.')}.txt`\n}\n","import type { DynamicParamTypesShort } from '../shared/lib/app-router-types'\nimport {\n  addSearchParamsIfPageSegment,\n  DEFAULT_SEGMENT_KEY,\n  PAGE_SEGMENT_KEY,\n} from '../shared/lib/segment'\nimport { ROOT_SEGMENT_REQUEST_KEY } from '../shared/lib/segment-cache/segment-value-encoding'\nimport {\n  NEXT_REWRITTEN_PATH_HEADER,\n  NEXT_REWRITTEN_QUERY_HEADER,\n  NEXT_RSC_UNION_QUERY,\n} from './components/app-router-headers'\nimport type {\n  NormalizedPathname,\n  NormalizedSearch,\n} from './components/segment-cache/cache-key'\nimport type { RSCResponse } from './components/router-reducer/fetch-server-response'\nimport type { ParsedUrlQuery } from 'querystring'\n\nexport type RouteParamValue = string | Array<string> | null\n\nexport function getRenderedSearch(\n  response: RSCResponse<unknown> | Response\n): NormalizedSearch {\n  // If the server performed a rewrite, the search params used to render the\n  // page will be different from the params in the request URL. In this case,\n  // the response will include a header that gives the rewritten search query.\n  const rewrittenQuery = response.headers.get(NEXT_REWRITTEN_QUERY_HEADER)\n  if (rewrittenQuery !== null) {\n    return (\n      rewrittenQuery === '' ? '' : '?' + rewrittenQuery\n    ) as NormalizedSearch\n  }\n  // If the header is not present, there was no rewrite, so we use the search\n  // query of the response URL.\n  return urlToUrlWithoutFlightMarker(new URL(response.url))\n    .search as NormalizedSearch\n}\n\nexport function getRenderedPathname(\n  response: RSCResponse<unknown> | Response\n): NormalizedPathname {\n  // If the server performed a rewrite, the pathname used to render the\n  // page will be different from the pathname in the request URL. In this case,\n  // the response will include a header that gives the rewritten pathname.\n  const rewrittenPath = response.headers.get(NEXT_REWRITTEN_PATH_HEADER)\n  return (rewrittenPath ??\n    urlToUrlWithoutFlightMarker(new URL(response.url))\n      .pathname) as NormalizedPathname\n}\n\nexport function parseDynamicParamFromURLPart(\n  paramType: DynamicParamTypesShort,\n  pathnameParts: Array<string>,\n  partIndex: number\n): RouteParamValue {\n  // This needs to match the behavior in get-dynamic-param.ts.\n  switch (paramType) {\n    // Catchalls\n    case 'c': {\n      // Catchalls receive all the remaining URL parts. If there are no\n      // remaining pathname parts, return an empty array.\n      return partIndex < pathnameParts.length\n        ? pathnameParts.slice(partIndex).map((s) => encodeURIComponent(s))\n        : []\n    }\n    // Catchall intercepted\n    case 'ci(..)(..)':\n    case 'ci(.)':\n    case 'ci(..)':\n    case 'ci(...)': {\n      const prefix = paramType.length - 2\n      return partIndex < pathnameParts.length\n        ? pathnameParts.slice(partIndex).map((s, i) => {\n            if (i === 0) {\n              return encodeURIComponent(s.slice(prefix))\n            }\n\n            return encodeURIComponent(s)\n          })\n        : []\n    }\n    // Optional catchalls\n    case 'oc': {\n      // Optional catchalls receive all the remaining URL parts, unless this is\n      // the end of the pathname, in which case they return null.\n      return partIndex < pathnameParts.length\n        ? pathnameParts.slice(partIndex).map((s) => encodeURIComponent(s))\n        : null\n    }\n    // Dynamic\n    case 'd': {\n      if (partIndex >= pathnameParts.length) {\n        // The route tree expected there to be more parts in the URL than there\n        // actually are. This could happen if the x-nextjs-rewritten-path header\n        // is incorrectly set, or potentially due to bug in Next.js. TODO:\n        // Should this be a hard error? During a prefetch, we can just abort.\n        // During a client navigation, we could trigger a hard refresh. But if\n        // it happens during initial render, we don't really have any\n        // recovery options.\n        return ''\n      }\n      return encodeURIComponent(pathnameParts[partIndex])\n    }\n    // Dynamic intercepted\n    case 'di(..)(..)':\n    case 'di(.)':\n    case 'di(..)':\n    case 'di(...)': {\n      const prefix = paramType.length - 2\n      if (partIndex >= pathnameParts.length) {\n        // The route tree expected there to be more parts in the URL than there\n        // actually are. This could happen if the x-nextjs-rewritten-path header\n        // is incorrectly set, or potentially due to bug in Next.js. TODO:\n        // Should this be a hard error? During a prefetch, we can just abort.\n        // During a client navigation, we could trigger a hard refresh. But if\n        // it happens during initial render, we don't really have any\n        // recovery options.\n        return ''\n      }\n\n      return encodeURIComponent(pathnameParts[partIndex].slice(prefix))\n    }\n    default:\n      paramType satisfies never\n      return ''\n  }\n}\n\nexport function doesStaticSegmentAppearInURL(segment: string): boolean {\n  // This is not a parameterized segment; however, we need to determine\n  // whether or not this segment appears in the URL. For example, this route\n  // groups do not appear in the URL, so they should be skipped. Any other\n  // special cases must be handled here.\n  // TODO: Consider encoding this directly into the router tree instead of\n  // inferring it on the client based on the segment type. Something like\n  // a `doesAppearInURL` flag in FlightRouterState.\n  if (\n    segment === ROOT_SEGMENT_REQUEST_KEY ||\n    // For some reason, the loader tree sometimes includes extra __PAGE__\n    // \"layouts\" when part of a parallel route. But it's not a leaf node.\n    // Otherwise, we wouldn't need this special case because pages are\n    // always leaf nodes.\n    // TODO: Investigate why the loader produces these fake page segments.\n    segment.startsWith(PAGE_SEGMENT_KEY) ||\n    // Route groups.\n    (segment[0] === '(' && segment.endsWith(')')) ||\n    segment === DEFAULT_SEGMENT_KEY ||\n    segment === '/_not-found'\n  ) {\n    return false\n  } else {\n    // All other segment types appear in the URL\n    return true\n  }\n}\n\nexport function getCacheKeyForDynamicParam(\n  paramValue: RouteParamValue,\n  renderedSearch: NormalizedSearch\n): string {\n  // This needs to match the logic in get-dynamic-param.ts, until we're able to\n  // unify the various implementations so that these are always computed on\n  // the client.\n  if (typeof paramValue === 'string') {\n    // TODO: Refactor or remove this helper function to accept a string rather\n    // than the whole segment type. Also we can probably just append the\n    // search string instead of turning it into JSON.\n    const pageSegmentWithSearchParams = addSearchParamsIfPageSegment(\n      paramValue,\n      Object.fromEntries(new URLSearchParams(renderedSearch))\n    ) as string\n    return pageSegmentWithSearchParams\n  } else if (paramValue === null) {\n    return ''\n  } else {\n    return paramValue.join('/')\n  }\n}\n\nexport function urlToUrlWithoutFlightMarker(url: URL): URL {\n  const urlWithoutFlightParameters = new URL(url)\n  urlWithoutFlightParameters.searchParams.delete(NEXT_RSC_UNION_QUERY)\n  if (process.env.NODE_ENV === 'production') {\n    if (\n      process.env.__NEXT_CONFIG_OUTPUT === 'export' &&\n      urlWithoutFlightParameters.pathname.endsWith('.txt')\n    ) {\n      const { pathname } = urlWithoutFlightParameters\n      const length = pathname.endsWith('/index.txt') ? 10 : 4\n      // Slice off `/index.txt` or `.txt` from the end of the pathname\n      urlWithoutFlightParameters.pathname = pathname.slice(0, -length)\n    }\n  }\n  return urlWithoutFlightParameters\n}\n\nexport function getParamValueFromCacheKey(\n  paramCacheKey: string,\n  paramType: DynamicParamTypesShort\n) {\n  // Turn the cache key string sent by the server (as part of FlightRouterState)\n  // into a value that can be passed to `useParams` and client components.\n  const isCatchAll = paramType === 'c' || paramType === 'oc'\n  if (isCatchAll) {\n    // Catch-all param keys are a concatenation of the path segments.\n    // See equivalent logic in `getSelectedParams`.\n    // TODO: We should just pass the array directly, rather than concatenate\n    // it to a string and then split it back to an array. It needs to be an\n    // array in some places, like when passing a key React, but we can convert\n    // it at runtime in those places.\n    return paramCacheKey.split('/')\n  }\n  return paramCacheKey\n}\n\nexport function urlSearchParamsToParsedUrlQuery(\n  searchParams: URLSearchParams\n): ParsedUrlQuery {\n  // Converts a URLSearchParams object to the same type used by the server when\n  // creating search params props, i.e. the type returned by Node's\n  // \"querystring\" module.\n  const result: ParsedUrlQuery = {}\n  for (const [key, value] of searchParams.entries()) {\n    if (result[key] === undefined) {\n      result[key] = value\n    } else if (Array.isArray(result[key])) {\n      result[key].push(value)\n    } else {\n      result[key] = [result[key], value]\n    }\n  }\n  return result\n}\n","export function createHrefFromUrl(\n  url: Pick<URL, 'pathname' | 'search' | 'hash'>,\n  includeHash: boolean = true\n): string {\n  return url.pathname + url.search + (includeHash ? url.hash : '')\n}\n","import type {\n  CacheNodeSeedData,\n  FlightData,\n  FlightDataPath,\n  FlightRouterState,\n  FlightSegmentPath,\n  Segment,\n  HeadData,\n  InitialRSCPayload,\n} from '../shared/lib/app-router-types'\nimport { PAGE_SEGMENT_KEY } from '../shared/lib/segment'\nimport type { NormalizedSearch } from './components/segment-cache/cache-key'\nimport {\n  getCacheKeyForDynamicParam,\n  parseDynamicParamFromURLPart,\n  doesStaticSegmentAppearInURL,\n  getRenderedPathname,\n  getRenderedSearch,\n} from './route-params'\nimport { createHrefFromUrl } from './components/router-reducer/create-href-from-url'\n\nexport type NormalizedFlightData = {\n  /**\n   * The full `FlightSegmentPath` inclusive of the final `Segment`\n   */\n  segmentPath: FlightSegmentPath\n  /**\n   * The `FlightSegmentPath` exclusive of the final `Segment`\n   */\n  pathToSegment: FlightSegmentPath\n  segment: Segment\n  tree: FlightRouterState\n  seedData: CacheNodeSeedData | null\n  head: HeadData\n  isHeadPartial: boolean\n  isRootRender: boolean\n}\n\n// TODO: We should only have to export `normalizeFlightData`, however because the initial flight data\n// that gets passed to `createInitialRouterState` doesn't conform to the `FlightDataPath` type (it's missing the root segment)\n// we're currently exporting it so we can use it directly. This should be fixed as part of the unification of\n// the different ways we express `FlightSegmentPath`.\nexport function getFlightDataPartsFromPath(\n  flightDataPath: FlightDataPath\n): NormalizedFlightData {\n  // Pick the last 4 items from the `FlightDataPath` to get the [tree, seedData, viewport, isHeadPartial].\n  const flightDataPathLength = 4\n  // tree, seedData, and head are *always* the last three items in the `FlightDataPath`.\n  const [tree, seedData, head, isHeadPartial] =\n    flightDataPath.slice(-flightDataPathLength)\n  // The `FlightSegmentPath` is everything except the last three items. For a root render, it won't be present.\n  const segmentPath = flightDataPath.slice(0, -flightDataPathLength)\n\n  return {\n    // TODO: Unify these two segment path helpers. We are inconsistently pushing an empty segment (\"\")\n    // to the start of the segment path in some places which makes it hard to use solely the segment path.\n    // Look for \"// TODO-APP: remove ''\" in the codebase.\n    pathToSegment: segmentPath.slice(0, -1),\n    segmentPath,\n    // if the `FlightDataPath` corresponds with the root, there'll be no segment path,\n    // in which case we default to ''.\n    segment: segmentPath[segmentPath.length - 1] ?? '',\n    tree,\n    seedData,\n    head,\n    isHeadPartial,\n    isRootRender: flightDataPath.length === flightDataPathLength,\n  }\n}\n\nexport function createInitialRSCPayloadFromFallbackPrerender(\n  response: Response,\n  fallbackInitialRSCPayload: InitialRSCPayload\n): InitialRSCPayload {\n  // This is a static fallback page. In order to hydrate the page, we need to\n  // parse the client params from the URL, but to account for the possibility\n  // that the page was rewritten, we need to check the response headers\n  // for x-nextjs-rewritten-path or x-nextjs-rewritten-query headers. Since\n  // we can't access the headers of the initial document response, the client\n  // performs a fetch request to the current location. Since it's possible that\n  // the fetch request will be dynamically rewritten to a different path than\n  // the initial document, this fetch request delivers _all_ the hydration data\n  // for the page; it was not inlined into the document, like it normally\n  // would be.\n  //\n  // TODO: Consider treating the case where fetch is rewritten to a different\n  // path from the document as a special deopt case. We should optimistically\n  // assume this won't happen, inline the data into the document, and perform\n  // a minimal request (like a HEAD or range request) to verify that the\n  // response matches. Tricky to get right because we need to account for\n  // all the different deployment environments we support, like output:\n  // \"export\" mode, where we currently don't assume that custom response\n  // headers are present.\n\n  // Patch the Flight data sent by the server with the correct params parsed\n  // from the URL + response object.\n  const renderedPathname = getRenderedPathname(response)\n  const renderedSearch = getRenderedSearch(response)\n  const canonicalUrl = createHrefFromUrl(new URL(location.href))\n  const originalFlightDataPath = fallbackInitialRSCPayload.f[0]\n  const originalFlightRouterState = originalFlightDataPath[0]\n  return {\n    b: fallbackInitialRSCPayload.b,\n    c: canonicalUrl.split('/'),\n    q: renderedSearch,\n    i: fallbackInitialRSCPayload.i,\n    f: [\n      [\n        fillInFallbackFlightRouterState(\n          originalFlightRouterState,\n          renderedPathname,\n          renderedSearch as NormalizedSearch\n        ),\n        originalFlightDataPath[1],\n        originalFlightDataPath[2],\n        originalFlightDataPath[2],\n      ],\n    ],\n    m: fallbackInitialRSCPayload.m,\n    G: fallbackInitialRSCPayload.G,\n    S: fallbackInitialRSCPayload.S,\n  }\n}\n\nfunction fillInFallbackFlightRouterState(\n  flightRouterState: FlightRouterState,\n  renderedPathname: string,\n  renderedSearch: NormalizedSearch\n): FlightRouterState {\n  const pathnameParts = renderedPathname.split('/').filter((p) => p !== '')\n  const index = 0\n  return fillInFallbackFlightRouterStateImpl(\n    flightRouterState,\n    renderedSearch,\n    pathnameParts,\n    index\n  )\n}\n\nfunction fillInFallbackFlightRouterStateImpl(\n  flightRouterState: FlightRouterState,\n  renderedSearch: NormalizedSearch,\n  pathnameParts: Array<string>,\n  pathnamePartsIndex: number\n): FlightRouterState {\n  const originalSegment = flightRouterState[0]\n  let newSegment: Segment\n  let doesAppearInURL: boolean\n  if (typeof originalSegment === 'string') {\n    newSegment = originalSegment\n    doesAppearInURL = doesStaticSegmentAppearInURL(originalSegment)\n  } else {\n    const paramName = originalSegment[0]\n    const paramType = originalSegment[2]\n    const paramValue = parseDynamicParamFromURLPart(\n      paramType,\n      pathnameParts,\n      pathnamePartsIndex\n    )\n    const cacheKey = getCacheKeyForDynamicParam(paramValue, renderedSearch)\n    newSegment = [paramName, cacheKey, paramType]\n    doesAppearInURL = true\n  }\n\n  // Only increment the index if the segment appears in the URL. If it's a\n  // \"virtual\" segment, like a route group, it remains the same.\n  const childPathnamePartsIndex = doesAppearInURL\n    ? pathnamePartsIndex + 1\n    : pathnamePartsIndex\n\n  const children = flightRouterState[1]\n  const newChildren: { [key: string]: FlightRouterState } = {}\n  for (let key in children) {\n    const childFlightRouterState = children[key]\n    newChildren[key] = fillInFallbackFlightRouterStateImpl(\n      childFlightRouterState,\n      renderedSearch,\n      pathnameParts,\n      childPathnamePartsIndex\n    )\n  }\n\n  const newState: FlightRouterState = [\n    newSegment,\n    newChildren,\n    null,\n    flightRouterState[3],\n    flightRouterState[4],\n  ]\n  return newState\n}\n\nexport function getNextFlightSegmentPath(\n  flightSegmentPath: FlightSegmentPath\n): FlightSegmentPath {\n  // Since `FlightSegmentPath` is a repeated tuple of `Segment` and `ParallelRouteKey`, we slice off two items\n  // to get the next segment path.\n  return flightSegmentPath.slice(2)\n}\n\nexport function normalizeFlightData(\n  flightData: FlightData\n): NormalizedFlightData[] | string {\n  // FlightData can be a string when the server didn't respond with a proper flight response,\n  // or when a redirect happens, to signal to the client that it needs to perform an MPA navigation.\n  if (typeof flightData === 'string') {\n    return flightData\n  }\n\n  return flightData.map((flightDataPath) =>\n    getFlightDataPartsFromPath(flightDataPath)\n  )\n}\n\n/**\n * This function is used to prepare the flight router state for the request.\n * It removes markers that are not needed by the server, and are purely used\n * for stashing state on the client.\n * @param flightRouterState - The flight router state to prepare.\n * @param isHmrRefresh - Whether this is an HMR refresh request.\n * @returns The prepared flight router state.\n */\nexport function prepareFlightRouterStateForRequest(\n  flightRouterState: FlightRouterState,\n  isHmrRefresh?: boolean\n): string {\n  // HMR requests need the complete, unmodified state for proper functionality\n  if (isHmrRefresh) {\n    return encodeURIComponent(JSON.stringify(flightRouterState))\n  }\n\n  return encodeURIComponent(\n    JSON.stringify(stripClientOnlyDataFromFlightRouterState(flightRouterState))\n  )\n}\n\n/**\n * Recursively strips client-only data from FlightRouterState while preserving\n * server-needed information for proper rendering decisions.\n */\nfunction stripClientOnlyDataFromFlightRouterState(\n  flightRouterState: FlightRouterState\n): FlightRouterState {\n  const [\n    segment,\n    parallelRoutes,\n    _url, // Intentionally unused - URLs are client-only\n    refreshMarker,\n    isRootLayout,\n    hasLoadingBoundary,\n  ] = flightRouterState\n\n  // __PAGE__ segments are always fetched from the server, so there's\n  // no need to send them up\n  const cleanedSegment = stripSearchParamsFromPageSegment(segment)\n\n  // Recursively process parallel routes\n  const cleanedParallelRoutes: { [key: string]: FlightRouterState } = {}\n  for (const [key, childState] of Object.entries(parallelRoutes)) {\n    cleanedParallelRoutes[key] =\n      stripClientOnlyDataFromFlightRouterState(childState)\n  }\n\n  const result: FlightRouterState = [\n    cleanedSegment,\n    cleanedParallelRoutes,\n    null, // URLs omitted - server reconstructs paths from segments\n    shouldPreserveRefreshMarker(refreshMarker) ? refreshMarker : null,\n  ]\n\n  // Append optional fields if present\n  if (isRootLayout !== undefined) {\n    result[4] = isRootLayout\n  }\n  if (hasLoadingBoundary !== undefined) {\n    result[5] = hasLoadingBoundary\n  }\n\n  return result\n}\n\n/**\n * Strips search parameters from __PAGE__ segments to prevent sensitive\n * client-side data from being sent to the server.\n */\nfunction stripSearchParamsFromPageSegment(segment: Segment): Segment {\n  if (\n    typeof segment === 'string' &&\n    segment.startsWith(PAGE_SEGMENT_KEY + '?')\n  ) {\n    return PAGE_SEGMENT_KEY\n  }\n  return segment\n}\n\n/**\n * Determines whether the refresh marker should be sent to the server\n * Client-only markers like 'refresh' are stripped, while server-needed markers\n * like 'refetch' and 'inside-shared-layout' are preserved.\n */\nfunction shouldPreserveRefreshMarker(\n  refreshMarker: FlightRouterState[3]\n): boolean {\n  return Boolean(refreshMarker && refreshMarker !== 'refresh')\n}\n","// This gets assigned as a side-effect during app initialization. Because it\n// represents the build used to create the JS bundle, it should never change\n// after being set, so we store it in a global variable.\n//\n// When performing RSC requests, if the incoming data has a different build ID,\n// we perform an MPA navigation/refresh to load the updated build and ensure\n// that the client and server in sync.\n\n// Starts as an empty string. In practice, because setAppBuildId is called\n// during initialization before hydration starts, this will always get\n// reassigned to the actual build ID before it's ever needed by a navigation.\n// If for some reasons it didn't, due to a bug or race condition, then on\n// navigation the build comparision would fail and trigger an MPA navigation.\nlet globalBuildId: string = ''\n\nexport function setAppBuildId(buildId: string) {\n  globalBuildId = buildId\n}\n\nexport function getAppBuildId(): string {\n  return globalBuildId\n}\n","// http://www.cse.yorku.ca/~oz/hash.html\n// More specifically, 32-bit hash via djbxor\n// (ref: https://gist.github.com/eplawless/52813b1d8ad9af510d85?permalink_comment_id=3367765#gistcomment-3367765)\n// This is due to number type differences between rust for turbopack to js number types,\n// where rust does not have easy way to repreesnt js's 53-bit float number type for the matching\n// overflow behavior. This is more `correct` in terms of having canonical hash across different runtime / implementation\n// as can gaurantee determinstic output from 32bit hash.\nexport function djb2Hash(str: string) {\n  let hash = 5381\n  for (let i = 0; i < str.length; i++) {\n    const char = str.charCodeAt(i)\n    hash = ((hash << 5) + hash + char) & 0xffffffff\n  }\n  return hash >>> 0\n}\n\nexport function hexHash(str: string) {\n  return djb2Hash(str).toString(36).slice(0, 5)\n}\n","import { hexHash } from '../../hash'\n\nexport function computeCacheBustingSearchParam(\n  prefetchHeader: '1' | '2' | '0' | undefined,\n  segmentPrefetchHeader: string | string[] | undefined,\n  stateTreeHeader: string | string[] | undefined,\n  nextUrlHeader: string | string[] | undefined\n): string {\n  if (\n    (prefetchHeader === undefined || prefetchHeader === '0') &&\n    segmentPrefetchHeader === undefined &&\n    stateTreeHeader === undefined &&\n    nextUrlHeader === undefined\n  ) {\n    return ''\n  }\n  return hexHash(\n    [\n      prefetchHeader || '0',\n      segmentPrefetchHeader || '0',\n      stateTreeHeader || '0',\n      nextUrlHeader || '0',\n    ].join(',')\n  )\n}\n","'use client'\n\nimport { computeCacheBustingSearchParam } from '../../../shared/lib/router/utils/cache-busting-search-param'\nimport {\n  NEXT_ROUTER_PREFETCH_HEADER,\n  NEXT_ROUTER_SEGMENT_PREFETCH_HEADER,\n  NEXT_ROUTER_STATE_TREE_HEADER,\n  NEXT_URL,\n  NEXT_RSC_UNION_QUERY,\n} from '../app-router-headers'\nimport type { RequestHeaders } from './fetch-server-response'\n\n/**\n * Mutates the provided URL by adding a cache-busting search parameter for CDNs that don't\n * support custom headers. This helps avoid caching conflicts by making each request unique.\n *\n * Rather than relying on the Vary header which some CDNs ignore, we append a search param\n * to create a unique URL that forces a fresh request.\n *\n * Example:\n * URL before: https://example.com/path?query=1\n * URL after: https://example.com/path?query=1&_rsc=abc123\n *\n * Note: This function mutates the input URL directly and does not return anything.\n *\n * TODO: Since we need to use a search param anyway, we could simplify by removing the custom\n * headers approach entirely and just use search params.\n */\nexport const setCacheBustingSearchParam = (\n  url: URL,\n  headers: RequestHeaders\n): void => {\n  const uniqueCacheKey = computeCacheBustingSearchParam(\n    headers[NEXT_ROUTER_PREFETCH_HEADER],\n    headers[NEXT_ROUTER_SEGMENT_PREFETCH_HEADER],\n    headers[NEXT_ROUTER_STATE_TREE_HEADER],\n    headers[NEXT_URL]\n  )\n  setCacheBustingSearchParamWithHash(url, uniqueCacheKey)\n}\n\n/**\n * Sets a cache-busting search parameter on a URL using a provided hash value.\n *\n * This function performs the same logic as `setCacheBustingSearchParam` but accepts\n * a pre-computed hash instead of computing it from headers.\n *\n * Example:\n * URL before: https://example.com/path?query=1\n * hash: \"abc123\"\n * URL after: https://example.com/path?query=1&_rsc=abc123\n *\n * If the hash is null, we will set `_rsc` search param without a value.\n * Like this: https://example.com/path?query=1&_rsc\n *\n * Note: This function mutates the input URL directly and does not return anything.\n */\nexport const setCacheBustingSearchParamWithHash = (\n  url: URL,\n  hash: string\n): void => {\n  /**\n   * Note that we intentionally do not use `url.searchParams.set` here:\n   *\n   * const url = new URL('https://example.com/search?q=custom%20spacing');\n   * url.searchParams.set('_rsc', 'abc123');\n   * console.log(url.toString()); // Outputs: https://example.com/search?q=custom+spacing&_rsc=abc123\n   *                                                                             ^ <--- this is causing confusion\n   * This is in fact intended based on https://url.spec.whatwg.org/#interface-urlsearchparams, but\n   * we want to preserve the %20 as %20 if that's what the user passed in, hence the custom\n   * logic below.\n   */\n  const existingSearch = url.search\n  const rawQuery = existingSearch.startsWith('?')\n    ? existingSearch.slice(1)\n    : existingSearch\n\n  // Always remove any existing cache busting param and add a fresh one to ensure\n  // we have the correct value based on current request headers\n  const pairs = rawQuery\n    .split('&')\n    .filter((pair) => pair && !pair.startsWith(`${NEXT_RSC_UNION_QUERY}=`))\n\n  if (hash.length > 0) {\n    pairs.push(`${NEXT_RSC_UNION_QUERY}=${hash}`)\n  } else {\n    pairs.push(`${NEXT_RSC_UNION_QUERY}`)\n  }\n  url.search = pairs.length ? `?${pairs.join('&')}` : ''\n}\n","'use client'\n\n// TODO: Explicitly import from client.browser\n// eslint-disable-next-line import/no-extraneous-dependencies\nimport {\n  createFromReadableStream as createFromReadableStreamBrowser,\n  createFromFetch as createFromFetchBrowser,\n} from 'react-server-dom-webpack/client'\n\nimport type {\n  FlightRouterState,\n  NavigationFlightResponse,\n} from '../../../shared/lib/app-router-types'\n\nimport type { NEXT_ROUTER_SEGMENT_PREFETCH_HEADER } from '../app-router-headers'\nimport {\n  NEXT_ROUTER_PREFETCH_HEADER,\n  NEXT_ROUTER_STATE_TREE_HEADER,\n  NEXT_RSC_UNION_QUERY,\n  NEXT_URL,\n  RSC_HEADER,\n  RSC_CONTENT_TYPE_HEADER,\n  NEXT_HMR_REFRESH_HEADER,\n  NEXT_DID_POSTPONE_HEADER,\n  NEXT_ROUTER_STALE_TIME_HEADER,\n  NEXT_HTML_REQUEST_ID_HEADER,\n  NEXT_REQUEST_ID_HEADER,\n} from '../app-router-headers'\nimport { callServer } from '../../app-call-server'\nimport { findSourceMapURL } from '../../app-find-source-map-url'\nimport { PrefetchKind } from './router-reducer-types'\nimport {\n  normalizeFlightData,\n  prepareFlightRouterStateForRequest,\n  type NormalizedFlightData,\n} from '../../flight-data-helpers'\nimport { getAppBuildId } from '../../app-build-id'\nimport { setCacheBustingSearchParam } from './set-cache-busting-search-param'\nimport {\n  getRenderedSearch,\n  urlToUrlWithoutFlightMarker,\n} from '../../route-params'\nimport type { NormalizedSearch } from '../segment-cache/cache-key'\n\nconst createFromReadableStream =\n  createFromReadableStreamBrowser as (typeof import('react-server-dom-webpack/client.browser'))['createFromReadableStream']\nconst createFromFetch =\n  createFromFetchBrowser as (typeof import('react-server-dom-webpack/client.browser'))['createFromFetch']\n\nlet createDebugChannel:\n  | typeof import('../../dev/debug-channel').createDebugChannel\n  | undefined\n\nif (\n  process.env.NODE_ENV !== 'production' &&\n  process.env.__NEXT_REACT_DEBUG_CHANNEL\n) {\n  createDebugChannel = (\n    require('../../dev/debug-channel') as typeof import('../../dev/debug-channel')\n  ).createDebugChannel\n}\n\nexport interface FetchServerResponseOptions {\n  readonly flightRouterState: FlightRouterState\n  readonly nextUrl: string | null\n  readonly prefetchKind?: PrefetchKind\n  readonly isHmrRefresh?: boolean\n}\n\ntype SpaFetchServerResponseResult = {\n  flightData: NormalizedFlightData[]\n  canonicalUrl: URL\n  renderedSearch: NormalizedSearch\n  couldBeIntercepted: boolean\n  prerendered: boolean\n  postponed: boolean\n  staleTime: number\n  debugInfo: Array<any> | null\n}\n\ntype MpaFetchServerResponseResult = string\n\nexport type FetchServerResponseResult =\n  | MpaFetchServerResponseResult\n  | SpaFetchServerResponseResult\n\nexport type RequestHeaders = {\n  [RSC_HEADER]?: '1'\n  [NEXT_ROUTER_STATE_TREE_HEADER]?: string\n  [NEXT_URL]?: string\n  [NEXT_ROUTER_PREFETCH_HEADER]?: '1' | '2'\n  [NEXT_ROUTER_SEGMENT_PREFETCH_HEADER]?: string\n  'x-deployment-id'?: string\n  [NEXT_HMR_REFRESH_HEADER]?: '1'\n  // A header that is only added in test mode to assert on fetch priority\n  'Next-Test-Fetch-Priority'?: RequestInit['priority']\n  [NEXT_HTML_REQUEST_ID_HEADER]?: string // dev-only\n  [NEXT_REQUEST_ID_HEADER]?: string // dev-only\n}\n\nfunction doMpaNavigation(url: string): FetchServerResponseResult {\n  return urlToUrlWithoutFlightMarker(new URL(url, location.origin)).toString()\n}\n\nlet abortController = new AbortController()\n\nif (typeof window !== 'undefined') {\n  // Abort any in-flight requests when the page is unloaded, e.g. due to\n  // reloading the page or performing hard navigations. This allows us to ignore\n  // what would otherwise be a thrown TypeError when the browser cancels the\n  // requests.\n  window.addEventListener('pagehide', () => {\n    abortController.abort()\n  })\n\n  // Use a fresh AbortController instance on pageshow, e.g. when navigating back\n  // and the JavaScript execution context is restored by the browser.\n  window.addEventListener('pageshow', () => {\n    abortController = new AbortController()\n  })\n}\n\n/**\n * Fetch the flight data for the provided url. Takes in the current router state\n * to decide what to render server-side.\n */\nexport async function fetchServerResponse(\n  url: URL,\n  options: FetchServerResponseOptions\n): Promise<FetchServerResponseResult> {\n  const { flightRouterState, nextUrl, prefetchKind } = options\n\n  const headers: RequestHeaders = {\n    // Enable flight response\n    [RSC_HEADER]: '1',\n    // Provide the current router state\n    [NEXT_ROUTER_STATE_TREE_HEADER]: prepareFlightRouterStateForRequest(\n      flightRouterState,\n      options.isHmrRefresh\n    ),\n  }\n\n  /**\n   * Three cases:\n   * - `prefetchKind` is `undefined`, it means it's a normal navigation, so we want to prefetch the page data fully\n   * - `prefetchKind` is `full` - we want to prefetch the whole page so same as above\n   * - `prefetchKind` is `auto` - if the page is dynamic, prefetch the page data partially, if static prefetch the page data fully\n   */\n  if (prefetchKind === PrefetchKind.AUTO) {\n    headers[NEXT_ROUTER_PREFETCH_HEADER] = '1'\n  }\n\n  if (process.env.NODE_ENV === 'development' && options.isHmrRefresh) {\n    headers[NEXT_HMR_REFRESH_HEADER] = '1'\n  }\n\n  if (nextUrl) {\n    headers[NEXT_URL] = nextUrl\n  }\n\n  // In static export mode, we need to modify the URL to request the .txt file,\n  // but we should preserve the original URL for the canonical URL and error handling.\n  const originalUrl = url\n\n  try {\n    // When creating a \"temporary\" prefetch (the \"on-demand\" prefetch that gets created on navigation, if one doesn't exist)\n    // we send the request with a \"high\" priority as it's in response to a user interaction that could be blocking a transition.\n    // Otherwise, all other prefetches are sent with a \"low\" priority.\n    // We use \"auto\" for in all other cases to match the existing default, as this function is shared outside of prefetching.\n    const fetchPriority = prefetchKind\n      ? prefetchKind === PrefetchKind.TEMPORARY\n        ? 'high'\n        : 'low'\n      : 'auto'\n\n    if (process.env.NODE_ENV === 'production') {\n      if (process.env.__NEXT_CONFIG_OUTPUT === 'export') {\n        // In \"output: export\" mode, we can't rely on headers to distinguish\n        // between HTML and RSC requests. Instead, we append an extra prefix\n        // to the request.\n        url = new URL(url)\n        if (url.pathname.endsWith('/')) {\n          url.pathname += 'index.txt'\n        } else {\n          url.pathname += '.txt'\n        }\n      }\n    }\n\n    // Typically, during a navigation, we decode the response using Flight's\n    // `createFromFetch` API, which accepts a `fetch` promise.\n    // TODO: Remove this check once the old PPR flag is removed\n    const isLegacyPPR =\n      process.env.__NEXT_PPR && !process.env.__NEXT_CACHE_COMPONENTS\n    const shouldImmediatelyDecode = !isLegacyPPR\n    const res = await createFetch<NavigationFlightResponse>(\n      url,\n      headers,\n      fetchPriority,\n      shouldImmediatelyDecode,\n      abortController.signal\n    )\n\n    const responseUrl = urlToUrlWithoutFlightMarker(new URL(res.url))\n    const canonicalUrl = res.redirected ? responseUrl : originalUrl\n\n    const contentType = res.headers.get('content-type') || ''\n    const interception = !!res.headers.get('vary')?.includes(NEXT_URL)\n    const postponed = !!res.headers.get(NEXT_DID_POSTPONE_HEADER)\n    const staleTimeHeaderSeconds = res.headers.get(\n      NEXT_ROUTER_STALE_TIME_HEADER\n    )\n    const staleTime =\n      staleTimeHeaderSeconds !== null\n        ? parseInt(staleTimeHeaderSeconds, 10) * 1000\n        : -1\n    let isFlightResponse = contentType.startsWith(RSC_CONTENT_TYPE_HEADER)\n\n    if (process.env.NODE_ENV === 'production') {\n      if (process.env.__NEXT_CONFIG_OUTPUT === 'export') {\n        if (!isFlightResponse) {\n          isFlightResponse = contentType.startsWith('text/plain')\n        }\n      }\n    }\n\n    // If fetch returns something different than flight response handle it like a mpa navigation\n    // If the fetch was not 200, we also handle it like a mpa navigation\n    if (!isFlightResponse || !res.ok || !res.body) {\n      // in case the original URL came with a hash, preserve it before redirecting to the new URL\n      if (url.hash) {\n        responseUrl.hash = url.hash\n      }\n\n      return doMpaNavigation(responseUrl.toString())\n    }\n\n    // We may navigate to a page that requires a different Webpack runtime.\n    // In prod, every page will have the same Webpack runtime.\n    // In dev, the Webpack runtime is minimal for each page.\n    // We need to ensure the Webpack runtime is updated before executing client-side JS of the new page.\n    // TODO: This needs to happen in the Flight Client.\n    // Or Webpack needs to include the runtime update in the Flight response as\n    // a blocking script.\n    if (process.env.NODE_ENV !== 'production' && !process.env.TURBOPACK) {\n      await (\n        require('../../dev/hot-reloader/app/hot-reloader-app') as typeof import('../../dev/hot-reloader/app/hot-reloader-app')\n      ).waitForWebpackRuntimeHotUpdate()\n    }\n\n    let flightResponsePromise = res.flightResponse\n    if (flightResponsePromise === null) {\n      // Typically, `createFetch` would have already started decoding the\n      // Flight response. If it hasn't, though, we need to decode it now.\n      // TODO: This should only be reachable if legacy PPR is enabled (i.e. PPR\n      // without Cache Components). Remove this branch once legacy PPR\n      // is deleted.\n      const flightStream = postponed\n        ? createUnclosingPrefetchStream(res.body)\n        : res.body\n      flightResponsePromise =\n        createFromNextReadableStream<NavigationFlightResponse>(\n          flightStream,\n          headers\n        )\n    }\n\n    const flightResponse = await flightResponsePromise\n\n    if (getAppBuildId() !== flightResponse.b) {\n      return doMpaNavigation(res.url)\n    }\n\n    const normalizedFlightData = normalizeFlightData(flightResponse.f)\n    if (typeof normalizedFlightData === 'string') {\n      return doMpaNavigation(normalizedFlightData)\n    }\n\n    return {\n      flightData: normalizedFlightData,\n      canonicalUrl: canonicalUrl,\n      renderedSearch: getRenderedSearch(res),\n      couldBeIntercepted: interception,\n      prerendered: flightResponse.S,\n      postponed,\n      staleTime,\n      debugInfo: flightResponsePromise._debugInfo ?? null,\n    }\n  } catch (err) {\n    if (!abortController.signal.aborted) {\n      console.error(\n        `Failed to fetch RSC payload for ${originalUrl}. Falling back to browser navigation.`,\n        err\n      )\n    }\n\n    // If fetch fails handle it like a mpa navigation\n    // TODO-APP: Add a test for the case where a CORS request fails, e.g. external url redirect coming from the response.\n    // See https://github.com/vercel/next.js/issues/43605#issuecomment-1451617521 for a reproduction.\n    return originalUrl.toString()\n  }\n}\n\n// This is a subset of the standard Response type. We use a custom type for\n// this so we can limit which details about the response leak into the rest of\n// the codebase. For example, there's some custom logic for manually following\n// redirects, so \"redirected\" in this type could be a composite of multiple\n// browser fetch calls; however, this fact should not leak to the caller.\nexport type RSCResponse<T> = {\n  ok: boolean\n  redirected: boolean\n  headers: Headers\n  body: ReadableStream<Uint8Array> | null\n  status: number\n  url: string\n  flightResponse: (Promise<T> & { _debugInfo?: Array<any> }) | null\n}\n\nexport async function createFetch<T>(\n  url: URL,\n  headers: RequestHeaders,\n  fetchPriority: 'auto' | 'high' | 'low' | null,\n  shouldImmediatelyDecode: boolean,\n  signal?: AbortSignal\n): Promise<RSCResponse<T>> {\n  // TODO: In output: \"export\" mode, the headers do nothing. Omit them (and the\n  // cache busting search param) from the request so they're\n  // maximally cacheable.\n\n  if (process.env.__NEXT_TEST_MODE && fetchPriority !== null) {\n    headers['Next-Test-Fetch-Priority'] = fetchPriority\n  }\n\n  if (process.env.NEXT_DEPLOYMENT_ID) {\n    headers['x-deployment-id'] = process.env.NEXT_DEPLOYMENT_ID\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (self.__next_r) {\n      headers[NEXT_HTML_REQUEST_ID_HEADER] = self.__next_r\n    }\n\n    // Create a new request ID for the server action request. The server uses\n    // this to tag debug information sent via WebSocket to the client, which\n    // then routes those chunks to the debug channel associated with this ID.\n    headers[NEXT_REQUEST_ID_HEADER] = crypto\n      .getRandomValues(new Uint32Array(1))[0]\n      .toString(16)\n  }\n\n  const fetchOptions: RequestInit = {\n    // Backwards compat for older browsers. `same-origin` is the default in modern browsers.\n    credentials: 'same-origin',\n    headers,\n    priority: fetchPriority || undefined,\n    signal,\n  }\n  // `fetchUrl` is slightly different from `url` because we add a cache-busting\n  // search param to it. This should not leak outside of this function, so we\n  // track them separately.\n  let fetchUrl = new URL(url)\n  setCacheBustingSearchParam(fetchUrl, headers)\n  let fetchPromise = fetch(fetchUrl, fetchOptions)\n  // Immediately pass the fetch promise to the Flight client so that the debug\n  // info includes the latency from the client to the server. The internal timer\n  // in React starts as soon as `createFromFetch` is called.\n  //\n  // The only case where we don't do this is during a prefetch, because we have\n  // to do some extra processing of the response stream (see\n  // `createUnclosingPrefetchStream`). But this is fine, because a top-level\n  // prefetch response never blocks a navigation; if it hasn't already been\n  // written into the cache by the time the navigation happens, the router will\n  // go straight to a dynamic request.\n  let flightResponsePromise = shouldImmediatelyDecode\n    ? createFromNextFetch<T>(fetchPromise, headers)\n    : null\n  let browserResponse = await fetchPromise\n\n  // If the server responds with a redirect (e.g. 307), and the redirected\n  // location does not contain the cache busting search param set in the\n  // original request, the response is likely invalid — when following the\n  // redirect, the browser forwards the request headers, but since the cache\n  // busting search param is missing, the server will reject the request due to\n  // a mismatch.\n  //\n  // Ideally, we would be able to intercept the redirect response and perform it\n  // manually, instead of letting the browser automatically follow it, but this\n  // is not allowed by the fetch API.\n  //\n  // So instead, we must \"replay\" the redirect by fetching the new location\n  // again, but this time we'll append the cache busting search param to prevent\n  // a mismatch.\n  //\n  // TODO: We can optimize Next.js's built-in middleware APIs by returning a\n  // custom status code, to prevent the browser from automatically following it.\n  //\n  // This does not affect Server Action-based redirects; those are encoded\n  // differently, as part of the Flight body. It only affects redirects that\n  // occur in a middleware or a third-party proxy.\n\n  let redirected = browserResponse.redirected\n  if (process.env.__NEXT_CLIENT_VALIDATE_RSC_REQUEST_HEADERS) {\n    // This is to prevent a redirect loop. Same limit used by Chrome.\n    const MAX_REDIRECTS = 20\n    for (let n = 0; n < MAX_REDIRECTS; n++) {\n      if (!browserResponse.redirected) {\n        // The server did not perform a redirect.\n        break\n      }\n      const responseUrl = new URL(browserResponse.url, fetchUrl)\n      if (responseUrl.origin !== fetchUrl.origin) {\n        // The server redirected to an external URL. The rest of the logic below\n        // is not relevant, because it only applies to internal redirects.\n        break\n      }\n      if (\n        responseUrl.searchParams.get(NEXT_RSC_UNION_QUERY) ===\n        fetchUrl.searchParams.get(NEXT_RSC_UNION_QUERY)\n      ) {\n        // The redirected URL already includes the cache busting search param.\n        // This was probably intentional. Regardless, there's no reason to\n        // issue another request to this URL because it already has the param\n        // value that we would have added below.\n        break\n      }\n      // The RSC request was redirected. Assume the response is invalid.\n      //\n      // Append the cache busting search param to the redirected URL and\n      // fetch again.\n      // TODO: We should abort the previous request.\n      fetchUrl = new URL(responseUrl)\n      setCacheBustingSearchParam(fetchUrl, headers)\n      fetchPromise = fetch(fetchUrl, fetchOptions)\n      flightResponsePromise = shouldImmediatelyDecode\n        ? createFromNextFetch<T>(fetchPromise, headers)\n        : null\n      browserResponse = await fetchPromise\n      // We just performed a manual redirect, so this is now true.\n      redirected = true\n    }\n  }\n\n  // Remove the cache busting search param from the response URL, to prevent it\n  // from leaking outside of this function.\n  const responseUrl = new URL(browserResponse.url, fetchUrl)\n  responseUrl.searchParams.delete(NEXT_RSC_UNION_QUERY)\n\n  const rscResponse: RSCResponse<T> = {\n    url: responseUrl.href,\n\n    // This is true if any redirects occurred, either automatically by the\n    // browser, or manually by us. So it's different from\n    // `browserResponse.redirected`, which only tells us whether the browser\n    // followed a redirect, and only for the last response in the chain.\n    redirected,\n\n    // These can be copied from the last browser response we received. We\n    // intentionally only expose the subset of fields that are actually used\n    // elsewhere in the codebase.\n    ok: browserResponse.ok,\n    headers: browserResponse.headers,\n    body: browserResponse.body,\n    status: browserResponse.status,\n\n    // This is the exact promise returned by `createFromFetch`. It contains\n    // debug information that we need to transfer to any derived promises that\n    // are later rendered by React.\n    flightResponse: flightResponsePromise,\n  }\n\n  return rscResponse\n}\n\nexport function createFromNextReadableStream<T>(\n  flightStream: ReadableStream<Uint8Array>,\n  requestHeaders: RequestHeaders\n): Promise<T> {\n  return createFromReadableStream(flightStream, {\n    callServer,\n    findSourceMapURL,\n    debugChannel: createDebugChannel && createDebugChannel(requestHeaders),\n  })\n}\n\nfunction createFromNextFetch<T>(\n  promiseForResponse: Promise<Response>,\n  requestHeaders: RequestHeaders\n): Promise<T> & { _debugInfo?: Array<any> } {\n  return createFromFetch(promiseForResponse, {\n    callServer,\n    findSourceMapURL,\n    debugChannel: createDebugChannel && createDebugChannel(requestHeaders),\n  })\n}\n\nfunction createUnclosingPrefetchStream(\n  originalFlightStream: ReadableStream<Uint8Array>\n): ReadableStream<Uint8Array> {\n  // When PPR is enabled, prefetch streams may contain references that never\n  // resolve, because that's how we encode dynamic data access. In the decoded\n  // object returned by the Flight client, these are reified into hanging\n  // promises that suspend during render, which is effectively what we want.\n  // The UI resolves when it switches to the dynamic data stream\n  // (via useDeferredValue(dynamic, static)).\n  //\n  // However, the Flight implementation currently errors if the server closes\n  // the response before all the references are resolved. As a cheat to work\n  // around this, we wrap the original stream in a new stream that never closes,\n  // and therefore doesn't error.\n  const reader = originalFlightStream.getReader()\n  return new ReadableStream({\n    async pull(controller) {\n      while (true) {\n        const { done, value } = await reader.read()\n        if (!done) {\n          // Pass to the target stream and keep consuming the Flight response\n          // from the server.\n          controller.enqueue(value)\n          continue\n        }\n        // The server stream has closed. Exit, but intentionally do not close\n        // the target stream.\n        return\n      }\n    },\n  })\n}\n","import type { MapEntry } from './cache-map'\nimport { deleteFromCacheMap } from './cache-map'\n\n// We use an LRU for memory management. We must update this whenever we add or\n// remove a new cache entry, or when an entry changes size.\n\n// The MapEntry type is used as an LRU node, too. We choose this one instead of\n// the inner cache entry type (RouteCacheEntry, SegmentCacheEntry) because it's\n// monomorphic and can be optimized by the VM.\ntype LRUNode = MapEntry<any>\n\nlet head: LRUNode | null = null\nlet didScheduleCleanup: boolean = false\nlet lruSize: number = 0\n\n// TODO: I chose the max size somewhat arbitrarily. Consider setting this based\n// on navigator.deviceMemory, or some other heuristic. We should make this\n// customizable via the Next.js config, too.\nconst maxLruSize = 50 * 1024 * 1024 // 50 MB\n\nexport function lruPut(node: LRUNode) {\n  if (head === node) {\n    // Already at the head\n    return\n  }\n  const prev = node.prev\n  const next = node.next\n  if (next === null || prev === null) {\n    // This is an insertion\n    lruSize += node.size\n    // Whenever we add an entry, we need to check if we've exceeded the\n    // max size. We don't evict entries immediately; they're evicted later in\n    // an asynchronous task.\n    ensureCleanupIsScheduled()\n  } else {\n    // This is a move. Remove from its current position.\n    prev.next = next\n    next.prev = prev\n  }\n\n  // Move to the front of the list\n  if (head === null) {\n    // This is the first entry\n    node.prev = node\n    node.next = node\n  } else {\n    // Add to the front of the list\n    const tail = head.prev\n    node.prev = tail\n    // In practice, this is never null, but that isn't encoded in the type\n    if (tail !== null) {\n      tail.next = node\n    }\n    node.next = head\n    head.prev = node\n  }\n  head = node\n}\n\nexport function updateLruSize(node: LRUNode, newNodeSize: number) {\n  // This is a separate function from `put` so that we can resize the entry\n  // regardless of whether it's currently being tracked by the LRU.\n  const prevNodeSize = node.size\n  node.size = newNodeSize\n  if (node.next === null) {\n    // This entry is not currently being tracked by the LRU.\n    return\n  }\n  // Update the total LRU size\n  lruSize = lruSize - prevNodeSize + newNodeSize\n  ensureCleanupIsScheduled()\n}\n\nexport function deleteFromLru(deleted: LRUNode) {\n  const next = deleted.next\n  const prev = deleted.prev\n  if (next !== null && prev !== null) {\n    lruSize -= deleted.size\n\n    deleted.next = null\n    deleted.prev = null\n\n    // Remove from the list\n    if (head === deleted) {\n      // Update the head\n      if (next === head) {\n        // This was the last entry\n        head = null\n      } else {\n        head = next\n      }\n    } else {\n      prev.next = next\n      next.prev = prev\n    }\n  } else {\n    // Already deleted\n  }\n}\n\nfunction ensureCleanupIsScheduled() {\n  if (didScheduleCleanup || lruSize <= maxLruSize) {\n    return\n  }\n  didScheduleCleanup = true\n  requestCleanupCallback(cleanup)\n}\n\nfunction cleanup() {\n  didScheduleCleanup = false\n\n  // Evict entries until we're at 90% capacity. We can assume this won't\n  // infinite loop because even if `maxLruSize` were 0, eventually\n  // `deleteFromLru` sets `head` to `null` when we run out entries.\n  const ninetyPercentMax = maxLruSize * 0.9\n  while (lruSize > ninetyPercentMax && head !== null) {\n    const tail = head.prev\n    // In practice, this is never null, but that isn't encoded in the type\n    if (tail !== null) {\n      // Delete the entry from the map. In turn, this will remove it from\n      // the LRU.\n      deleteFromCacheMap(tail.value)\n    }\n  }\n}\n\nconst requestCleanupCallback =\n  typeof requestIdleCallback === 'function'\n    ? requestIdleCallback\n    : (cb: () => void) => setTimeout(cb, 0)\n","import type { VaryPath } from './vary-path'\nimport { lruPut, updateLruSize, deleteFromLru } from './lru'\n\n/**\n * A specialized data type for storing multi-key cache entries.\n *\n * The basic structure is a map whose keys are tuples, called the keypath.\n * When querying the cache, keypaths are compared per-element.\n *\n * Example:\n *   set(map, ['https://localhost', 'foo/bar/baz'], 'yay');\n *   get(map, ['https://localhost', 'foo/bar/baz']) -> 'yay'\n *\n * NOTE: Array syntax is used in these examples for illustration purposes, but\n * in reality the paths are lists.\n * \n * The parts of the keypath represent the different inputs that contribute\n * to the entry value. To illustrate, if you were to use this data type to store\n * HTTP responses, the keypath would include the URL and everything listed by\n * the Vary header.\n * \n * See vary-path.ts for more details.\n *\n * The order of elements in a keypath must be consistent between lookups to\n * be considered the same, but besides that, the order of the keys is not\n * semantically meaningful.\n *\n * Keypaths may include a special kind of key called Fallback. When an entry is\n * stored with Fallback as part of its keypath, it means that the entry does not\n * vary by that key. When querying the cache, if an exact match is not found for\n * a keypath, the cache will check for a Fallback match instead. Each element of\n * the keypath may have a Fallback, so retrieval is an O(n ^ 2) operation, but\n * it's expected that keypaths are relatively short.\n *\n * Example:\n *   set(cacheMap, ['store', 'product', 1], PRODUCT_PAGE_1);\n *   set(cacheMap, ['store', 'product', Fallback], GENERIC_PRODUCT_PAGE);\n *\n *   // Exact match\n *   get(cacheMap, ['store', 'product', 1]) -> PRODUCT_PAGE_1\n *\n *   // Fallback match\n *   get(cacheMap, ['store', 'product', 2]) -> GENERIC_PRODUCT_PAGE\n *\n * Because we have the Fallback mechanism, we can impose a constraint that\n * regular JS maps do not have: a value cannot be stored at multiple keypaths\n * simultaneously. These cases should be expressed with Fallback keys instead.\n *\n * Additionally, because values only exist at a single keypath at a time, we\n * can optimize successive lookups by caching the internal map entry on the\n * value itself, using the `ref` field. This is especially useful because it\n * lets us skip the O(n ^ 2) lookup that occurs when Fallback entries\n * are present.\n *\n\n * How to decide if stuff belongs in here, or in cache.ts?\n * -------------------------------------------------------\n * \n * Anything to do with retrival, lifetimes, or eviction needs to go in this\n * module because it affects the fallback algorithm. For example, when\n * performing a lookup, if an entry is stale, it needs to be treated as\n * semantically equivalent to if the entry was not present at all.\n * \n * If there's logic that's not related to the fallback algorithm, though, we\n * should prefer to put it in cache.ts.\n */\n\ntype MapEntryShared<V extends MapValue> = {\n  parent: MapEntry<V> | null\n  key: any\n  map: Map<any, MapEntry<V>> | null\n\n  // LRU-related fields\n  prev: MapEntry<any> | null\n  next: MapEntry<any> | null\n  size: number\n}\n\ntype EmptyMapEntry<V extends MapValue> = MapEntryShared<V> & {\n  value: null\n}\n\ntype FullMapEntry<V extends MapValue> = MapEntryShared<V> & {\n  value: V\n}\n\nexport type MapEntry<V extends MapValue> = EmptyMapEntry<V> | FullMapEntry<V>\n\n// The CacheMap type is just the root entry of the map.\nexport type CacheMap<V extends MapValue> = MapEntry<V>\n\n// The protocol that values must implement. In practice, the only two types that\n// we ever actually deal with in this module are RouteCacheEntry and\n// SegmentCacheEntry; this is just to keep track of the coupling so we don't\n// leak concerns between the modules unnecessarily.\nexport interface MapValue {\n  ref: MapEntry<any> | null\n  size: number\n  staleAt: number\n  version: number\n}\n\nexport type FallbackType = { __brand: 'Fallback' }\nexport const Fallback = {} as FallbackType\n\n// This is a special internal key that is used for \"revalidation\" entries. It's\n// an implementation detail that shouldn't leak outside of this module.\nconst Revalidation = {}\n\nexport function createCacheMap<V extends MapValue>(): CacheMap<V> {\n  const cacheMap: MapEntry<V> = {\n    parent: null,\n    key: null,\n    value: null,\n    map: null,\n\n    // LRU-related fields\n    prev: null,\n    next: null,\n    size: 0,\n  }\n  return cacheMap\n}\n\nfunction getOrInitialize<V extends MapValue>(\n  cacheMap: CacheMap<V>,\n  keys: VaryPath,\n  isRevalidation: boolean\n): MapEntry<V> {\n  // Go through each level of keys until we find the entry that matches, or\n  // create a new entry if one doesn't exist.\n  //\n  // This function will only return entries that match the keypath _exactly_.\n  // Unlike getWithFallback, it will not access fallback entries unless it's\n  // explicitly part of the keypath.\n  let entry = cacheMap\n  let remainingKeys: VaryPath | null = keys\n  let key: unknown | null = null\n  while (true) {\n    const previousKey = key\n    if (remainingKeys !== null) {\n      key = remainingKeys.value\n      remainingKeys = remainingKeys.parent\n    } else if (isRevalidation && previousKey !== Revalidation) {\n      // During a revalidation, we append an internal \"Revalidation\" key to\n      // the end of the keypath. The \"normal\" entry is its parent.\n\n      // However, if the parent entry is currently empty, we don't need to store\n      // this as a revalidation entry. Just insert the revalidation into the\n      // normal slot.\n      if (entry.value === null) {\n        return entry\n      }\n\n      // Otheriwse, create a child entry.\n      key = Revalidation\n    } else {\n      // There are no more keys. This is the terminal entry.\n      break\n    }\n\n    let map = entry.map\n    if (map !== null) {\n      const existingEntry = map.get(key)\n      if (existingEntry !== undefined) {\n        // Found a match. Keep going.\n        entry = existingEntry\n        continue\n      }\n    } else {\n      map = new Map()\n      entry.map = map\n    }\n    // No entry exists yet at this level. Create a new one.\n    const newEntry: EmptyMapEntry<V> = {\n      parent: entry,\n      key,\n      value: null,\n      map: null,\n\n      // LRU-related fields\n      prev: null,\n      next: null,\n      size: 0,\n    }\n    map.set(key, newEntry)\n    entry = newEntry\n  }\n\n  return entry\n}\n\nexport function getFromCacheMap<V extends MapValue>(\n  now: number,\n  currentCacheVersion: number,\n  rootEntry: CacheMap<V>,\n  keys: VaryPath,\n  isRevalidation: boolean\n): V | null {\n  const entry = getEntryWithFallbackImpl(\n    now,\n    currentCacheVersion,\n    rootEntry,\n    keys,\n    isRevalidation,\n    0\n  )\n  if (entry === null || entry.value === null) {\n    return null\n  }\n  // This is an LRU access. Move the entry to the front of the list.\n  lruPut(entry)\n  return entry.value\n}\n\nexport function isValueExpired<V extends MapValue>(\n  now: number,\n  currentCacheVersion: number,\n  value: V\n): boolean {\n  return value.staleAt <= now || value.version < currentCacheVersion\n}\n\nfunction lazilyEvictIfNeeded<V extends MapValue>(\n  now: number,\n  currentCacheVersion: number,\n  entry: MapEntry<V>\n) {\n  // We have a matching entry, but before we can return it, we need to check if\n  // it's still fresh. Otherwise it should be treated the same as a cache miss.\n\n  if (entry.value === null) {\n    // This entry has no value, so there's nothing to evict.\n    return entry\n  }\n\n  const value = entry.value\n  if (isValueExpired(now, currentCacheVersion, value)) {\n    // The value expired. Lazily evict it from the cache, and return null. This\n    // is conceptually the same as a cache miss.\n    deleteMapEntry(entry)\n    return null\n  }\n\n  // The matched entry has not expired. Return it.\n  return entry\n}\n\nfunction getEntryWithFallbackImpl<V extends MapValue>(\n  now: number,\n  currentCacheVersion: number,\n  entry: MapEntry<V>,\n  keys: VaryPath | null,\n  isRevalidation: boolean,\n  previousKey: unknown | null\n): MapEntry<V> | null {\n  // This is similar to getExactEntry, but if an exact match is not found for\n  // a key, it will return the fallback entry instead. This is recursive at\n  // every level, e.g. an entry with keypath [a, Fallback, c, Fallback] is\n  // valid match for [a, b, c, d].\n  //\n  // It will return the most specific match available.\n  let key\n  let remainingKeys: VaryPath | null\n  if (keys !== null) {\n    key = keys.value\n    remainingKeys = keys.parent\n  } else if (isRevalidation && previousKey !== Revalidation) {\n    // During a revalidation, we append an internal \"Revalidation\" key to\n    // the end of the keypath.\n    key = Revalidation\n    remainingKeys = null\n  } else {\n    // There are no more keys. This is the terminal entry.\n\n    // TODO: When performing a lookup during a navigation, as opposed to a\n    // prefetch, we may want to skip entries that are Pending if there's also\n    // a Fulfilled fallback entry. Tricky to say, though, since if it's\n    // already pending, it's likely to stream in soon. Maybe we could do this\n    // just on slow connections and offline mode.\n\n    return lazilyEvictIfNeeded(now, currentCacheVersion, entry)\n  }\n  const map = entry.map\n  if (map !== null) {\n    const existingEntry = map.get(key)\n    if (existingEntry !== undefined) {\n      // Found an exact match for this key. Keep searching.\n      const result = getEntryWithFallbackImpl<V>(\n        now,\n        currentCacheVersion,\n        existingEntry,\n        remainingKeys,\n        isRevalidation,\n        key\n      )\n      if (result !== null) {\n        return result\n      }\n    }\n    // No match found for this key. Check if there's a fallback.\n    const fallbackEntry = map.get(Fallback)\n    if (fallbackEntry !== undefined) {\n      // Found a fallback for this key. Keep searching.\n      return getEntryWithFallbackImpl(\n        now,\n        currentCacheVersion,\n        fallbackEntry,\n        remainingKeys,\n        isRevalidation,\n        key\n      )\n    }\n  }\n  return null\n}\n\nexport function setInCacheMap<V extends MapValue>(\n  cacheMap: CacheMap<V>,\n  keys: VaryPath,\n  value: V,\n  isRevalidation: boolean\n): void {\n  // Add a value to the map at the given keypath. If the value is already\n  // part of the map, it's removed from its previous keypath. (NOTE: This is\n  // unlike a regular JS map, but the behavior is intentional.)\n  const entry = getOrInitialize(cacheMap, keys, isRevalidation)\n  setMapEntryValue(entry, value)\n\n  // This is an LRU access. Move the entry to the front of the list.\n  lruPut(entry)\n  updateLruSize(entry, value.size)\n}\n\nfunction setMapEntryValue<V extends MapValue>(\n  entry: MapEntry<V>,\n  value: V\n): void {\n  if (entry.value !== null) {\n    // There's already a value at the given keypath. Disconnect the old value\n    // from the map. We're not calling `deleteMapEntry` here because the\n    // entry itself is still in the map. We just want to overwrite its value.\n    dropRef(entry.value)\n\n    // Fill the entry with the updated value.\n    const emptyEntry: EmptyMapEntry<V> = entry as any\n    emptyEntry.value = null\n    fillEmptyReference(emptyEntry, value)\n  } else {\n    fillEmptyReference(entry as any, value)\n  }\n}\n\nfunction fillEmptyReference<V extends MapValue>(\n  entry: EmptyMapEntry<V>,\n  value: V\n): void {\n  // This value may already be in the map at a different keypath.\n  // Grab a reference before we overwrite it.\n  const oldEntry = value.ref\n\n  const fullEntry: FullMapEntry<V> = entry as any\n  fullEntry.value = value\n  value.ref = fullEntry\n\n  updateLruSize(fullEntry, value.size)\n\n  if (oldEntry !== null && oldEntry !== entry && oldEntry.value === value) {\n    // This value is already in the map at a different keypath in the map.\n    // Values only exist at a single keypath at a time. Remove it from the\n    // previous keypath.\n    //\n    // Note that only the internal map entry is garbage collected; we don't\n    // call `dropRef` here because it's still in the map, just\n    // at a new keypath (the one we just set, above).\n    deleteMapEntry(oldEntry)\n  }\n}\n\nexport function deleteFromCacheMap<V extends MapValue>(value: V): void {\n  const entry = value.ref\n  if (entry === null) {\n    // This value is not a member of any map.\n    return\n  }\n\n  dropRef(value)\n  deleteMapEntry(entry)\n}\n\nfunction dropRef<V extends MapValue>(value: V): void {\n  // Drop the value from the map by setting its `ref` backpointer to\n  // null. This is a separate operation from `deleteMapEntry` because when\n  // re-keying a value we need to be able to delete the old, internal map\n  // entry without garbage collecting the value itself.\n  value.ref = null\n}\n\nfunction deleteMapEntry<V extends MapValue>(entry: MapEntry<V>): void {\n  // Delete the entry from the cache.\n  const emptyEntry: EmptyMapEntry<V> = entry as any\n  emptyEntry.value = null\n\n  deleteFromLru(entry)\n\n  // Check if we can garbage collect the entry.\n  const map = emptyEntry.map\n  if (map === null) {\n    // Since this entry has no value, and also no child entries, we can\n    // garbage collect it. Remove it from its parent, and keep garbage\n    // collecting the parents until we reach a non-empty entry.\n    let parent = emptyEntry.parent\n    let key = emptyEntry.key\n    while (parent !== null) {\n      const parentMap = parent.map\n      if (parentMap !== null) {\n        parentMap.delete(key)\n        if (parentMap.size === 0) {\n          // We just removed the last entry in the parent map.\n          parent.map = null\n          if (parent.value === null) {\n            // The parent node has no child entries, nor does it have a value\n            // on itself. It can be garbage collected. Keep going.\n            key = parent.key\n            parent = parent.parent\n            continue\n          }\n        }\n      }\n      // The parent is not empty. Stop garbage collecting.\n      break\n    }\n  } else {\n    // Check if there's a revalidating entry. If so, promote it to a\n    // \"normal\" entry, since the normal one was just deleted.\n    const revalidatingEntry = map.get(Revalidation)\n    if (revalidatingEntry !== undefined && revalidatingEntry.value !== null) {\n      setMapEntryValue(emptyEntry, revalidatingEntry.value)\n    }\n  }\n}\n\nexport function setSizeInCacheMap<V extends MapValue>(\n  value: V,\n  size: number\n): void {\n  const entry = value.ref\n  if (entry === null) {\n    // This value is not a member of any map.\n    return\n  }\n  // Except during initialization (when the size is set to 0), this is the only\n  // place the `size` field should be updated, to ensure it's in sync with the\n  // the LRU.\n  value.size = size\n  updateLruSize(entry, size)\n}\n","import { FetchStrategy } from './types'\nimport type {\n  NormalizedPathname,\n  NormalizedSearch,\n  NormalizedNextUrl,\n} from './cache-key'\nimport type { RouteTree } from './cache'\nimport { Fallback, type FallbackType } from './cache-map'\nimport { HEAD_REQUEST_KEY } from '../../../shared/lib/segment-cache/segment-value-encoding'\n\ntype Opaque<T, K> = T & { __brand: K }\n\n/**\n * A linked-list of all the params (or other param-like) inputs that a cache\n * entry may vary by. This is used by the CacheMap module to reuse cache entries\n * across different param values. If a param has a value of Fallback, it means\n * the cache entry is reusable for all possible values of that param. See\n * cache-map.ts for details.\n *\n * A segment's vary path is a pure function of a segment's position in a\n * particular route tree and the (post-rewrite) URL that is being queried. More\n * concretely, successive queries of the cache for the same segment always use\n * the same vary path.\n *\n * A route's vary path is simpler: it's comprised of the pathname, search\n * string, and Next-URL header.\n */\nexport type VaryPath = {\n  value: string | null | FallbackType\n  parent: VaryPath | null\n}\n\n// Because it's so important for vary paths to line up across cache accesses,\n// we use opaque type aliases to ensure these are only created within\n// this module.\n\n// requestKey -> searchParams -> nextUrl\nexport type RouteVaryPath = Opaque<\n  {\n    value: NormalizedPathname\n    parent: {\n      value: NormalizedSearch\n      parent: {\n        value: NormalizedNextUrl | null | FallbackType\n        parent: null\n      }\n    }\n  },\n  'RouteVaryPath'\n>\n\n// requestKey -> pathParams\nexport type LayoutVaryPath = Opaque<\n  {\n    value: string\n    parent: PartialSegmentVaryPath | null\n  },\n  'LayoutVaryPath'\n>\n\n// requestKey -> searchParams -> pathParams\nexport type PageVaryPath = Opaque<\n  {\n    value: string\n    parent: {\n      value: NormalizedSearch | FallbackType\n      parent: PartialSegmentVaryPath | null\n    }\n  },\n  'PageVaryPath'\n>\n\nexport type SegmentVaryPath = LayoutVaryPath | PageVaryPath\n\n// Intermediate type used when building a vary path during a recursive traversal\n// of the route tree.\nexport type PartialSegmentVaryPath = Opaque<VaryPath, 'PartialSegmentVaryPath'>\n\nexport function getRouteVaryPath(\n  pathname: NormalizedPathname,\n  search: NormalizedSearch,\n  nextUrl: NormalizedNextUrl | null\n): RouteVaryPath {\n  // requestKey -> searchParams -> nextUrl\n  const varyPath: VaryPath = {\n    value: pathname,\n    parent: {\n      value: search,\n      parent: {\n        value: nextUrl,\n        parent: null,\n      },\n    },\n  }\n  return varyPath as RouteVaryPath\n}\n\nexport function getFulfilledRouteVaryPath(\n  pathname: NormalizedPathname,\n  search: NormalizedSearch,\n  nextUrl: NormalizedNextUrl | null,\n  couldBeIntercepted: boolean\n): RouteVaryPath {\n  // This is called when a route's data is fulfilled. The cache entry will be\n  // re-keyed based on which inputs the response varies by.\n  // requestKey -> searchParams -> nextUrl\n  const varyPath: VaryPath = {\n    value: pathname,\n    parent: {\n      value: search,\n      parent: {\n        value: couldBeIntercepted ? nextUrl : Fallback,\n        parent: null,\n      },\n    },\n  }\n  return varyPath as RouteVaryPath\n}\n\nexport function appendLayoutVaryPath(\n  parentPath: PartialSegmentVaryPath | null,\n  cacheKey: string\n): PartialSegmentVaryPath {\n  const varyPathPart: VaryPath = {\n    value: cacheKey,\n    parent: parentPath,\n  }\n  return varyPathPart as PartialSegmentVaryPath\n}\n\nexport function finalizeLayoutVaryPath(\n  requestKey: string,\n  varyPath: PartialSegmentVaryPath | null\n): LayoutVaryPath {\n  const layoutVaryPath: VaryPath = {\n    value: requestKey,\n    parent: varyPath,\n  }\n  return layoutVaryPath as LayoutVaryPath\n}\n\nexport function finalizePageVaryPath(\n  requestKey: string,\n  renderedSearch: NormalizedSearch,\n  varyPath: PartialSegmentVaryPath | null\n): PageVaryPath {\n  // Unlike layouts, a page segment's vary path also includes the search string.\n  // requestKey -> searchParams -> pathParams\n  const pageVaryPath: VaryPath = {\n    value: requestKey,\n    parent: {\n      value: renderedSearch,\n      parent: varyPath,\n    },\n  }\n  return pageVaryPath as PageVaryPath\n}\n\nexport function finalizeMetadataVaryPath(\n  pageRequestKey: string,\n  renderedSearch: NormalizedSearch,\n  varyPath: PartialSegmentVaryPath | null\n): PageVaryPath {\n  // The metadata \"segment\" is not a real segment because it doesn't exist in\n  // the normal structure of the route tree, but in terms of caching, it\n  // behaves like a page segment because it varies by all the same params as\n  // a page.\n  //\n  // To keep the protocol for querying the server simple, the request key for\n  // the metadata does not include any path information. It's unnecessary from\n  // the server's perspective, because unlike page segments, there's only one\n  // metadata response per URL, i.e. there's no need to distinguish multiple\n  // parallel pages.\n  //\n  // However, this means the metadata request key is insufficient for\n  // caching the the metadata in the client cache, because on the client we\n  // use the request key to distinguish the metadata entry from all other\n  // page's metadata entries.\n  //\n  // So instead we create a simulated request key based on the page segment.\n  // Conceptually this is equivalent to the request key the server would have\n  // assigned the metadata segment if it treated it as part of the actual\n  // route structure.\n\n  // If there are multiple parallel pages, we use whichever is the first one.\n  // This is fine because the only difference between request keys for\n  // different parallel pages are things like route groups and parallel\n  // route slots. As long as it's always the same one, it doesn't matter.\n  const pageVaryPath: VaryPath = {\n    // Append the actual metadata request key to the page request key. Note\n    // that we're not using a separate vary path part; it's unnecessary because\n    // these are not conceptually separate inputs.\n    value: pageRequestKey + HEAD_REQUEST_KEY,\n    parent: {\n      value: renderedSearch,\n      parent: varyPath,\n    },\n  }\n  return pageVaryPath as PageVaryPath\n}\n\nexport function getSegmentVaryPathForRequest(\n  fetchStrategy: FetchStrategy,\n  tree: RouteTree\n): SegmentVaryPath {\n  // This is used for storing pending requests in the cache. We want to choose\n  // the most generic vary path based on the strategy used to fetch it, i.e.\n  // static/PPR versus runtime prefetching, so that it can be reused as much\n  // as possible.\n  //\n  // We may be able to re-key the response to something even more generic once\n  // we receive it — for example, if the server tells us that the response\n  // doesn't vary on a particular param — but even before we send the request,\n  // we know some params are reusable based on the fetch strategy alone. For\n  // example, a static prefetch will never vary on search params.\n  //\n  // The original vary path with all the params filled in is stored on the\n  // route tree object. We will clone this one to create a new vary path\n  // where certain params are replaced with Fallback.\n  //\n  // This result of this function is not stored anywhere. It's only used to\n  // access the cache a single time.\n  //\n  // TODO: Rather than create a new list object just to access the cache, the\n  // plan is to add the concept of a \"vary mask\". This will represent all the\n  // params that can be treated as Fallback. (Or perhaps the inverse.)\n  const originalVaryPath = tree.varyPath\n\n  // Only page segments (and the special \"metadata\" segment, which is treated\n  // like a page segment for the purposes of caching) may contain search\n  // params. There's no reason to include them in the vary path otherwise.\n  if (tree.isPage) {\n    // Only a runtime prefetch will include search params in the vary path.\n    // Static prefetches never include search params, so they can be reused\n    // across all possible search param values.\n    const doesVaryOnSearchParams =\n      fetchStrategy === FetchStrategy.Full ||\n      fetchStrategy === FetchStrategy.PPRRuntime\n\n    if (!doesVaryOnSearchParams) {\n      // The response from the the server will not vary on search params. Clone\n      // the end of the original vary path to replace the search params\n      // with Fallback.\n      //\n      // requestKey -> searchParams -> pathParams\n      //               ^ This part gets replaced with Fallback\n      const searchParamsVaryPath = (originalVaryPath as PageVaryPath).parent\n      const pathParamsVaryPath = searchParamsVaryPath.parent\n      const patchedVaryPath: VaryPath = {\n        value: originalVaryPath.value,\n        parent: {\n          value: Fallback,\n          parent: pathParamsVaryPath,\n        },\n      }\n      return patchedVaryPath as SegmentVaryPath\n    }\n  }\n\n  // The request does vary on search params. We don't need to modify anything.\n  return originalVaryPath as SegmentVaryPath\n}\n\nexport function clonePageVaryPathWithNewSearchParams(\n  originalVaryPath: PageVaryPath,\n  newSearch: NormalizedSearch\n): PageVaryPath {\n  // requestKey -> searchParams -> pathParams\n  //               ^ This part gets replaced with newSearch\n  const searchParamsVaryPath = originalVaryPath.parent\n  const clonedVaryPath: VaryPath = {\n    value: originalVaryPath.value,\n    parent: {\n      value: newSearch,\n      parent: searchParamsVaryPath.parent,\n    },\n  }\n  return clonedVaryPath as PageVaryPath\n}\n","/**\n * For a given page path, this function ensures that there is a leading slash.\n * If there is not a leading slash, one is added, otherwise it is noop.\n */\nexport function ensureLeadingSlash(path: string) {\n  return path.startsWith('/') ? path : `/${path}`\n}\n","import { ensureLeadingSlash } from '../../page-path/ensure-leading-slash'\nimport { isGroupSegment } from '../../segment'\n\n/**\n * Normalizes an app route so it represents the actual request path. Essentially\n * performing the following transformations:\n *\n * - `/(dashboard)/user/[id]/page` to `/user/[id]`\n * - `/(dashboard)/account/page` to `/account`\n * - `/user/[id]/page` to `/user/[id]`\n * - `/account/page` to `/account`\n * - `/page` to `/`\n * - `/(dashboard)/user/[id]/route` to `/user/[id]`\n * - `/(dashboard)/account/route` to `/account`\n * - `/user/[id]/route` to `/user/[id]`\n * - `/account/route` to `/account`\n * - `/route` to `/`\n * - `/` to `/`\n *\n * @param route the app route to normalize\n * @returns the normalized pathname\n */\nexport function normalizeAppPath(route: string) {\n  return ensureLeadingSlash(\n    route.split('/').reduce((pathname, segment, index, segments) => {\n      // Empty segments are ignored.\n      if (!segment) {\n        return pathname\n      }\n\n      // Groups are ignored.\n      if (isGroupSegment(segment)) {\n        return pathname\n      }\n\n      // Parallel segments are ignored.\n      if (segment[0] === '@') {\n        return pathname\n      }\n\n      // The last segment (if it's a leaf) should be ignored.\n      if (\n        (segment === 'page' || segment === 'route') &&\n        index === segments.length - 1\n      ) {\n        return pathname\n      }\n\n      return `${pathname}/${segment}`\n    }, '')\n  )\n}\n\n/**\n * Strips the `.rsc` extension if it's in the pathname.\n * Since this function is used on full urls it checks `?` for searchParams handling.\n */\nexport function normalizeRscURL(url: string) {\n  return url.replace(\n    /\\.rsc($|\\?)/,\n    // $1 ensures `?` is preserved\n    '$1'\n  )\n}\n","import { normalizeAppPath } from './app-paths'\n\n// order matters here, the first match will be used\nexport const INTERCEPTION_ROUTE_MARKERS = [\n  '(..)(..)',\n  '(.)',\n  '(..)',\n  '(...)',\n] as const\n\nexport function isInterceptionRouteAppPath(path: string): boolean {\n  // TODO-APP: add more serious validation\n  return (\n    path\n      .split('/')\n      .find((segment) =>\n        INTERCEPTION_ROUTE_MARKERS.find((m) => segment.startsWith(m))\n      ) !== undefined\n  )\n}\n\ntype InterceptionRouteInformation = {\n  /**\n   * The intercepting route. This is the route that is being intercepted or the\n   * route that the user was coming from. This is matched by the Next-Url\n   * header.\n   */\n  interceptingRoute: string\n\n  /**\n   * The intercepted route. This is the route that is being intercepted or the\n   * route that the user is going to. This is matched by the request pathname.\n   */\n  interceptedRoute: string\n}\n\nexport function extractInterceptionRouteInformation(\n  path: string\n): InterceptionRouteInformation {\n  let interceptingRoute: string | undefined\n  let marker: (typeof INTERCEPTION_ROUTE_MARKERS)[number] | undefined\n  let interceptedRoute: string | undefined\n\n  for (const segment of path.split('/')) {\n    marker = INTERCEPTION_ROUTE_MARKERS.find((m) => segment.startsWith(m))\n    if (marker) {\n      ;[interceptingRoute, interceptedRoute] = path.split(marker, 2)\n      break\n    }\n  }\n\n  if (!interceptingRoute || !marker || !interceptedRoute) {\n    throw new Error(\n      `Invalid interception route: ${path}. Must be in the format /<intercepting route>/(..|...|..)(..)/<intercepted route>`\n    )\n  }\n\n  interceptingRoute = normalizeAppPath(interceptingRoute) // normalize the path, e.g. /(blog)/feed -> /feed\n\n  switch (marker) {\n    case '(.)':\n      // (.) indicates that we should match with sibling routes, so we just need to append the intercepted route to the intercepting route\n      if (interceptingRoute === '/') {\n        interceptedRoute = `/${interceptedRoute}`\n      } else {\n        interceptedRoute = interceptingRoute + '/' + interceptedRoute\n      }\n      break\n    case '(..)':\n      // (..) indicates that we should match at one level up, so we need to remove the last segment of the intercepting route\n      if (interceptingRoute === '/') {\n        throw new Error(\n          `Invalid interception route: ${path}. Cannot use (..) marker at the root level, use (.) instead.`\n        )\n      }\n      interceptedRoute = interceptingRoute\n        .split('/')\n        .slice(0, -1)\n        .concat(interceptedRoute)\n        .join('/')\n      break\n    case '(...)':\n      // (...) will match the route segment in the root directory, so we need to use the root directory to prepend the intercepted route\n      interceptedRoute = '/' + interceptedRoute\n      break\n    case '(..)(..)':\n      // (..)(..) indicates that we should match at two levels up, so we need to remove the last two segments of the intercepting route\n\n      const splitInterceptingRoute = interceptingRoute.split('/')\n      if (splitInterceptingRoute.length <= 2) {\n        throw new Error(\n          `Invalid interception route: ${path}. Cannot use (..)(..) marker at the root level or one level up.`\n        )\n      }\n\n      interceptedRoute = splitInterceptingRoute\n        .slice(0, -2)\n        .concat(interceptedRoute)\n        .join('/')\n      break\n    default:\n      throw new Error('Invariant: unexpected marker')\n  }\n\n  return { interceptingRoute, interceptedRoute }\n}\n","import type {\n  FlightRouterState,\n  Segment,\n} from '../../../shared/lib/app-router-types'\nimport { INTERCEPTION_ROUTE_MARKERS } from '../../../shared/lib/router/utils/interception-routes'\nimport type { Params } from '../../../server/request/params'\nimport {\n  isGroupSegment,\n  DEFAULT_SEGMENT_KEY,\n  PAGE_SEGMENT_KEY,\n} from '../../../shared/lib/segment'\nimport { matchSegment } from '../match-segments'\n\nconst removeLeadingSlash = (segment: string): string => {\n  return segment[0] === '/' ? segment.slice(1) : segment\n}\n\nconst segmentToPathname = (segment: Segment): string => {\n  if (typeof segment === 'string') {\n    // 'children' is not a valid path -- it's technically a parallel route that corresponds with the current segment's page\n    // if we don't skip it, then the computed pathname might be something like `/children` which doesn't make sense.\n    if (segment === 'children') return ''\n\n    return segment\n  }\n\n  return segment[1]\n}\n\nfunction normalizeSegments(segments: string[]): string {\n  return (\n    segments.reduce((acc, segment) => {\n      segment = removeLeadingSlash(segment)\n      if (segment === '' || isGroupSegment(segment)) {\n        return acc\n      }\n\n      return `${acc}/${segment}`\n    }, '') || '/'\n  )\n}\n\nexport function extractPathFromFlightRouterState(\n  flightRouterState: FlightRouterState\n): string | undefined {\n  const segment = Array.isArray(flightRouterState[0])\n    ? flightRouterState[0][1]\n    : flightRouterState[0]\n\n  if (\n    segment === DEFAULT_SEGMENT_KEY ||\n    INTERCEPTION_ROUTE_MARKERS.some((m) => segment.startsWith(m))\n  )\n    return undefined\n\n  if (segment.startsWith(PAGE_SEGMENT_KEY)) return ''\n\n  const segments = [segmentToPathname(segment)]\n  const parallelRoutes = flightRouterState[1] ?? {}\n\n  const childrenPath = parallelRoutes.children\n    ? extractPathFromFlightRouterState(parallelRoutes.children)\n    : undefined\n\n  if (childrenPath !== undefined) {\n    segments.push(childrenPath)\n  } else {\n    for (const [key, value] of Object.entries(parallelRoutes)) {\n      if (key === 'children') continue\n\n      const childPath = extractPathFromFlightRouterState(value)\n\n      if (childPath !== undefined) {\n        segments.push(childPath)\n      }\n    }\n  }\n\n  return normalizeSegments(segments)\n}\n\nfunction computeChangedPathImpl(\n  treeA: FlightRouterState,\n  treeB: FlightRouterState\n): string | null {\n  const [segmentA, parallelRoutesA] = treeA\n  const [segmentB, parallelRoutesB] = treeB\n\n  const normalizedSegmentA = segmentToPathname(segmentA)\n  const normalizedSegmentB = segmentToPathname(segmentB)\n\n  if (\n    INTERCEPTION_ROUTE_MARKERS.some(\n      (m) =>\n        normalizedSegmentA.startsWith(m) || normalizedSegmentB.startsWith(m)\n    )\n  ) {\n    return ''\n  }\n\n  if (!matchSegment(segmentA, segmentB)) {\n    // once we find where the tree changed, we compute the rest of the path by traversing the tree\n    return extractPathFromFlightRouterState(treeB) ?? ''\n  }\n\n  for (const parallelRouterKey in parallelRoutesA) {\n    if (parallelRoutesB[parallelRouterKey]) {\n      const changedPath = computeChangedPathImpl(\n        parallelRoutesA[parallelRouterKey],\n        parallelRoutesB[parallelRouterKey]\n      )\n      if (changedPath !== null) {\n        return `${segmentToPathname(segmentB)}/${changedPath}`\n      }\n    }\n  }\n\n  return null\n}\n\nexport function computeChangedPath(\n  treeA: FlightRouterState,\n  treeB: FlightRouterState\n): string | null {\n  const changedPath = computeChangedPathImpl(treeA, treeB)\n\n  if (changedPath == null || changedPath === '/') {\n    return changedPath\n  }\n\n  // lightweight normalization to remove route groups\n  return normalizeSegments(changedPath.split('/'))\n}\n\n/**\n * Recursively extracts dynamic parameters from FlightRouterState.\n */\nexport function getSelectedParams(\n  currentTree: FlightRouterState,\n  params: Params = {}\n): Params {\n  const parallelRoutes = currentTree[1]\n\n  for (const parallelRoute of Object.values(parallelRoutes)) {\n    const segment = parallelRoute[0]\n    const isDynamicParameter = Array.isArray(segment)\n    const segmentValue = isDynamicParameter ? segment[1] : segment\n    if (!segmentValue || segmentValue.startsWith(PAGE_SEGMENT_KEY)) continue\n\n    // Ensure catchAll and optional catchall are turned into an array\n    const isCatchAll =\n      isDynamicParameter && (segment[2] === 'c' || segment[2] === 'oc')\n\n    if (isCatchAll) {\n      params[segment[0]] = segment[1].split('/')\n    } else if (isDynamicParameter) {\n      params[segment[0]] = segment[1]\n    }\n\n    params = getSelectedParams(parallelRoute, params)\n  }\n\n  return params\n}\n","import { computeChangedPath } from './compute-changed-path'\nimport type {\n  Mutable,\n  ReadonlyReducerState,\n  ReducerState,\n} from './router-reducer-types'\n\nfunction isNotUndefined<T>(value: T): value is Exclude<T, undefined> {\n  return typeof value !== 'undefined'\n}\n\nexport function handleMutable(\n  state: ReadonlyReducerState,\n  mutable: Mutable\n): ReducerState {\n  // shouldScroll is true by default, can override to false.\n  const shouldScroll = mutable.shouldScroll ?? true\n\n  let previousNextUrl = state.previousNextUrl\n  let nextUrl = state.nextUrl\n\n  if (isNotUndefined(mutable.patchedTree)) {\n    // If we received a patched tree, we need to compute the changed path.\n    const changedPath = computeChangedPath(state.tree, mutable.patchedTree)\n    if (changedPath) {\n      // If the tree changed, we need to update the nextUrl\n      previousNextUrl = nextUrl\n      nextUrl = changedPath\n    } else if (!nextUrl) {\n      // if the tree ends up being the same (ie, no changed path), and we don't have a nextUrl, then we should use the canonicalUrl\n      nextUrl = state.canonicalUrl\n    }\n    // otherwise this will be a no-op and continue to use the existing nextUrl\n  }\n\n  return {\n    // Set href.\n    canonicalUrl: mutable.canonicalUrl ?? state.canonicalUrl,\n    renderedSearch: mutable.renderedSearch ?? state.renderedSearch,\n    pushRef: {\n      pendingPush: isNotUndefined(mutable.pendingPush)\n        ? mutable.pendingPush\n        : state.pushRef.pendingPush,\n      mpaNavigation: isNotUndefined(mutable.mpaNavigation)\n        ? mutable.mpaNavigation\n        : state.pushRef.mpaNavigation,\n      preserveCustomHistoryState: isNotUndefined(\n        mutable.preserveCustomHistoryState\n      )\n        ? mutable.preserveCustomHistoryState\n        : state.pushRef.preserveCustomHistoryState,\n    },\n    // All navigation requires scroll and focus management to trigger.\n    focusAndScrollRef: {\n      apply: shouldScroll\n        ? isNotUndefined(mutable?.scrollableSegments)\n          ? true\n          : state.focusAndScrollRef.apply\n        : // If shouldScroll is false then we should not apply scroll and focus management.\n          false,\n      onlyHashChange: mutable.onlyHashChange || false,\n      hashFragment: shouldScroll\n        ? // Empty hash should trigger default behavior of scrolling layout into view.\n          // #top is handled in layout-router.\n          mutable.hashFragment && mutable.hashFragment !== ''\n          ? // Remove leading # and decode hash to make non-latin hashes work.\n            decodeURIComponent(mutable.hashFragment.slice(1))\n          : state.focusAndScrollRef.hashFragment\n        : // If shouldScroll is false then we should not apply scroll and focus management.\n          null,\n      segmentPaths: shouldScroll\n        ? (mutable?.scrollableSegments ?? state.focusAndScrollRef.segmentPaths)\n        : // If shouldScroll is false then we should not apply scroll and focus management.\n          [],\n    },\n    // Apply cache.\n    cache: mutable.cache ? mutable.cache : state.cache,\n    // Apply patched router state.\n    tree: isNotUndefined(mutable.patchedTree)\n      ? mutable.patchedTree\n      : state.tree,\n    nextUrl,\n    previousNextUrl: previousNextUrl,\n    debugInfo: mutable.collectedDebugInfo ?? null,\n  }\n}\n","import type { Segment } from '../../../shared/lib/app-router-types'\nimport { PAGE_SEGMENT_KEY } from '../../../shared/lib/segment'\n\nexport function createRouterCacheKey(\n  segment: Segment,\n  withoutSearchParameters: boolean = false\n) {\n  // if the segment is an array, it means it's a dynamic segment\n  // for example, ['lang', 'en', 'd']. We need to convert it to a string to store it as a cache node key.\n  if (Array.isArray(segment)) {\n    return `${segment[0]}|${segment[1]}|${segment[2]}`\n  }\n\n  // Page segments might have search parameters, ie __PAGE__?foo=bar\n  // When `withoutSearchParameters` is true, we only want to return the page segment\n  if (withoutSearchParameters && segment.startsWith(PAGE_SEGMENT_KEY)) {\n    return PAGE_SEGMENT_KEY\n  }\n\n  return segment\n}\n","import type { FlightRouterState } from '../../../shared/lib/app-router-types'\n\nexport function isNavigatingToNewRootLayout(\n  currentTree: FlightRouterState,\n  nextTree: FlightRouterState\n): boolean {\n  // Compare segments\n  const currentTreeSegment = currentTree[0]\n  const nextTreeSegment = nextTree[0]\n\n  // If any segment is different before we find the root layout, the root layout has changed.\n  // E.g. /same/(group1)/layout.js -> /same/(group2)/layout.js\n  // First segment is 'same' for both, keep looking. (group1) changed to (group2) before the root layout was found, it must have changed.\n  if (Array.isArray(currentTreeSegment) && Array.isArray(nextTreeSegment)) {\n    // Compare dynamic param name and type but ignore the value, different values would not affect the current root layout\n    // /[name] - /slug1 and /slug2, both values (slug1 & slug2) still has the same layout /[name]/layout.js\n    if (\n      currentTreeSegment[0] !== nextTreeSegment[0] ||\n      currentTreeSegment[2] !== nextTreeSegment[2]\n    ) {\n      return true\n    }\n  } else if (currentTreeSegment !== nextTreeSegment) {\n    return true\n  }\n\n  // Current tree root layout found\n  if (currentTree[4]) {\n    // If the next tree doesn't have the root layout flag, it must have changed.\n    return !nextTree[4]\n  }\n  // Current tree didn't have its root layout here, must have changed.\n  if (nextTree[4]) {\n    return true\n  }\n  // We can't assume it's `parallelRoutes.children` here in case the root layout is `app/@something/layout.js`\n  // But it's not possible to be more than one parallelRoutes before the root layout is found\n  // TODO-APP: change to traverse all parallel routes\n  const currentTreeChild = Object.values(currentTree[1])[0]\n  const nextTreeChild = Object.values(nextTree[1])[0]\n  if (!currentTreeChild || !nextTreeChild) return true\n  return isNavigatingToNewRootLayout(currentTreeChild, nextTreeChild)\n}\n","import type {\n  CacheNodeSeedData,\n  FlightRouterState,\n  FlightSegmentPath,\n  Segment,\n} from '../../../shared/lib/app-router-types'\nimport type {\n  CacheNode,\n  ChildSegmentMap,\n  ReadyCacheNode,\n} from '../../../shared/lib/app-router-types'\nimport type {\n  HeadData,\n  LoadingModuleData,\n} from '../../../shared/lib/app-router-types'\nimport { DEFAULT_SEGMENT_KEY } from '../../../shared/lib/segment'\nimport { matchSegment } from '../match-segments'\nimport { createHrefFromUrl } from './create-href-from-url'\nimport { createRouterCacheKey } from './create-router-cache-key'\nimport type { FetchServerResponseResult } from './fetch-server-response'\nimport { isNavigatingToNewRootLayout } from './is-navigating-to-new-root-layout'\nimport { DYNAMIC_STALETIME_MS } from './reducers/navigate-reducer'\n\n// This is yet another tree type that is used to track pending promises that\n// need to be fulfilled once the dynamic data is received. The terminal nodes of\n// this tree represent the new Cache Node trees that were created during this\n// request. We can't use the Cache Node tree or Route State tree directly\n// because those include reused nodes, too. This tree is discarded as soon as\n// the navigation response is received.\ntype SPANavigationTask = {\n  // The router state that corresponds to the tree that this Task represents.\n  route: FlightRouterState\n  // The CacheNode that corresponds to the tree that this Task represents. If\n  // `children` is null (i.e. if this is a terminal task node), then `node`\n  // represents a brand new Cache Node tree, which way or may not need to be\n  // filled with dynamic data from the server.\n  node: CacheNode | null\n  // The tree sent to the server during the dynamic request. This is the\n  // same as `route`, except with the `refetch` marker set on dynamic segments.\n  // If all the segments are static, then this will be null, and no server\n  // request is required.\n  dynamicRequestTree: FlightRouterState | null\n  children: Map<string, SPANavigationTask> | null\n}\n\n// A special type used to bail out and trigger a full-page navigation.\ntype MPANavigationTask = {\n  // MPA tasks are distinguised from SPA tasks by having a null `route`.\n  route: null\n  node: null\n  dynamicRequestTree: null\n  children: null\n}\n\nconst MPA_NAVIGATION_TASK: MPANavigationTask = {\n  route: null,\n  node: null,\n  dynamicRequestTree: null,\n  children: null,\n}\n\nexport type Task = SPANavigationTask | MPANavigationTask\n\n// Creates a new Cache Node tree (i.e. copy-on-write) that represents the\n// optimistic result of a navigation, using both the current Cache Node tree and\n// data that was prefetched prior to navigation.\n//\n// At the moment we call this function, we haven't yet received the navigation\n// response from the server. It could send back something completely different\n// from the tree that was prefetched — due to rewrites, default routes, parallel\n// routes, etc.\n//\n// But in most cases, it will return the same tree that we prefetched, just with\n// the dynamic holes filled in. So we optimistically assume this will happen,\n// and accept that the real result could be arbitrarily different.\n//\n// We'll reuse anything that was already in the previous tree, since that's what\n// the server does.\n//\n// New segments (ones that don't appear in the old tree) are assigned an\n// unresolved promise. The data for these promises will be fulfilled later, when\n// the navigation response is received.\n//\n// The tree can be rendered immediately after it is created (that's why this is\n// a synchronous function). Any new trees that do not have prefetch data will\n// suspend during rendering, until the dynamic data streams in.\n//\n// Returns a Task object, which contains both the updated Cache Node and a path\n// to the pending subtrees that need to be resolved by the navigation response.\n//\n// A return value of `null` means there were no changes, and the previous tree\n// can be reused without initiating a server request.\nexport function startPPRNavigation(\n  navigatedAt: number,\n  oldUrl: URL,\n  oldCacheNode: CacheNode,\n  oldRouterState: FlightRouterState,\n  newRouterState: FlightRouterState,\n  prefetchData: CacheNodeSeedData | null,\n  prefetchHead: HeadData | null,\n  isPrefetchHeadPartial: boolean,\n  isSamePageNavigation: boolean,\n  scrollableSegmentsResult: Array<FlightSegmentPath>\n): Task | null {\n  const segmentPath: Array<FlightSegmentPath> = []\n  return updateCacheNodeOnNavigation(\n    navigatedAt,\n    oldUrl,\n    oldCacheNode,\n    oldRouterState,\n    newRouterState,\n    false,\n    prefetchData,\n    prefetchHead,\n    isPrefetchHeadPartial,\n    isSamePageNavigation,\n    segmentPath,\n    scrollableSegmentsResult\n  )\n}\n\nfunction updateCacheNodeOnNavigation(\n  navigatedAt: number,\n  oldUrl: URL,\n  oldCacheNode: CacheNode,\n  oldRouterState: FlightRouterState,\n  newRouterState: FlightRouterState,\n  didFindRootLayout: boolean,\n  prefetchData: CacheNodeSeedData | null,\n  prefetchHead: HeadData | null,\n  isPrefetchHeadPartial: boolean,\n  isSamePageNavigation: boolean,\n  segmentPath: FlightSegmentPath,\n  scrollableSegmentsResult: Array<FlightSegmentPath>\n): Task | null {\n  // Diff the old and new trees to reuse the shared layouts.\n  const oldRouterStateChildren = oldRouterState[1]\n  const newRouterStateChildren = newRouterState[1]\n  const prefetchDataChildren = prefetchData !== null ? prefetchData[1] : null\n\n  if (!didFindRootLayout) {\n    // We're currently traversing the part of the tree that was also part of\n    // the previous route. If we discover a root layout, then we don't need to\n    // trigger an MPA navigation. See beginRenderingNewRouteTree for context.\n    const isRootLayout = newRouterState[4] === true\n    if (isRootLayout) {\n      // Found a matching root layout.\n      didFindRootLayout = true\n    }\n  }\n\n  const oldParallelRoutes = oldCacheNode.parallelRoutes\n\n  // Clone the current set of segment children, even if they aren't active in\n  // the new tree.\n  // TODO: We currently retain all the inactive segments indefinitely, until\n  // there's an explicit refresh, or a parent layout is lazily refreshed. We\n  // rely on this for popstate navigations, which update the Router State Tree\n  // but do not eagerly perform a data fetch, because they expect the segment\n  // data to already be in the Cache Node tree. For highly static sites that\n  // are mostly read-only, this may happen only rarely, causing memory to\n  // leak. We should figure out a better model for the lifetime of inactive\n  // segments, so we can maintain instant back/forward navigations without\n  // leaking memory indefinitely.\n  const prefetchParallelRoutes = new Map(oldParallelRoutes)\n\n  // As we diff the trees, we may sometimes modify (copy-on-write, not mutate)\n  // the Route Tree that was returned by the server — for example, in the case\n  // of default parallel routes, we preserve the currently active segment. To\n  // avoid mutating the original tree, we clone the router state children along\n  // the return path.\n  let patchedRouterStateChildren: {\n    [parallelRouteKey: string]: FlightRouterState\n  } = {}\n  let taskChildren = null\n\n  // Most navigations require a request to fetch additional data from the\n  // server, either because the data was not already prefetched, or because the\n  // target route contains dynamic data that cannot be prefetched.\n  //\n  // However, if the target route is fully static, and it's already completely\n  // loaded into the segment cache, then we can skip the server request.\n  //\n  // This starts off as `false`, and is set to `true` if any of the child\n  // routes requires a dynamic request.\n  let needsDynamicRequest = false\n  // As we traverse the children, we'll construct a FlightRouterState that can\n  // be sent to the server to request the dynamic data. If it turns out that\n  // nothing in the subtree is dynamic (i.e. needsDynamicRequest is false at the\n  // end), then this will be discarded.\n  // TODO: We can probably optimize the format of this data structure to only\n  // include paths that are dynamic. Instead of reusing the\n  // FlightRouterState type.\n  let dynamicRequestTreeChildren: {\n    [parallelRouteKey: string]: FlightRouterState\n  } = {}\n\n  for (let parallelRouteKey in newRouterStateChildren) {\n    const newRouterStateChild: FlightRouterState =\n      newRouterStateChildren[parallelRouteKey]\n    const oldRouterStateChild: FlightRouterState | void =\n      oldRouterStateChildren[parallelRouteKey]\n    const oldSegmentMapChild = oldParallelRoutes.get(parallelRouteKey)\n    const prefetchDataChild: CacheNodeSeedData | void | null =\n      prefetchDataChildren !== null\n        ? prefetchDataChildren[parallelRouteKey]\n        : null\n\n    const newSegmentChild = newRouterStateChild[0]\n    const newSegmentPathChild = segmentPath.concat([\n      parallelRouteKey,\n      newSegmentChild,\n    ])\n    const newSegmentKeyChild = createRouterCacheKey(newSegmentChild)\n\n    const oldSegmentChild =\n      oldRouterStateChild !== undefined ? oldRouterStateChild[0] : undefined\n\n    const oldCacheNodeChild =\n      oldSegmentMapChild !== undefined\n        ? oldSegmentMapChild.get(newSegmentKeyChild)\n        : undefined\n\n    let taskChild: Task | null\n    if (newSegmentChild === DEFAULT_SEGMENT_KEY) {\n      // This is another kind of leaf segment — a default route.\n      //\n      // Default routes have special behavior. When there's no matching segment\n      // for a parallel route, Next.js preserves the currently active segment\n      // during a client navigation — but not for initial render. The server\n      // leaves it to the client to account for this. So we need to handle\n      // it here.\n      if (oldRouterStateChild !== undefined) {\n        // Reuse the existing Router State for this segment. We spawn a \"task\"\n        // just to keep track of the updated router state; unlike most, it's\n        // already fulfilled and won't be affected by the dynamic response.\n        taskChild = reuseActiveSegmentInDefaultSlot(oldUrl, oldRouterStateChild)\n      } else {\n        // There's no currently active segment. Switch to the \"create\" path.\n        taskChild = beginRenderingNewRouteTree(\n          navigatedAt,\n          oldRouterStateChild,\n          newRouterStateChild,\n          oldCacheNodeChild,\n          didFindRootLayout,\n          prefetchDataChild !== undefined ? prefetchDataChild : null,\n          prefetchHead,\n          isPrefetchHeadPartial,\n          newSegmentPathChild,\n          scrollableSegmentsResult\n        )\n      }\n    } else if (\n      isSamePageNavigation &&\n      // Check if this is a page segment.\n      // TODO: We're not consistent about how we do this check. Some places\n      // check if the segment starts with PAGE_SEGMENT_KEY, but most seem to\n      // check if there any any children, which is why I'm doing it here. We\n      // should probably encode an empty children set as `null` though. Either\n      // way, we should update all the checks to be consistent.\n      Object.keys(newRouterStateChild[1]).length === 0\n    ) {\n      // We special case navigations to the exact same URL as the current\n      // location. It's a common UI pattern for apps to refresh when you click a\n      // link to the current page. So when this happens, we refresh the dynamic\n      // data in the page segments.\n      //\n      // Note that this does not apply if the any part of the hash or search\n      // query has changed. This might feel a bit weird but it makes more sense\n      // when you consider that the way to trigger this behavior is to click\n      // the same link multiple times.\n      //\n      // TODO: We should probably refresh the *entire* route when this case\n      // occurs, not just the page segments. Essentially treating it the same as\n      // a refresh() triggered by an action, which is the more explicit way of\n      // modeling the UI pattern described above.\n      //\n      // Also note that this only refreshes the dynamic data, not static/\n      // cached data. If the page segment is fully static and prefetched, the\n      // request is skipped. (This is also how refresh() works.)\n      taskChild = beginRenderingNewRouteTree(\n        navigatedAt,\n        oldRouterStateChild,\n        newRouterStateChild,\n        oldCacheNodeChild,\n        didFindRootLayout,\n        prefetchDataChild !== undefined ? prefetchDataChild : null,\n        prefetchHead,\n        isPrefetchHeadPartial,\n        newSegmentPathChild,\n        scrollableSegmentsResult\n      )\n    } else if (\n      oldRouterStateChild !== undefined &&\n      oldSegmentChild !== undefined &&\n      matchSegment(newSegmentChild, oldSegmentChild)\n    ) {\n      if (\n        oldCacheNodeChild !== undefined &&\n        oldRouterStateChild !== undefined\n      ) {\n        // This segment exists in both the old and new trees. Recursively update\n        // the children.\n        taskChild = updateCacheNodeOnNavigation(\n          navigatedAt,\n          oldUrl,\n          oldCacheNodeChild,\n          oldRouterStateChild,\n          newRouterStateChild,\n          didFindRootLayout,\n          prefetchDataChild,\n          prefetchHead,\n          isPrefetchHeadPartial,\n          isSamePageNavigation,\n          newSegmentPathChild,\n          scrollableSegmentsResult\n        )\n      } else {\n        // There's no existing Cache Node for this segment. Switch to the\n        // \"create\" path.\n        taskChild = beginRenderingNewRouteTree(\n          navigatedAt,\n          oldRouterStateChild,\n          newRouterStateChild,\n          oldCacheNodeChild,\n          didFindRootLayout,\n          prefetchDataChild !== undefined ? prefetchDataChild : null,\n          prefetchHead,\n          isPrefetchHeadPartial,\n          newSegmentPathChild,\n          scrollableSegmentsResult\n        )\n      }\n    } else {\n      // This is a new tree. Switch to the \"create\" path.\n      taskChild = beginRenderingNewRouteTree(\n        navigatedAt,\n        oldRouterStateChild,\n        newRouterStateChild,\n        oldCacheNodeChild,\n        didFindRootLayout,\n        prefetchDataChild !== undefined ? prefetchDataChild : null,\n        prefetchHead,\n        isPrefetchHeadPartial,\n        newSegmentPathChild,\n        scrollableSegmentsResult\n      )\n    }\n\n    if (taskChild !== null) {\n      // Recursively propagate up the child tasks.\n\n      if (taskChild.route === null) {\n        // One of the child tasks discovered a change to the root layout.\n        // Immediately unwind from this recursive traversal.\n        return MPA_NAVIGATION_TASK\n      }\n\n      if (taskChildren === null) {\n        taskChildren = new Map()\n      }\n      taskChildren.set(parallelRouteKey, taskChild)\n      const newCacheNodeChild = taskChild.node\n      if (newCacheNodeChild !== null) {\n        const newSegmentMapChild: ChildSegmentMap = new Map(oldSegmentMapChild)\n        newSegmentMapChild.set(newSegmentKeyChild, newCacheNodeChild)\n        prefetchParallelRoutes.set(parallelRouteKey, newSegmentMapChild)\n      }\n\n      // The child tree's route state may be different from the prefetched\n      // route sent by the server. We need to clone it as we traverse back up\n      // the tree.\n      const taskChildRoute = taskChild.route\n      patchedRouterStateChildren[parallelRouteKey] = taskChildRoute\n\n      const dynamicRequestTreeChild = taskChild.dynamicRequestTree\n      if (dynamicRequestTreeChild !== null) {\n        // Something in the child tree is dynamic.\n        needsDynamicRequest = true\n        dynamicRequestTreeChildren[parallelRouteKey] = dynamicRequestTreeChild\n      } else {\n        dynamicRequestTreeChildren[parallelRouteKey] = taskChildRoute\n      }\n    } else {\n      // The child didn't change. We can use the prefetched router state.\n      patchedRouterStateChildren[parallelRouteKey] = newRouterStateChild\n      dynamicRequestTreeChildren[parallelRouteKey] = newRouterStateChild\n    }\n  }\n\n  if (taskChildren === null) {\n    // No new tasks were spawned.\n    return null\n  }\n\n  const newCacheNode: ReadyCacheNode = {\n    lazyData: null,\n    rsc: oldCacheNode.rsc,\n    // We intentionally aren't updating the prefetchRsc field, since this node\n    // is already part of the current tree, because it would be weird for\n    // prefetch data to be newer than the final data. It probably won't ever be\n    // observable anyway, but it could happen if the segment is unmounted then\n    // mounted again, because LayoutRouter will momentarily switch to rendering\n    // prefetchRsc, via useDeferredValue.\n    prefetchRsc: oldCacheNode.prefetchRsc,\n    head: oldCacheNode.head,\n    prefetchHead: oldCacheNode.prefetchHead,\n    loading: oldCacheNode.loading,\n\n    // Everything is cloned except for the children, which we computed above.\n    parallelRoutes: prefetchParallelRoutes,\n\n    navigatedAt,\n  }\n\n  return {\n    // Return a cloned copy of the router state with updated children.\n    route: patchRouterStateWithNewChildren(\n      newRouterState,\n      patchedRouterStateChildren\n    ),\n    node: newCacheNode,\n    dynamicRequestTree: needsDynamicRequest\n      ? patchRouterStateWithNewChildren(\n          newRouterState,\n          dynamicRequestTreeChildren\n        )\n      : null,\n    children: taskChildren,\n  }\n}\n\nfunction beginRenderingNewRouteTree(\n  navigatedAt: number,\n  oldRouterState: FlightRouterState | void,\n  newRouterState: FlightRouterState,\n  existingCacheNode: CacheNode | void,\n  didFindRootLayout: boolean,\n  prefetchData: CacheNodeSeedData | null,\n  possiblyPartialPrefetchHead: HeadData | null,\n  isPrefetchHeadPartial: boolean,\n  segmentPath: FlightSegmentPath,\n  scrollableSegmentsResult: Array<FlightSegmentPath>\n): Task {\n  if (!didFindRootLayout) {\n    // The route tree changed before we reached a layout. (The highest-level\n    // layout in a route tree is referred to as the \"root\" layout.) This could\n    // mean that we're navigating between two different root layouts. When this\n    // happens, we perform a full-page (MPA-style) navigation.\n    //\n    // However, the algorithm for deciding where to start rendering a route\n    // (i.e. the one performed in order to reach this function) is stricter\n    // than the one used to detect a change in the root layout. So just because\n    // we're re-rendering a segment outside of the root layout does not mean we\n    // should trigger a full-page navigation.\n    //\n    // Specifically, we handle dynamic parameters differently: two segments are\n    // considered the same even if their parameter values are different.\n    //\n    // Refer to isNavigatingToNewRootLayout for details.\n    //\n    // Note that we only have to perform this extra traversal if we didn't\n    // already discover a root layout in the part of the tree that is unchanged.\n    // In the common case, this branch is skipped completely.\n    if (\n      oldRouterState === undefined ||\n      isNavigatingToNewRootLayout(oldRouterState, newRouterState)\n    ) {\n      // The root layout changed. Perform a full-page navigation.\n      return MPA_NAVIGATION_TASK\n    }\n  }\n  return createCacheNodeOnNavigation(\n    navigatedAt,\n    newRouterState,\n    existingCacheNode,\n    prefetchData,\n    possiblyPartialPrefetchHead,\n    isPrefetchHeadPartial,\n    segmentPath,\n    scrollableSegmentsResult\n  )\n}\n\nfunction createCacheNodeOnNavigation(\n  navigatedAt: number,\n  routerState: FlightRouterState,\n  existingCacheNode: CacheNode | void,\n  prefetchData: CacheNodeSeedData | null,\n  possiblyPartialPrefetchHead: HeadData | null,\n  isPrefetchHeadPartial: boolean,\n  segmentPath: FlightSegmentPath,\n  scrollableSegmentsResult: Array<FlightSegmentPath>\n): SPANavigationTask {\n  // Same traversal as updateCacheNodeNavigation, but we switch to this path\n  // once we reach the part of the tree that was not in the previous route. We\n  // don't need to diff against the old tree, we just need to create a new one.\n\n  // The head is assigned to every leaf segment delivered by the server. Based\n  // on corresponding logic in fill-lazy-items-till-leaf-with-head.ts\n  const routerStateChildren = routerState[1]\n  const isLeafSegment = Object.keys(routerStateChildren).length === 0\n\n  // Even we're rendering inside the \"new\" part of the target tree, we may have\n  // a locally cached segment that we can reuse. This may come from either 1)\n  // the CacheNode tree, which lives in React state and is populated by previous\n  // navigations; or 2) the prefetch cache, which is a separate cache that is\n  // populated by prefetches.\n  let rsc: React.ReactNode\n  let loading: LoadingModuleData | Promise<LoadingModuleData>\n  let head: HeadData | null\n  let cacheNodeNavigatedAt: number\n  if (\n    existingCacheNode !== undefined &&\n    // DYNAMIC_STALETIME_MS defaults to 0, but it can be increased using\n    // the experimental.staleTimes.dynamic config. When set, we'll avoid\n    // refetching dynamic data if it was fetched within the given threshold.\n    existingCacheNode.navigatedAt + DYNAMIC_STALETIME_MS > navigatedAt\n  ) {\n    // We have an existing CacheNode for this segment, and it's not stale. We\n    // should reuse it rather than request a new one.\n    rsc = existingCacheNode.rsc\n    loading = existingCacheNode.loading\n    head = existingCacheNode.head\n\n    // Don't update the navigatedAt timestamp, since we're reusing stale data.\n    cacheNodeNavigatedAt = existingCacheNode.navigatedAt\n  } else if (prefetchData !== null) {\n    // There's no existing CacheNode for this segment, but we do have prefetch\n    // data. If the prefetch data is fully static (i.e. does not contain any\n    // dynamic holes), we don't need to request it from the server.\n    rsc = prefetchData[0]\n    loading = prefetchData[2]\n    head = isLeafSegment ? possiblyPartialPrefetchHead : null\n    // Even though we're accessing the data from the prefetch cache, this is\n    // conceptually a new segment, not a reused one. So we should update the\n    // navigatedAt timestamp.\n    cacheNodeNavigatedAt = navigatedAt\n    const isPrefetchRscPartial = prefetchData[3]\n    if (\n      // Check if the segment data is partial\n      isPrefetchRscPartial ||\n      // Check if the head is partial (only relevant if this is a leaf segment)\n      (isPrefetchHeadPartial && isLeafSegment)\n    ) {\n      // We only have partial data from this segment. Like missing segments, we\n      // must request the full data from the server.\n      return spawnPendingTask(\n        navigatedAt,\n        routerState,\n        prefetchData,\n        possiblyPartialPrefetchHead,\n        isPrefetchHeadPartial,\n        segmentPath,\n        scrollableSegmentsResult\n      )\n    } else {\n      // The prefetch data is fully static, so we can omit it from the\n      // navigation request.\n    }\n  } else {\n    // There's no prefetch for this segment. Everything from this point will be\n    // requested from the server, even if there are static children below it.\n    // Create a terminal task node that will later be fulfilled by\n    // server response.\n    return spawnPendingTask(\n      navigatedAt,\n      routerState,\n      null,\n      possiblyPartialPrefetchHead,\n      isPrefetchHeadPartial,\n      segmentPath,\n      scrollableSegmentsResult\n    )\n  }\n\n  // We already have a full segment we can render, so we don't need to request a\n  // new one from the server. Keep traversing down the tree until we reach\n  // something that requires a dynamic request.\n  const prefetchDataChildren = prefetchData !== null ? prefetchData[1] : null\n  const taskChildren = new Map()\n  const existingCacheNodeChildren =\n    existingCacheNode !== undefined ? existingCacheNode.parallelRoutes : null\n  const cacheNodeChildren = new Map(existingCacheNodeChildren)\n  let dynamicRequestTreeChildren: {\n    [parallelRouteKey: string]: FlightRouterState\n  } = {}\n  let needsDynamicRequest = false\n  if (isLeafSegment) {\n    // The segment path of every leaf segment (i.e. page) is collected into\n    // a result array. This is used by the LayoutRouter to scroll to ensure that\n    // new pages are visible after a navigation.\n    // TODO: We should use a string to represent the segment path instead of\n    // an array. We already use a string representation for the path when\n    // accessing the Segment Cache, so we can use the same one.\n    scrollableSegmentsResult.push(segmentPath)\n  } else {\n    for (let parallelRouteKey in routerStateChildren) {\n      const routerStateChild: FlightRouterState =\n        routerStateChildren[parallelRouteKey]\n      const prefetchDataChild: CacheNodeSeedData | void | null =\n        prefetchDataChildren !== null\n          ? prefetchDataChildren[parallelRouteKey]\n          : null\n      const existingSegmentMapChild =\n        existingCacheNodeChildren !== null\n          ? existingCacheNodeChildren.get(parallelRouteKey)\n          : undefined\n      const segmentChild = routerStateChild[0]\n      const segmentPathChild = segmentPath.concat([\n        parallelRouteKey,\n        segmentChild,\n      ])\n      const segmentKeyChild = createRouterCacheKey(segmentChild)\n\n      const existingCacheNodeChild =\n        existingSegmentMapChild !== undefined\n          ? existingSegmentMapChild.get(segmentKeyChild)\n          : undefined\n\n      const taskChild = createCacheNodeOnNavigation(\n        navigatedAt,\n        routerStateChild,\n        existingCacheNodeChild,\n        prefetchDataChild,\n        possiblyPartialPrefetchHead,\n        isPrefetchHeadPartial,\n        segmentPathChild,\n        scrollableSegmentsResult\n      )\n      taskChildren.set(parallelRouteKey, taskChild)\n      const dynamicRequestTreeChild = taskChild.dynamicRequestTree\n      if (dynamicRequestTreeChild !== null) {\n        // Something in the child tree is dynamic.\n        needsDynamicRequest = true\n        dynamicRequestTreeChildren[parallelRouteKey] = dynamicRequestTreeChild\n      } else {\n        dynamicRequestTreeChildren[parallelRouteKey] = routerStateChild\n      }\n      const newCacheNodeChild = taskChild.node\n      if (newCacheNodeChild !== null) {\n        const newSegmentMapChild: ChildSegmentMap = new Map()\n        newSegmentMapChild.set(segmentKeyChild, newCacheNodeChild)\n        cacheNodeChildren.set(parallelRouteKey, newSegmentMapChild)\n      }\n    }\n  }\n\n  return {\n    // Since we're inside a new route tree, unlike the\n    // `updateCacheNodeOnNavigation` path, the router state on the children\n    // tasks is always the same as the router state we pass in. So we don't need\n    // to clone/modify it.\n    route: routerState,\n    node: {\n      lazyData: null,\n      // Since this segment is already full, we don't need to use the\n      // `prefetchRsc` field.\n      rsc,\n      prefetchRsc: null,\n      head,\n      prefetchHead: null,\n      loading,\n      parallelRoutes: cacheNodeChildren,\n      navigatedAt: cacheNodeNavigatedAt,\n    },\n    dynamicRequestTree: needsDynamicRequest\n      ? patchRouterStateWithNewChildren(routerState, dynamicRequestTreeChildren)\n      : null,\n    children: taskChildren,\n  }\n}\n\nfunction patchRouterStateWithNewChildren(\n  baseRouterState: FlightRouterState,\n  newChildren: { [parallelRouteKey: string]: FlightRouterState }\n): FlightRouterState {\n  const clone: FlightRouterState = [baseRouterState[0], newChildren]\n  // Based on equivalent logic in apply-router-state-patch-to-tree, but should\n  // confirm whether we need to copy all of these fields. Not sure the server\n  // ever sends, e.g. the refetch marker.\n  if (2 in baseRouterState) {\n    clone[2] = baseRouterState[2]\n  }\n  if (3 in baseRouterState) {\n    clone[3] = baseRouterState[3]\n  }\n  if (4 in baseRouterState) {\n    clone[4] = baseRouterState[4]\n  }\n  return clone\n}\n\nfunction spawnPendingTask(\n  navigatedAt: number,\n  routerState: FlightRouterState,\n  prefetchData: CacheNodeSeedData | null,\n  prefetchHead: HeadData | null,\n  isPrefetchHeadPartial: boolean,\n  segmentPath: FlightSegmentPath,\n  scrollableSegmentsResult: Array<FlightSegmentPath>\n): SPANavigationTask {\n  // Create a task that will later be fulfilled by data from the server.\n\n  // Clone the prefetched route tree and the `refetch` marker to it. We'll send\n  // this to the server so it knows where to start rendering.\n  const dynamicRequestTree = patchRouterStateWithNewChildren(\n    routerState,\n    routerState[1]\n  )\n  dynamicRequestTree[3] = 'refetch'\n\n  const newTask: Task = {\n    route: routerState,\n\n    // Corresponds to the part of the route that will be rendered on the server.\n    node: createPendingCacheNode(\n      navigatedAt,\n      routerState,\n      prefetchData,\n      prefetchHead,\n      isPrefetchHeadPartial,\n      segmentPath,\n      scrollableSegmentsResult\n    ),\n    // Because this is non-null, and it gets propagated up through the parent\n    // tasks, the root task will know that it needs to perform a server request.\n    dynamicRequestTree,\n    children: null,\n  }\n  return newTask\n}\n\nfunction reuseActiveSegmentInDefaultSlot(\n  oldUrl: URL,\n  oldRouterState: FlightRouterState\n): Task {\n  // This is a \"default\" segment. These are never sent by the server during a\n  // soft navigation; instead, the client reuses whatever segment was already\n  // active in that slot on the previous route. This means if we later need to\n  // refresh the segment, it will have to be refetched from the previous route's\n  // URL. We store it in the Flight Router State.\n  //\n  // TODO: We also mark the segment with a \"refresh\" marker but I think we can\n  // get rid of that eventually by making sure we only add URLs to page segments\n  // that are reused. Then the presence of the URL alone is enough.\n  let reusedRouterState\n\n  const oldRefreshMarker = oldRouterState[3]\n  if (oldRefreshMarker === 'refresh') {\n    // This segment was already reused from an even older route. Keep its\n    // existing URL and refresh marker.\n    reusedRouterState = oldRouterState\n  } else {\n    // This segment was not previously reused, and it's not on the new route.\n    // So it must have been delivered in the old route.\n    reusedRouterState = patchRouterStateWithNewChildren(\n      oldRouterState,\n      oldRouterState[1]\n    )\n    reusedRouterState[2] = createHrefFromUrl(oldUrl)\n    reusedRouterState[3] = 'refresh'\n  }\n\n  return {\n    route: reusedRouterState,\n    node: null,\n    dynamicRequestTree: null,\n    children: null,\n  }\n}\n\n// Writes a dynamic server response into the tree created by\n// updateCacheNodeOnNavigation. All pending promises that were spawned by the\n// navigation will be resolved, either with dynamic data from the server, or\n// `null` to indicate that the data is missing.\n//\n// A `null` value will trigger a lazy fetch during render, which will then patch\n// up the tree using the same mechanism as the non-PPR implementation\n// (serverPatchReducer).\n//\n// Usually, the server will respond with exactly the subset of data that we're\n// waiting for — everything below the nearest shared layout. But technically,\n// the server can return anything it wants.\n//\n// This does _not_ create a new tree; it modifies the existing one in place.\n// Which means it must follow the Suspense rules of cache safety.\nexport function listenForDynamicRequest(\n  task: SPANavigationTask,\n  responsePromise: Promise<FetchServerResponseResult>\n) {\n  responsePromise.then(\n    (result: FetchServerResponseResult) => {\n      if (typeof result === 'string') {\n        // Happens when navigating to page in `pages` from `app`. We shouldn't\n        // get here because should have already handled this during\n        // the prefetch.\n        return\n      }\n      const { flightData, debugInfo } = result\n      for (const normalizedFlightData of flightData) {\n        const {\n          segmentPath,\n          tree: serverRouterState,\n          seedData: dynamicData,\n          head: dynamicHead,\n        } = normalizedFlightData\n\n        if (!dynamicData) {\n          // This shouldn't happen. PPR should always send back a response.\n          // However, `FlightDataPath` is a shared type and the pre-PPR handling of\n          // this might return null.\n          continue\n        }\n\n        writeDynamicDataIntoPendingTask(\n          task,\n          segmentPath,\n          serverRouterState,\n          dynamicData,\n          dynamicHead,\n          debugInfo\n        )\n      }\n\n      // Now that we've exhausted all the data we received from the server, if\n      // there are any remaining pending tasks in the tree, abort them now.\n      // If there's any missing data, it will trigger a lazy fetch.\n      abortTask(task, null, debugInfo)\n    },\n    (error: any) => {\n      // This will trigger an error during render\n      abortTask(task, error, null)\n    }\n  )\n}\n\nfunction writeDynamicDataIntoPendingTask(\n  rootTask: SPANavigationTask,\n  segmentPath: FlightSegmentPath,\n  serverRouterState: FlightRouterState,\n  dynamicData: CacheNodeSeedData,\n  dynamicHead: HeadData,\n  debugInfo: Array<any> | null\n) {\n  // The data sent by the server represents only a subtree of the app. We need\n  // to find the part of the task tree that matches the server response, and\n  // fulfill it using the dynamic data.\n  //\n  // segmentPath represents the parent path of subtree. It's a repeating pattern\n  // of parallel route key and segment:\n  //\n  //   [string, Segment, string, Segment, string, Segment, ...]\n  //\n  // Iterate through the path and finish any tasks that match this payload.\n  let task = rootTask\n  for (let i = 0; i < segmentPath.length; i += 2) {\n    const parallelRouteKey: string = segmentPath[i]\n    const segment: Segment = segmentPath[i + 1]\n    const taskChildren = task.children\n    if (taskChildren !== null) {\n      const taskChild = taskChildren.get(parallelRouteKey)\n      if (taskChild !== undefined) {\n        const taskSegment = taskChild.route[0]\n        if (matchSegment(segment, taskSegment)) {\n          // Found a match for this task. Keep traversing down the task tree.\n          task = taskChild\n          continue\n        }\n      }\n    }\n    // We didn't find a child task that matches the server data. Exit. We won't\n    // abort the task, though, because a different FlightDataPath may be able to\n    // fulfill it (see loop in listenForDynamicRequest). We only abort tasks\n    // once we've run out of data.\n    return\n  }\n\n  finishTaskUsingDynamicDataPayload(\n    task,\n    serverRouterState,\n    dynamicData,\n    dynamicHead,\n    debugInfo\n  )\n}\n\nfunction finishTaskUsingDynamicDataPayload(\n  task: SPANavigationTask,\n  serverRouterState: FlightRouterState,\n  dynamicData: CacheNodeSeedData,\n  dynamicHead: HeadData,\n  debugInfo: Array<any> | null\n) {\n  if (task.dynamicRequestTree === null) {\n    // Everything in this subtree is already complete. Bail out.\n    return\n  }\n\n  // dynamicData may represent a larger subtree than the task. Before we can\n  // finish the task, we need to line them up.\n  const taskChildren = task.children\n  const taskNode = task.node\n  if (taskChildren === null) {\n    // We've reached the leaf node of the pending task. The server data tree\n    // lines up the pending Cache Node tree. We can now switch to the\n    // normal algorithm.\n    if (taskNode !== null) {\n      finishPendingCacheNode(\n        taskNode,\n        task.route,\n        serverRouterState,\n        dynamicData,\n        dynamicHead,\n        debugInfo\n      )\n      // Set this to null to indicate that this task is now complete.\n      task.dynamicRequestTree = null\n    }\n    return\n  }\n  // The server returned more data than we need to finish the task. Skip over\n  // the extra segments until we reach the leaf task node.\n  const serverChildren = serverRouterState[1]\n  const dynamicDataChildren = dynamicData[1]\n\n  for (const parallelRouteKey in serverRouterState) {\n    const serverRouterStateChild: FlightRouterState =\n      serverChildren[parallelRouteKey]\n    const dynamicDataChild: CacheNodeSeedData | null | void =\n      dynamicDataChildren[parallelRouteKey]\n\n    const taskChild = taskChildren.get(parallelRouteKey)\n    if (taskChild !== undefined) {\n      const taskSegment = taskChild.route[0]\n      if (\n        matchSegment(serverRouterStateChild[0], taskSegment) &&\n        dynamicDataChild !== null &&\n        dynamicDataChild !== undefined\n      ) {\n        // Found a match for this task. Keep traversing down the task tree.\n        return finishTaskUsingDynamicDataPayload(\n          taskChild,\n          serverRouterStateChild,\n          dynamicDataChild,\n          dynamicHead,\n          debugInfo\n        )\n      }\n    }\n    // We didn't find a child task that matches the server data. We won't abort\n    // the task, though, because a different FlightDataPath may be able to\n    // fulfill it (see loop in listenForDynamicRequest). We only abort tasks\n    // once we've run out of data.\n  }\n}\n\nfunction createPendingCacheNode(\n  navigatedAt: number,\n  routerState: FlightRouterState,\n  prefetchData: CacheNodeSeedData | null,\n  prefetchHead: HeadData | null,\n  isPrefetchHeadPartial: boolean,\n  segmentPath: FlightSegmentPath,\n  scrollableSegmentsResult: Array<FlightSegmentPath>\n): ReadyCacheNode {\n  const routerStateChildren = routerState[1]\n  const prefetchDataChildren = prefetchData !== null ? prefetchData[1] : null\n\n  const parallelRoutes = new Map()\n  for (let parallelRouteKey in routerStateChildren) {\n    const routerStateChild: FlightRouterState =\n      routerStateChildren[parallelRouteKey]\n    const prefetchDataChild: CacheNodeSeedData | null | void =\n      prefetchDataChildren !== null\n        ? prefetchDataChildren[parallelRouteKey]\n        : null\n\n    const segmentChild = routerStateChild[0]\n    const segmentPathChild = segmentPath.concat([\n      parallelRouteKey,\n      segmentChild,\n    ])\n    const segmentKeyChild = createRouterCacheKey(segmentChild)\n\n    const newCacheNodeChild = createPendingCacheNode(\n      navigatedAt,\n      routerStateChild,\n      prefetchDataChild === undefined ? null : prefetchDataChild,\n      prefetchHead,\n      isPrefetchHeadPartial,\n      segmentPathChild,\n      scrollableSegmentsResult\n    )\n\n    const newSegmentMapChild: ChildSegmentMap = new Map()\n    newSegmentMapChild.set(segmentKeyChild, newCacheNodeChild)\n    parallelRoutes.set(parallelRouteKey, newSegmentMapChild)\n  }\n\n  // The head is assigned to every leaf segment delivered by the server. Based\n  // on corresponding logic in fill-lazy-items-till-leaf-with-head.ts\n  const isLeafSegment = parallelRoutes.size === 0\n\n  if (isLeafSegment) {\n    // The segment path of every leaf segment (i.e. page) is collected into\n    // a result array. This is used by the LayoutRouter to scroll to ensure that\n    // new pages are visible after a navigation.\n    // TODO: We should use a string to represent the segment path instead of\n    // an array. We already use a string representation for the path when\n    // accessing the Segment Cache, so we can use the same one.\n    scrollableSegmentsResult.push(segmentPath)\n  }\n\n  const maybePrefetchRsc = prefetchData !== null ? prefetchData[0] : null\n  return {\n    lazyData: null,\n    parallelRoutes: parallelRoutes,\n\n    prefetchRsc: maybePrefetchRsc !== undefined ? maybePrefetchRsc : null,\n    prefetchHead: isLeafSegment ? prefetchHead : [null, null],\n\n    // Create a deferred promise. This will be fulfilled once the dynamic\n    // response is received from the server.\n    rsc: createDeferredRsc() as React.ReactNode,\n    head: isLeafSegment ? (createDeferredRsc() as React.ReactNode) : null,\n\n    // TODO: Technically, a loading boundary could contain dynamic data. We must\n    // have separate `loading` and `prefetchLoading` fields to handle this, like\n    // we do for the segment data and head.\n    loading:\n      prefetchData !== null\n        ? (prefetchData[2] ?? null)\n        : // If we don't have a prefetch, then we don't know if there's a loading component.\n          // We'll fulfill it based on the dynamic response, just like `rsc` and `head`.\n          createDeferredRsc<LoadingModuleData>(),\n\n    navigatedAt,\n  }\n}\n\nfunction finishPendingCacheNode(\n  cacheNode: CacheNode,\n  taskState: FlightRouterState,\n  serverState: FlightRouterState,\n  dynamicData: CacheNodeSeedData,\n  dynamicHead: HeadData,\n  debugInfo: Array<any> | null\n): void {\n  // Writes a dynamic response into an existing Cache Node tree. This does _not_\n  // create a new tree, it updates the existing tree in-place. So it must follow\n  // the Suspense rules of cache safety — it can resolve pending promises, but\n  // it cannot overwrite existing data. It can add segments to the tree (because\n  // a missing segment will cause the layout router to suspend).\n  // but it cannot delete them.\n  //\n  // We must resolve every promise in the tree, or else it will suspend\n  // indefinitely. If we did not receive data for a segment, we will resolve its\n  // data promise to `null` to trigger a lazy fetch during render.\n  const taskStateChildren = taskState[1]\n  const serverStateChildren = serverState[1]\n  const dataChildren = dynamicData[1]\n\n  // The router state that we traverse the tree with (taskState) is the same one\n  // that we used to construct the pending Cache Node tree. That way we're sure\n  // to resolve all the pending promises.\n  const parallelRoutes = cacheNode.parallelRoutes\n  for (let parallelRouteKey in taskStateChildren) {\n    const taskStateChild: FlightRouterState =\n      taskStateChildren[parallelRouteKey]\n    const serverStateChild: FlightRouterState | void =\n      serverStateChildren[parallelRouteKey]\n    const dataChild: CacheNodeSeedData | null | void =\n      dataChildren[parallelRouteKey]\n\n    const segmentMapChild = parallelRoutes.get(parallelRouteKey)\n    const taskSegmentChild = taskStateChild[0]\n    const taskSegmentKeyChild = createRouterCacheKey(taskSegmentChild)\n\n    const cacheNodeChild =\n      segmentMapChild !== undefined\n        ? segmentMapChild.get(taskSegmentKeyChild)\n        : undefined\n\n    if (cacheNodeChild !== undefined) {\n      if (\n        serverStateChild !== undefined &&\n        matchSegment(taskSegmentChild, serverStateChild[0])\n      ) {\n        if (dataChild !== undefined && dataChild !== null) {\n          // This is the happy path. Recursively update all the children.\n          finishPendingCacheNode(\n            cacheNodeChild,\n            taskStateChild,\n            serverStateChild,\n            dataChild,\n            dynamicHead,\n            debugInfo\n          )\n        } else {\n          // The server never returned data for this segment. Trigger a lazy\n          // fetch during render. This shouldn't happen because the Route Tree\n          // and the Seed Data tree sent by the server should always be the same\n          // shape when part of the same server response.\n          abortPendingCacheNode(taskStateChild, cacheNodeChild, null, debugInfo)\n        }\n      } else {\n        // The server never returned data for this segment. Trigger a lazy\n        // fetch during render.\n        abortPendingCacheNode(taskStateChild, cacheNodeChild, null, debugInfo)\n      }\n    } else {\n      // The server response matches what was expected to receive, but there's\n      // no matching Cache Node in the task tree. This is a bug in the\n      // implementation because we should have created a node for every\n      // segment in the tree that's associated with this task.\n    }\n  }\n\n  // Use the dynamic data from the server to fulfill the deferred RSC promise\n  // on the Cache Node.\n  const rsc = cacheNode.rsc\n  const dynamicSegmentData = dynamicData[0]\n  if (rsc === null) {\n    // This is a lazy cache node. We can overwrite it. This is only safe\n    // because we know that the LayoutRouter suspends if `rsc` is `null`.\n    cacheNode.rsc = dynamicSegmentData\n  } else if (isDeferredRsc(rsc)) {\n    // This is a deferred RSC promise. We can fulfill it with the data we just\n    // received from the server. If it was already resolved by a different\n    // navigation, then this does nothing because we can't overwrite data.\n    rsc.resolve(dynamicSegmentData, debugInfo)\n  } else {\n    // This is not a deferred RSC promise, nor is it empty, so it must have\n    // been populated by a different navigation. We must not overwrite it.\n  }\n\n  // If we navigated without a prefetch, then `loading` will be a deferred promise too.\n  // Fulfill it using the dynamic response so that we can display the loading boundary.\n  const loading = cacheNode.loading\n  if (isDeferredRsc(loading)) {\n    const dynamicLoading = dynamicData[2]\n    loading.resolve(dynamicLoading, debugInfo)\n  }\n\n  // Check if this is a leaf segment. If so, it will have a `head` property with\n  // a pending promise that needs to be resolved with the dynamic head from\n  // the server.\n  const head = cacheNode.head\n  if (isDeferredRsc(head)) {\n    head.resolve(dynamicHead, debugInfo)\n  }\n}\n\nexport function abortTask(\n  task: SPANavigationTask,\n  error: any,\n  debugInfo: Array<any> | null\n): void {\n  const cacheNode = task.node\n  if (cacheNode === null) {\n    // This indicates the task is already complete.\n    return\n  }\n\n  const taskChildren = task.children\n  if (taskChildren === null) {\n    // Reached the leaf task node. This is the root of a pending cache\n    // node tree.\n    abortPendingCacheNode(task.route, cacheNode, error, debugInfo)\n  } else {\n    // This is an intermediate task node. Keep traversing until we reach a\n    // task node with no children. That will be the root of the cache node tree\n    // that needs to be resolved.\n    for (const taskChild of taskChildren.values()) {\n      abortTask(taskChild, error, debugInfo)\n    }\n  }\n\n  // Set this to null to indicate that this task is now complete.\n  task.dynamicRequestTree = null\n}\n\nfunction abortPendingCacheNode(\n  routerState: FlightRouterState,\n  cacheNode: CacheNode,\n  error: any,\n  debugInfo: Array<any> | null\n): void {\n  // For every pending segment in the tree, resolve its `rsc` promise to `null`\n  // to trigger a lazy fetch during render.\n  //\n  // Or, if an error object is provided, it will error instead.\n  const routerStateChildren = routerState[1]\n  const parallelRoutes = cacheNode.parallelRoutes\n  for (let parallelRouteKey in routerStateChildren) {\n    const routerStateChild: FlightRouterState =\n      routerStateChildren[parallelRouteKey]\n    const segmentMapChild = parallelRoutes.get(parallelRouteKey)\n    if (segmentMapChild === undefined) {\n      // This shouldn't happen because we're traversing the same tree that was\n      // used to construct the cache nodes in the first place.\n      continue\n    }\n    const segmentChild = routerStateChild[0]\n    const segmentKeyChild = createRouterCacheKey(segmentChild)\n    const cacheNodeChild = segmentMapChild.get(segmentKeyChild)\n    if (cacheNodeChild !== undefined) {\n      abortPendingCacheNode(routerStateChild, cacheNodeChild, error, debugInfo)\n    } else {\n      // This shouldn't happen because we're traversing the same tree that was\n      // used to construct the cache nodes in the first place.\n    }\n  }\n\n  const rsc = cacheNode.rsc\n  if (isDeferredRsc(rsc)) {\n    if (error === null) {\n      // This will trigger a lazy fetch during render.\n      rsc.resolve(null, debugInfo)\n    } else {\n      // This will trigger an error during rendering.\n      rsc.reject(error, debugInfo)\n    }\n  }\n\n  const loading = cacheNode.loading\n  if (isDeferredRsc(loading)) {\n    loading.resolve(null, debugInfo)\n  }\n\n  // Check if this is a leaf segment. If so, it will have a `head` property with\n  // a pending promise that needs to be resolved. If an error was provided, we\n  // will not resolve it with an error, since this is rendered at the root of\n  // the app. We want the segment to error, not the entire app.\n  const head = cacheNode.head\n  if (isDeferredRsc(head)) {\n    head.resolve(null, debugInfo)\n  }\n}\n\nexport function updateCacheNodeOnPopstateRestoration(\n  oldCacheNode: CacheNode,\n  routerState: FlightRouterState\n): ReadyCacheNode {\n  // A popstate navigation reads data from the local cache. It does not issue\n  // new network requests (unless the cache entries have been evicted). So, we\n  // update the cache to drop the prefetch data for any segment whose dynamic\n  // data was already received. This prevents an unnecessary flash back to PPR\n  // state during a back/forward navigation.\n  //\n  // This function clones the entire cache node tree and sets the `prefetchRsc`\n  // field to `null` to prevent it from being rendered. We can't mutate the node\n  // in place because this is a concurrent data structure.\n\n  const routerStateChildren = routerState[1]\n  const oldParallelRoutes = oldCacheNode.parallelRoutes\n  const newParallelRoutes = new Map(oldParallelRoutes)\n  for (let parallelRouteKey in routerStateChildren) {\n    const routerStateChild: FlightRouterState =\n      routerStateChildren[parallelRouteKey]\n    const segmentChild = routerStateChild[0]\n    const segmentKeyChild = createRouterCacheKey(segmentChild)\n    const oldSegmentMapChild = oldParallelRoutes.get(parallelRouteKey)\n    if (oldSegmentMapChild !== undefined) {\n      const oldCacheNodeChild = oldSegmentMapChild.get(segmentKeyChild)\n      if (oldCacheNodeChild !== undefined) {\n        const newCacheNodeChild = updateCacheNodeOnPopstateRestoration(\n          oldCacheNodeChild,\n          routerStateChild\n        )\n        const newSegmentMapChild = new Map(oldSegmentMapChild)\n        newSegmentMapChild.set(segmentKeyChild, newCacheNodeChild)\n        newParallelRoutes.set(parallelRouteKey, newSegmentMapChild)\n      }\n    }\n  }\n\n  // Only show prefetched data if the dynamic data is still pending.\n  //\n  // Tehnically, what we're actually checking is whether the dynamic network\n  // response was received. But since it's a streaming response, this does not\n  // mean that all the dynamic data has fully streamed in. It just means that\n  // _some_ of the dynamic data was received. But as a heuristic, we assume that\n  // the rest dynamic data will stream in quickly, so it's still better to skip\n  // the prefetch state.\n  const rsc = oldCacheNode.rsc\n  const shouldUsePrefetch = isDeferredRsc(rsc) && rsc.status === 'pending'\n\n  return {\n    lazyData: null,\n    rsc,\n    head: oldCacheNode.head,\n\n    prefetchHead: shouldUsePrefetch ? oldCacheNode.prefetchHead : [null, null],\n    prefetchRsc: shouldUsePrefetch ? oldCacheNode.prefetchRsc : null,\n    loading: oldCacheNode.loading,\n\n    // These are the cloned children we computed above\n    parallelRoutes: newParallelRoutes,\n\n    navigatedAt: oldCacheNode.navigatedAt,\n  }\n}\n\nconst DEFERRED = Symbol()\n\ntype PendingDeferredRsc<T> = Promise<T> & {\n  status: 'pending'\n  resolve: (value: T, debugInfo: Array<any> | null) => void\n  reject: (error: any, debugInfo: Array<any> | null) => void\n  tag: Symbol\n  _debugInfo: Array<any>\n}\n\ntype FulfilledDeferredRsc<T> = Promise<T> & {\n  status: 'fulfilled'\n  value: T\n  resolve: (value: T, debugInfo: Array<any> | null) => void\n  reject: (error: any, debugInfo: Array<any> | null) => void\n  tag: Symbol\n  _debugInfo: Array<any>\n}\n\ntype RejectedDeferredRsc<T> = Promise<T> & {\n  status: 'rejected'\n  reason: any\n  resolve: (value: T, debugInfo: Array<any> | null) => void\n  reject: (error: any, debugInfo: Array<any> | null) => void\n  tag: Symbol\n  _debugInfo: Array<any>\n}\n\ntype DeferredRsc<T extends React.ReactNode = React.ReactNode> =\n  | PendingDeferredRsc<T>\n  | FulfilledDeferredRsc<T>\n  | RejectedDeferredRsc<T>\n\n// This type exists to distinguish a DeferredRsc from a Flight promise. It's a\n// compromise to avoid adding an extra field on every Cache Node, which would be\n// awkward because the pre-PPR parts of codebase would need to account for it,\n// too. We can remove it once type Cache Node type is more settled.\nfunction isDeferredRsc(value: any): value is DeferredRsc {\n  return value && typeof value === 'object' && value.tag === DEFERRED\n}\n\nfunction createDeferredRsc<\n  T extends React.ReactNode = React.ReactNode,\n>(): PendingDeferredRsc<T> {\n  // Create an unresolved promise that represents data derived from a Flight\n  // response. The promise will be resolved later as soon as we start receiving\n  // data from the server, i.e. as soon as the Flight client decodes and returns\n  // the top-level response object.\n\n  // The `_debugInfo` field contains profiling information. Promises that are\n  // created by Flight already have this info added by React; for any derived\n  // promise created by the router, we need to transfer the Flight debug info\n  // onto the derived promise.\n  //\n  // The debug info represents the latency between the start of the navigation\n  // and the start of rendering. (It does not represent the time it takes for\n  // whole stream to finish.)\n  const debugInfo: Array<any> = []\n\n  let resolve: any\n  let reject: any\n  const pendingRsc = new Promise<T>((res, rej) => {\n    resolve = res\n    reject = rej\n  }) as PendingDeferredRsc<T>\n  pendingRsc.status = 'pending'\n  pendingRsc.resolve = (value: T, responseDebugInfo: Array<any> | null) => {\n    if (pendingRsc.status === 'pending') {\n      const fulfilledRsc: FulfilledDeferredRsc<T> = pendingRsc as any\n      fulfilledRsc.status = 'fulfilled'\n      fulfilledRsc.value = value\n      if (responseDebugInfo !== null) {\n        // Transfer the debug info to the derived promise.\n        debugInfo.push.apply(debugInfo, responseDebugInfo)\n      }\n      resolve(value)\n    }\n  }\n  pendingRsc.reject = (error: any, responseDebugInfo: Array<any> | null) => {\n    if (pendingRsc.status === 'pending') {\n      const rejectedRsc: RejectedDeferredRsc<T> = pendingRsc as any\n      rejectedRsc.status = 'rejected'\n      rejectedRsc.reason = error\n      if (responseDebugInfo !== null) {\n        // Transfer the debug info to the derived promise.\n        debugInfo.push.apply(debugInfo, responseDebugInfo)\n      }\n      reject(error)\n    }\n  }\n  pendingRsc.tag = DEFERRED\n  pendingRsc._debugInfo = debugInfo\n\n  return pendingRsc\n}\n","import type {\n  CacheNodeSeedData,\n  FlightRouterState,\n  FlightSegmentPath,\n} from '../../../shared/lib/app-router-types'\nimport type { CacheNode } from '../../../shared/lib/app-router-types'\nimport type {\n  HeadData,\n  LoadingModuleData,\n} from '../../../shared/lib/app-router-types'\nimport type { NormalizedFlightData } from '../../flight-data-helpers'\nimport { fetchServerResponse } from '../router-reducer/fetch-server-response'\nimport {\n  startPPRNavigation,\n  listenForDynamicRequest,\n  type Task as PPRNavigationTask,\n} from '../router-reducer/ppr-navigations'\nimport { createHrefFromUrl } from '../router-reducer/create-href-from-url'\nimport {\n  EntryStatus,\n  readRouteCacheEntry,\n  readSegmentCacheEntry,\n  waitForSegmentCacheEntry,\n  requestOptimisticRouteCacheEntry,\n  type RouteTree,\n  type FulfilledRouteCacheEntry,\n} from './cache'\nimport { createCacheKey } from './cache-key'\nimport { addSearchParamsIfPageSegment } from '../../../shared/lib/segment'\nimport { NavigationResultTag } from './types'\n\ntype MPANavigationResult = {\n  tag: NavigationResultTag.MPA\n  data: string\n}\n\ntype NoOpNavigationResult = {\n  tag: NavigationResultTag.NoOp\n  data: {\n    canonicalUrl: string\n    shouldScroll: boolean\n  }\n}\n\ntype SuccessfulNavigationResult = {\n  tag: NavigationResultTag.Success\n  data: {\n    flightRouterState: FlightRouterState\n    cacheNode: CacheNode\n    canonicalUrl: string\n    renderedSearch: string\n    scrollableSegments: Array<FlightSegmentPath>\n    shouldScroll: boolean\n    hash: string\n  }\n}\n\ntype AsyncNavigationResult = {\n  tag: NavigationResultTag.Async\n  data: Promise<\n    MPANavigationResult | NoOpNavigationResult | SuccessfulNavigationResult\n  >\n}\n\nexport type NavigationResult =\n  | MPANavigationResult\n  | SuccessfulNavigationResult\n  | NoOpNavigationResult\n  | AsyncNavigationResult\n\n/**\n * Navigate to a new URL, using the Segment Cache to construct a response.\n *\n * To allow for synchronous navigations whenever possible, this is not an async\n * function. It returns a promise only if there's no matching prefetch in\n * the cache. Otherwise it returns an immediate result and uses Suspense/RSC to\n * stream in any missing data.\n */\nexport function navigate(\n  url: URL,\n  currentUrl: URL,\n  currentCacheNode: CacheNode,\n  currentFlightRouterState: FlightRouterState,\n  nextUrl: string | null,\n  shouldScroll: boolean,\n  accumulation: { collectedDebugInfo?: Array<unknown> }\n): NavigationResult {\n  const now = Date.now()\n  const href = url.href\n\n  // We special case navigations to the exact same URL as the current location.\n  // It's a common UI pattern for apps to refresh when you click a link to the\n  // current page. So when this happens, we refresh the dynamic data in the page\n  // segments.\n  //\n  // Note that this does not apply if the any part of the hash or search query\n  // has changed. This might feel a bit weird but it makes more sense when you\n  // consider that the way to trigger this behavior is to click the same link\n  // multiple times.\n  //\n  // TODO: We should probably refresh the *entire* route when this case occurs,\n  // not just the page segments. Essentially treating it the same as a refresh()\n  // triggered by an action, which is the more explicit way of modeling the UI\n  // pattern described above.\n  //\n  // Also note that this only refreshes the dynamic data, not static/ cached\n  // data. If the page segment is fully static and prefetched, the request is\n  // skipped. (This is also how refresh() works.)\n  const isSamePageNavigation =\n    // TODO: This is not the only place we read from the location, but we should\n    // consider storing the current URL in the router state instead of reading\n    // from the location object. In practice I don't think this matters much\n    // since we keep them in sync anyway, but having two sources of truth can\n    // lead to subtle bugs and race conditions.\n    href === window.location.href\n\n  const cacheKey = createCacheKey(href, nextUrl)\n  const route = readRouteCacheEntry(now, cacheKey)\n  if (route !== null && route.status === EntryStatus.Fulfilled) {\n    // We have a matching prefetch.\n    const snapshot = readRenderSnapshotFromCache(now, route, route.tree)\n    const prefetchFlightRouterState = snapshot.flightRouterState\n    const prefetchSeedData = snapshot.seedData\n    const headSnapshot = readHeadSnapshotFromCache(now, route)\n    const prefetchHead = headSnapshot.rsc\n    const isPrefetchHeadPartial = headSnapshot.isPartial\n    // TODO: The \"canonicalUrl\" stored in the cache doesn't include the hash,\n    // because hash entries do not vary by hash fragment. However, the one\n    // we set in the router state *does* include the hash, and it's used to\n    // sync with the actual browser location. To make this less of a refactor\n    // hazard, we should always track the hash separately from the rest of\n    // the URL.\n    const newCanonicalUrl = route.canonicalUrl + url.hash\n    const renderedSearch = route.renderedSearch\n    return navigateUsingPrefetchedRouteTree(\n      now,\n      url,\n      currentUrl,\n      nextUrl,\n      isSamePageNavigation,\n      currentCacheNode,\n      currentFlightRouterState,\n      prefetchFlightRouterState,\n      prefetchSeedData,\n      prefetchHead,\n      isPrefetchHeadPartial,\n      newCanonicalUrl,\n      renderedSearch,\n      shouldScroll,\n      url.hash\n    )\n  }\n\n  // There was no matching route tree in the cache. Let's see if we can\n  // construct an \"optimistic\" route tree.\n  //\n  // Do not construct an optimistic route tree if there was a cache hit, but\n  // the entry has a rejected status, since it may have been rejected due to a\n  // rewrite or redirect based on the search params.\n  //\n  // TODO: There are multiple reasons a prefetch might be rejected; we should\n  // track them explicitly and choose what to do here based on that.\n  if (route === null || route.status !== EntryStatus.Rejected) {\n    const optimisticRoute = requestOptimisticRouteCacheEntry(now, url, nextUrl)\n    if (optimisticRoute !== null) {\n      // We have an optimistic route tree. Proceed with the normal flow.\n      const snapshot = readRenderSnapshotFromCache(\n        now,\n        optimisticRoute,\n        optimisticRoute.tree\n      )\n      const prefetchFlightRouterState = snapshot.flightRouterState\n      const prefetchSeedData = snapshot.seedData\n      const headSnapshot = readHeadSnapshotFromCache(now, optimisticRoute)\n      const prefetchHead = headSnapshot.rsc\n      const isPrefetchHeadPartial = headSnapshot.isPartial\n      const newCanonicalUrl = optimisticRoute.canonicalUrl + url.hash\n      const newRenderedSearch = optimisticRoute.renderedSearch\n      return navigateUsingPrefetchedRouteTree(\n        now,\n        url,\n        currentUrl,\n        nextUrl,\n        isSamePageNavigation,\n        currentCacheNode,\n        currentFlightRouterState,\n        prefetchFlightRouterState,\n        prefetchSeedData,\n        prefetchHead,\n        isPrefetchHeadPartial,\n        newCanonicalUrl,\n        newRenderedSearch,\n        shouldScroll,\n        url.hash\n      )\n    }\n  }\n\n  // There's no matching prefetch for this route in the cache.\n  let collectedDebugInfo = accumulation.collectedDebugInfo ?? []\n  if (accumulation.collectedDebugInfo === undefined) {\n    collectedDebugInfo = accumulation.collectedDebugInfo = []\n  }\n  return {\n    tag: NavigationResultTag.Async,\n    data: navigateDynamicallyWithNoPrefetch(\n      now,\n      url,\n      currentUrl,\n      nextUrl,\n      isSamePageNavigation,\n      currentCacheNode,\n      currentFlightRouterState,\n      shouldScroll,\n      url.hash,\n      collectedDebugInfo\n    ),\n  }\n}\n\nfunction navigateUsingPrefetchedRouteTree(\n  now: number,\n  url: URL,\n  currentUrl: URL,\n  nextUrl: string | null,\n  isSamePageNavigation: boolean,\n  currentCacheNode: CacheNode,\n  currentFlightRouterState: FlightRouterState,\n  prefetchFlightRouterState: FlightRouterState,\n  prefetchSeedData: CacheNodeSeedData | null,\n  prefetchHead: HeadData | null,\n  isPrefetchHeadPartial: boolean,\n  canonicalUrl: string,\n  renderedSearch: string,\n  shouldScroll: boolean,\n  hash: string\n): SuccessfulNavigationResult | NoOpNavigationResult | MPANavigationResult {\n  // Recursively construct a prefetch tree by reading from the Segment Cache. To\n  // maintain compatibility, we output the same data structures as the old\n  // prefetching implementation: FlightRouterState and CacheNodeSeedData.\n  // TODO: Eventually updateCacheNodeOnNavigation (or the equivalent) should\n  // read from the Segment Cache directly. It's only structured this way for now\n  // so we can share code with the old prefetching implementation.\n  const scrollableSegments: Array<FlightSegmentPath> = []\n  const task = startPPRNavigation(\n    now,\n    currentUrl,\n    currentCacheNode,\n    currentFlightRouterState,\n    prefetchFlightRouterState,\n    prefetchSeedData,\n    prefetchHead,\n    isPrefetchHeadPartial,\n    isSamePageNavigation,\n    scrollableSegments\n  )\n  if (task !== null) {\n    const dynamicRequestTree = task.dynamicRequestTree\n    if (dynamicRequestTree !== null) {\n      const promiseForDynamicServerResponse = fetchServerResponse(\n        new URL(canonicalUrl, url.origin),\n        {\n          flightRouterState: dynamicRequestTree,\n          nextUrl,\n        }\n      )\n      listenForDynamicRequest(task, promiseForDynamicServerResponse)\n    } else {\n      // The prefetched tree does not contain dynamic holes — it's\n      // fully static. We can skip the dynamic request.\n    }\n    return navigationTaskToResult(\n      task,\n      currentCacheNode,\n      canonicalUrl,\n      renderedSearch,\n      scrollableSegments,\n      shouldScroll,\n      hash\n    )\n  }\n  // The server sent back an empty tree patch. There's nothing to update, except\n  // possibly the URL.\n  return {\n    tag: NavigationResultTag.NoOp,\n    data: {\n      canonicalUrl,\n      shouldScroll,\n    },\n  }\n}\n\nfunction navigationTaskToResult(\n  task: PPRNavigationTask,\n  currentCacheNode: CacheNode,\n  canonicalUrl: string,\n  renderedSearch: string,\n  scrollableSegments: Array<FlightSegmentPath>,\n  shouldScroll: boolean,\n  hash: string\n): SuccessfulNavigationResult | MPANavigationResult {\n  const flightRouterState = task.route\n  if (flightRouterState === null) {\n    // When no router state is provided, it signals that we should perform an\n    // MPA navigation.\n    return {\n      tag: NavigationResultTag.MPA,\n      data: canonicalUrl,\n    }\n  }\n  const newCacheNode = task.node\n  return {\n    tag: NavigationResultTag.Success,\n    data: {\n      flightRouterState,\n      cacheNode: newCacheNode !== null ? newCacheNode : currentCacheNode,\n      canonicalUrl,\n      renderedSearch,\n      scrollableSegments,\n      shouldScroll,\n      hash,\n    },\n  }\n}\n\nfunction readRenderSnapshotFromCache(\n  now: number,\n  route: FulfilledRouteCacheEntry,\n  tree: RouteTree\n): { flightRouterState: FlightRouterState; seedData: CacheNodeSeedData } {\n  let childRouterStates: { [parallelRouteKey: string]: FlightRouterState } = {}\n  let childSeedDatas: {\n    [parallelRouteKey: string]: CacheNodeSeedData | null\n  } = {}\n  const slots = tree.slots\n  if (slots !== null) {\n    for (const parallelRouteKey in slots) {\n      const childTree = slots[parallelRouteKey]\n      const childResult = readRenderSnapshotFromCache(now, route, childTree)\n      childRouterStates[parallelRouteKey] = childResult.flightRouterState\n      childSeedDatas[parallelRouteKey] = childResult.seedData\n    }\n  }\n\n  let rsc: React.ReactNode | null = null\n  let loading: LoadingModuleData | Promise<LoadingModuleData> = null\n  let isPartial: boolean = true\n\n  const segmentEntry = readSegmentCacheEntry(now, tree.varyPath)\n  if (segmentEntry !== null) {\n    switch (segmentEntry.status) {\n      case EntryStatus.Fulfilled: {\n        // Happy path: a cache hit\n        rsc = segmentEntry.rsc\n        loading = segmentEntry.loading\n        isPartial = segmentEntry.isPartial\n        break\n      }\n      case EntryStatus.Pending: {\n        // We haven't received data for this segment yet, but there's already\n        // an in-progress request. Since it's extremely likely to arrive\n        // before the dynamic data response, we might as well use it.\n        const promiseForFulfilledEntry = waitForSegmentCacheEntry(segmentEntry)\n        rsc = promiseForFulfilledEntry.then((entry) =>\n          entry !== null ? entry.rsc : null\n        )\n        loading = promiseForFulfilledEntry.then((entry) =>\n          entry !== null ? entry.loading : null\n        )\n        // Since we don't know yet whether the segment is partial or fully\n        // static, we must assume it's partial; we can't skip the\n        // dynamic request.\n        isPartial = true\n        break\n      }\n      case EntryStatus.Empty:\n      case EntryStatus.Rejected:\n        break\n      default:\n        segmentEntry satisfies never\n    }\n  }\n\n  // The navigation implementation expects the search params to be\n  // included in the segment. However, the Segment Cache tracks search\n  // params separately from the rest of the segment key. So we need to\n  // add them back here.\n  //\n  // See corresponding comment in convertFlightRouterStateToTree.\n  //\n  // TODO: What we should do instead is update the navigation diffing\n  // logic to compare search params explicitly. This is a temporary\n  // solution until more of the Segment Cache implementation has settled.\n  const segment = addSearchParamsIfPageSegment(\n    tree.segment,\n    Object.fromEntries(new URLSearchParams(route.renderedSearch))\n  )\n\n  // We don't need this information in a render snapshot, so this can just be a placeholder.\n  const hasRuntimePrefetch = false\n\n  return {\n    flightRouterState: [\n      segment,\n      childRouterStates,\n      null,\n      null,\n      tree.isRootLayout,\n    ],\n    seedData: [rsc, childSeedDatas, loading, isPartial, hasRuntimePrefetch],\n  }\n}\n\nfunction readHeadSnapshotFromCache(\n  now: number,\n  route: FulfilledRouteCacheEntry\n): { rsc: HeadData; isPartial: boolean } {\n  // Same as readRenderSnapshotFromCache, but for the head\n  let rsc: React.ReactNode | null = null\n  let isPartial: boolean = true\n  const segmentEntry = readSegmentCacheEntry(now, route.metadata.varyPath)\n  if (segmentEntry !== null) {\n    switch (segmentEntry.status) {\n      case EntryStatus.Fulfilled: {\n        rsc = segmentEntry.rsc\n        isPartial = segmentEntry.isPartial\n        break\n      }\n      case EntryStatus.Pending: {\n        const promiseForFulfilledEntry = waitForSegmentCacheEntry(segmentEntry)\n        rsc = promiseForFulfilledEntry.then((entry) =>\n          entry !== null ? entry.rsc : null\n        )\n        isPartial = true\n        break\n      }\n      case EntryStatus.Empty:\n      case EntryStatus.Rejected:\n        break\n      default:\n        segmentEntry satisfies never\n    }\n  }\n  return { rsc, isPartial }\n}\n\nasync function navigateDynamicallyWithNoPrefetch(\n  now: number,\n  url: URL,\n  currentUrl: URL,\n  nextUrl: string | null,\n  isSamePageNavigation: boolean,\n  currentCacheNode: CacheNode,\n  currentFlightRouterState: FlightRouterState,\n  shouldScroll: boolean,\n  hash: string,\n  collectedDebugInfo: Array<unknown>\n): Promise<\n  MPANavigationResult | SuccessfulNavigationResult | NoOpNavigationResult\n> {\n  // Runs when a navigation happens but there's no cached prefetch we can use.\n  // Don't bother to wait for a prefetch response; go straight to a full\n  // navigation that contains both static and dynamic data in a single stream.\n  // (This is unlike the old navigation implementation, which instead blocks\n  // the dynamic request until a prefetch request is received.)\n  //\n  // To avoid duplication of logic, we're going to pretend that the tree\n  // returned by the dynamic request is, in fact, a prefetch tree. Then we can\n  // use the same server response to write the actual data into the CacheNode\n  // tree. So it's the same flow as the \"happy path\" (prefetch, then\n  // navigation), except we use a single server response for both stages.\n\n  const promiseForDynamicServerResponse = fetchServerResponse(url, {\n    flightRouterState: currentFlightRouterState,\n    nextUrl,\n  })\n  const result = await promiseForDynamicServerResponse\n  if (typeof result === 'string') {\n    // This is an MPA navigation.\n    const newUrl = result\n    return {\n      tag: NavigationResultTag.MPA,\n      data: newUrl,\n    }\n  }\n\n  const {\n    flightData,\n    canonicalUrl,\n    renderedSearch,\n    debugInfo: debugInfoFromResponse,\n  } = result\n  if (debugInfoFromResponse !== null) {\n    collectedDebugInfo.push(...debugInfoFromResponse)\n  }\n\n  // Since the response format of dynamic requests and prefetches is slightly\n  // different, we'll need to massage the data a bit. Create FlightRouterState\n  // tree that simulates what we'd receive as the result of a prefetch.\n  const prefetchFlightRouterState = simulatePrefetchTreeUsingDynamicTreePatch(\n    currentFlightRouterState,\n    flightData\n  )\n\n  // In our simulated prefetch payload, we pretend that there's no seed data\n  // nor a prefetch head.\n  const prefetchSeedData = null\n  const prefetchHead = null\n  const isPrefetchHeadPartial = true\n\n  // Now we proceed exactly as we would for normal navigation.\n  const scrollableSegments: Array<FlightSegmentPath> = []\n  const task = startPPRNavigation(\n    now,\n    currentUrl,\n    currentCacheNode,\n    currentFlightRouterState,\n    prefetchFlightRouterState,\n    prefetchSeedData,\n    prefetchHead,\n    isPrefetchHeadPartial,\n    isSamePageNavigation,\n    scrollableSegments\n  )\n  if (task !== null) {\n    // In this case, we've already sent the dynamic request, so we don't\n    // actually use the request tree created by `startPPRNavigation`,\n    // except to check if it contains dynamic holes.\n    //\n    // This is almost always true, but it could be false if all the segment data\n    // was present in the cache, but the route tree was not. E.g. navigating\n    // to a URL that was not prefetched but rewrites to a different URL\n    // that was.\n    const hasDynamicHoles = task.dynamicRequestTree !== null\n    if (hasDynamicHoles) {\n      listenForDynamicRequest(task, promiseForDynamicServerResponse)\n    } else {\n      // The prefetched tree does not contain dynamic holes — it's\n      // fully static. We don't need to process the server response further.\n    }\n    return navigationTaskToResult(\n      task,\n      currentCacheNode,\n      createHrefFromUrl(canonicalUrl),\n      renderedSearch,\n      scrollableSegments,\n      shouldScroll,\n      hash\n    )\n  }\n  // The server sent back an empty tree patch. There's nothing to update, except\n  // possibly the URL.\n  return {\n    tag: NavigationResultTag.NoOp,\n    data: {\n      canonicalUrl: createHrefFromUrl(canonicalUrl),\n      shouldScroll,\n    },\n  }\n}\n\nfunction simulatePrefetchTreeUsingDynamicTreePatch(\n  currentTree: FlightRouterState,\n  flightData: Array<NormalizedFlightData>\n): FlightRouterState {\n  // Takes the current FlightRouterState and applies the router state patch\n  // received from the server, to create a full FlightRouterState tree that we\n  // can pretend was returned by a prefetch.\n  //\n  // (It sounds similar to what applyRouterStatePatch does, but it doesn't need\n  // to handle stuff like interception routes or diffing since that will be\n  // handled later.)\n  let baseTree = currentTree\n  for (const { segmentPath, tree: treePatch } of flightData) {\n    // If the server sends us multiple tree patches, we only need to clone the\n    // base tree when applying the first patch. After the first patch, we can\n    // apply the remaining patches in place without copying.\n    const canMutateInPlace = baseTree !== currentTree\n    baseTree = simulatePrefetchTreeUsingDynamicTreePatchImpl(\n      baseTree,\n      treePatch,\n      segmentPath,\n      canMutateInPlace,\n      0\n    )\n  }\n\n  return baseTree\n}\n\nfunction simulatePrefetchTreeUsingDynamicTreePatchImpl(\n  baseRouterState: FlightRouterState,\n  patch: FlightRouterState,\n  segmentPath: FlightSegmentPath,\n  canMutateInPlace: boolean,\n  index: number\n) {\n  if (index === segmentPath.length) {\n    // We reached the part of the tree that we need to patch.\n    return patch\n  }\n\n  // segmentPath represents the parent path of subtree. It's a repeating\n  // pattern of parallel route key and segment:\n  //\n  //   [string, Segment, string, Segment, string, Segment, ...]\n  //\n  // This path tells us which part of the base tree to apply the tree patch.\n  //\n  // NOTE: In the case of a fully dynamic request with no prefetch, we receive\n  // the FlightRouterState patch in the same request as the dynamic data.\n  // Therefore we don't need to worry about diffing the segment values; we can\n  // assume the server sent us a correct result.\n  const updatedParallelRouteKey: string = segmentPath[index]\n  // const segment: Segment = segmentPath[index + 1] <-- Not used, see note above\n\n  const baseChildren = baseRouterState[1]\n  const newChildren: { [parallelRouteKey: string]: FlightRouterState } = {}\n  for (const parallelRouteKey in baseChildren) {\n    if (parallelRouteKey === updatedParallelRouteKey) {\n      const childBaseRouterState = baseChildren[parallelRouteKey]\n      newChildren[parallelRouteKey] =\n        simulatePrefetchTreeUsingDynamicTreePatchImpl(\n          childBaseRouterState,\n          patch,\n          segmentPath,\n          canMutateInPlace,\n          // Advance the index by two and keep cloning until we reach\n          // the end of the segment path.\n          index + 2\n        )\n    } else {\n      // This child is not being patched. Copy it over as-is.\n      newChildren[parallelRouteKey] = baseChildren[parallelRouteKey]\n    }\n  }\n\n  if (canMutateInPlace) {\n    // We can mutate the base tree in place, because the base tree is already\n    // a clone.\n    baseRouterState[1] = newChildren\n    return baseRouterState\n  }\n\n  // Clone all the fields except the children.\n  //\n  // Based on equivalent logic in apply-router-state-patch-to-tree, but should\n  // confirm whether we need to copy all of these fields. Not sure the server\n  // ever sends, e.g. the refetch marker.\n  const clone: FlightRouterState = [baseRouterState[0], newChildren]\n  if (2 in baseRouterState) {\n    clone[2] = baseRouterState[2]\n  }\n  if (3 in baseRouterState) {\n    clone[3] = baseRouterState[3]\n  }\n  if (4 in baseRouterState) {\n    clone[4] = baseRouterState[4]\n  }\n  return clone\n}\n","import type {\n  FlightRouterState,\n  FlightSegmentPath,\n} from '../../../../shared/lib/app-router-types'\nimport { createHrefFromUrl } from '../create-href-from-url'\nimport type {\n  Mutable,\n  NavigateAction,\n  ReadonlyReducerState,\n  ReducerState,\n} from '../router-reducer-types'\nimport { handleMutable } from '../handle-mutable'\n\nimport {\n  navigate as navigateUsingSegmentCache,\n  type NavigationResult,\n} from '../../segment-cache/navigation'\nimport { NavigationResultTag } from '../../segment-cache/types'\nimport { getStaleTimeMs } from '../../segment-cache/cache'\n\n// These values are set by `define-env-plugin` (based on `nextConfig.experimental.staleTimes`)\n// and default to 5 minutes (static) / 0 seconds (dynamic)\nexport const DYNAMIC_STALETIME_MS =\n  Number(process.env.__NEXT_CLIENT_ROUTER_DYNAMIC_STALETIME) * 1000\n\nexport const STATIC_STALETIME_MS = getStaleTimeMs(\n  Number(process.env.__NEXT_CLIENT_ROUTER_STATIC_STALETIME)\n)\n\nexport function handleExternalUrl(\n  state: ReadonlyReducerState,\n  mutable: Mutable,\n  url: string,\n  pendingPush: boolean\n) {\n  mutable.mpaNavigation = true\n  mutable.canonicalUrl = url\n  mutable.pendingPush = pendingPush\n  mutable.scrollableSegments = undefined\n\n  return handleMutable(state, mutable)\n}\n\nexport function generateSegmentsFromPatch(\n  flightRouterPatch: FlightRouterState\n): FlightSegmentPath[] {\n  const segments: FlightSegmentPath[] = []\n  const [segment, parallelRoutes] = flightRouterPatch\n\n  if (Object.keys(parallelRoutes).length === 0) {\n    return [[segment]]\n  }\n\n  for (const [parallelRouteKey, parallelRoute] of Object.entries(\n    parallelRoutes\n  )) {\n    for (const childSegment of generateSegmentsFromPatch(parallelRoute)) {\n      // If the segment is empty, it means we are at the root of the tree\n      if (segment === '') {\n        segments.push([parallelRouteKey, ...childSegment])\n      } else {\n        segments.push([segment, parallelRouteKey, ...childSegment])\n      }\n    }\n  }\n\n  return segments\n}\n\nfunction handleNavigationResult(\n  url: URL,\n  state: ReadonlyReducerState,\n  mutable: Mutable,\n  pendingPush: boolean,\n  result: NavigationResult\n): ReducerState {\n  switch (result.tag) {\n    case NavigationResultTag.MPA: {\n      // Perform an MPA navigation.\n      const newUrl = result.data\n      return handleExternalUrl(state, mutable, newUrl, pendingPush)\n    }\n    case NavigationResultTag.NoOp: {\n      // The server responded with no change to the current page. However, if\n      // the URL changed, we still need to update that.\n      const newCanonicalUrl = result.data.canonicalUrl\n      mutable.canonicalUrl = newCanonicalUrl\n\n      // Check if the only thing that changed was the hash fragment.\n      const oldUrl = new URL(state.canonicalUrl, url)\n      const onlyHashChange =\n        // We don't need to compare the origins, because client-driven\n        // navigations are always same-origin.\n        url.pathname === oldUrl.pathname &&\n        url.search === oldUrl.search &&\n        url.hash !== oldUrl.hash\n      if (onlyHashChange) {\n        // The only updated part of the URL is the hash.\n        mutable.onlyHashChange = true\n        mutable.shouldScroll = result.data.shouldScroll\n        mutable.hashFragment = url.hash\n        // Setting this to an empty array triggers a scroll for all new and\n        // updated segments. See `ScrollAndFocusHandler` for more details.\n        mutable.scrollableSegments = []\n      }\n\n      return handleMutable(state, mutable)\n    }\n    case NavigationResultTag.Success: {\n      // Received a new result.\n      mutable.cache = result.data.cacheNode\n      mutable.patchedTree = result.data.flightRouterState\n      mutable.renderedSearch = result.data.renderedSearch\n      mutable.canonicalUrl = result.data.canonicalUrl\n      mutable.scrollableSegments = result.data.scrollableSegments\n      mutable.shouldScroll = result.data.shouldScroll\n      mutable.hashFragment = result.data.hash\n      return handleMutable(state, mutable)\n    }\n    case NavigationResultTag.Async: {\n      return result.data.then(\n        (asyncResult) =>\n          handleNavigationResult(url, state, mutable, pendingPush, asyncResult),\n        // If the navigation failed, return the current state.\n        // TODO: This matches the current behavior but we need to do something\n        // better here if the network fails.\n        () => {\n          return state\n        }\n      )\n    }\n    default: {\n      result satisfies never\n      return state\n    }\n  }\n}\n\nexport function navigateReducer(\n  state: ReadonlyReducerState,\n  action: NavigateAction\n): ReducerState {\n  const { url, isExternalUrl, navigateType, shouldScroll } = action\n  const mutable: Mutable = {}\n  const href = createHrefFromUrl(url)\n  const pendingPush = navigateType === 'push'\n\n  mutable.preserveCustomHistoryState = false\n  mutable.pendingPush = pendingPush\n\n  if (isExternalUrl) {\n    return handleExternalUrl(state, mutable, url.toString(), pendingPush)\n  }\n\n  // Handles case where `<meta http-equiv=\"refresh\">` tag is present,\n  // which will trigger an MPA navigation.\n  if (document.getElementById('__next-page-redirect')) {\n    return handleExternalUrl(state, mutable, href, pendingPush)\n  }\n\n  // Temporary glue code between the router reducer and the new navigation\n  // implementation. Eventually we'll rewrite the router reducer to a\n  // state machine.\n  const currentUrl = new URL(state.canonicalUrl, location.origin)\n  const result = navigateUsingSegmentCache(\n    url,\n    currentUrl,\n    state.cache,\n    state.tree,\n    state.nextUrl,\n    shouldScroll,\n    mutable\n  )\n  return handleNavigationResult(url, state, mutable, pendingPush, result)\n}\n","// In output: export mode, the build id is added to the start of the HTML\n// document, directly after the doctype declaration. During a prefetch, the\n// client performs a range request to get the build id, so it can check whether\n// the target page belongs to the same build.\n//\n// The first 64 bytes of the document are requested. The exact number isn't\n// too important; it must be larger than the build id + doctype + closing and\n// ending comment markers, but it doesn't need to match the end of the\n// comment exactly.\n//\n// Build ids are 21 bytes long in the default implementation, though this\n// can be overridden in the Next.js config. For the purposes of this check,\n// it's OK to only match the start of the id, so we'll truncate it if exceeds\n// a certain length.\n\nconst DOCTYPE_PREFIX = '<!DOCTYPE html>' // 15 bytes\nconst MAX_BUILD_ID_LENGTH = 24\n\n// Request the first 64 bytes. The Range header is inclusive of the end value.\nexport const DOC_PREFETCH_RANGE_HEADER_VALUE = 'bytes=0-63'\n\nfunction escapeBuildId(buildId: string) {\n  // If the build id is longer than the given limit, it's OK for our purposes\n  // to only match the beginning.\n  const truncated = buildId.slice(0, MAX_BUILD_ID_LENGTH)\n  // Replace hyphens with underscores so it doesn't break the HTML comment.\n  // (Unlikely, but if this did happen it would break the whole document.)\n  return truncated.replace(/-/g, '_')\n}\n\nexport function insertBuildIdComment(originalHtml: string, buildId: string) {\n  if (\n    // Skip if the build id contains a closing comment marker.\n    buildId.includes('-->') ||\n    // React always inserts a doctype at the start of the document. Skip if it\n    // isn't present. Shouldn't happen; suggests an issue elsewhere.\n    !originalHtml.startsWith(DOCTYPE_PREFIX)\n  ) {\n    // Return the original HTML unchanged. This means the document will not\n    // be prefetched.\n    // TODO: The build id comment is currently only used during prefetches, but\n    // if we eventually use this mechanism for regular navigations, we may need\n    // to error during build if we fail to insert it for some reason.\n    return originalHtml\n  }\n  // The comment must be inserted after the doctype.\n  return originalHtml.replace(\n    DOCTYPE_PREFIX,\n    DOCTYPE_PREFIX + '<!--' + escapeBuildId(buildId) + '-->'\n  )\n}\n\nexport function doesExportedHtmlMatchBuildId(\n  partialHtmlDocument: string,\n  buildId: string\n) {\n  // Check whether the document starts with the expected buildId.\n  return partialHtmlDocument.startsWith(\n    DOCTYPE_PREFIX + '<!--' + escapeBuildId(buildId) + '-->'\n  )\n}\n","import type {\n  TreePrefetch,\n  RootTreePrefetch,\n  SegmentPrefetch,\n} from '../../../server/app-render/collect-segment-data'\nimport type { LoadingModuleData } from '../../../shared/lib/app-router-types'\nimport type {\n  CacheNodeSeedData,\n  Segment as FlightRouterStateSegment,\n} from '../../../shared/lib/app-router-types'\nimport { HasLoadingBoundary } from '../../../shared/lib/app-router-types'\nimport {\n  NEXT_DID_POSTPONE_HEADER,\n  NEXT_ROUTER_PREFETCH_HEADER,\n  NEXT_ROUTER_SEGMENT_PREFETCH_HEADER,\n  NEXT_ROUTER_STALE_TIME_HEADER,\n  NEXT_ROUTER_STATE_TREE_HEADER,\n  NEXT_URL,\n  RSC_CONTENT_TYPE_HEADER,\n  RSC_HEADER,\n} from '../app-router-headers'\nimport {\n  createFetch,\n  createFromNextReadableStream,\n  type RSCResponse,\n  type RequestHeaders,\n} from '../router-reducer/fetch-server-response'\nimport {\n  pingPrefetchTask,\n  isPrefetchTaskDirty,\n  type PrefetchTask,\n  type PrefetchSubtaskResult,\n  startRevalidationCooldown,\n} from './scheduler'\nimport {\n  type RouteVaryPath,\n  type SegmentVaryPath,\n  type PartialSegmentVaryPath,\n  getRouteVaryPath,\n  getFulfilledRouteVaryPath,\n  getSegmentVaryPathForRequest,\n  appendLayoutVaryPath,\n  finalizeLayoutVaryPath,\n  finalizePageVaryPath,\n  clonePageVaryPathWithNewSearchParams,\n  type PageVaryPath,\n  finalizeMetadataVaryPath,\n} from './vary-path'\nimport { getAppBuildId } from '../../app-build-id'\nimport { createHrefFromUrl } from '../router-reducer/create-href-from-url'\nimport type { NormalizedSearch, RouteCacheKey } from './cache-key'\n// TODO: Rename this module to avoid confusion with other types of cache keys\nimport { createCacheKey as createPrefetchRequestKey } from './cache-key'\nimport {\n  doesStaticSegmentAppearInURL,\n  getCacheKeyForDynamicParam,\n  getRenderedPathname,\n  getRenderedSearch,\n  parseDynamicParamFromURLPart,\n} from '../../route-params'\nimport {\n  createCacheMap,\n  getFromCacheMap,\n  setInCacheMap,\n  setSizeInCacheMap,\n  deleteFromCacheMap,\n  isValueExpired,\n  type CacheMap,\n  type MapEntry,\n} from './cache-map'\nimport {\n  appendSegmentRequestKeyPart,\n  convertSegmentPathToStaticExportFilename,\n  createSegmentRequestKeyPart,\n  HEAD_REQUEST_KEY,\n  ROOT_SEGMENT_REQUEST_KEY,\n  type SegmentRequestKey,\n} from '../../../shared/lib/segment-cache/segment-value-encoding'\nimport type {\n  FlightRouterState,\n  NavigationFlightResponse,\n} from '../../../shared/lib/app-router-types'\nimport {\n  normalizeFlightData,\n  prepareFlightRouterStateForRequest,\n} from '../../flight-data-helpers'\nimport { STATIC_STALETIME_MS } from '../router-reducer/reducers/navigate-reducer'\nimport { pingVisibleLinks } from '../links'\nimport { PAGE_SEGMENT_KEY } from '../../../shared/lib/segment'\nimport {\n  DOC_PREFETCH_RANGE_HEADER_VALUE,\n  doesExportedHtmlMatchBuildId,\n} from '../../../shared/lib/segment-cache/output-export-prefetch-encoding'\nimport { FetchStrategy } from './types'\nimport { createPromiseWithResolvers } from '../../../shared/lib/promise-with-resolvers'\n\n/**\n * Ensures a minimum stale time of 30s to avoid issues where the server sends a too\n * short-lived stale time, which would prevent anything from being prefetched.\n */\nexport function getStaleTimeMs(staleTimeSeconds: number): number {\n  return Math.max(staleTimeSeconds, 30) * 1000\n}\n\n// A note on async/await when working in the prefetch cache:\n//\n// Most async operations in the prefetch cache should *not* use async/await,\n// Instead, spawn a subtask that writes the results to a cache entry, and attach\n// a \"ping\" listener to notify the prefetch queue to try again.\n//\n// The reason is we need to be able to access the segment cache and traverse its\n// data structures synchronously. For example, if there's a synchronous update\n// we can take an immediate snapshot of the cache to produce something we can\n// render. Limiting the use of async/await also makes it easier to avoid race\n// conditions, which is especially important because is cache is mutable.\n//\n// Another reason is that while we're performing async work, it's possible for\n// existing entries to become stale, or for Link prefetches to be removed from\n// the queue. For optimal scheduling, we need to be able to \"cancel\" subtasks\n// that are no longer needed. So, when a segment is received from the server, we\n// restart from the root of the tree that's being prefetched, to confirm all the\n// parent segments are still cached. If the segment is no longer reachable from\n// the root, then it's effectively canceled. This is similar to the design of\n// Rust Futures, or React Suspense.\n\ntype RouteTreeShared = {\n  requestKey: SegmentRequestKey\n  // TODO: Remove the `segment` field, now that it can be reconstructed\n  // from `param`.\n  segment: FlightRouterStateSegment\n  slots: null | {\n    [parallelRouteKey: string]: RouteTree\n  }\n  isRootLayout: boolean\n\n  // If this is a dynamic route, indicates whether there is a loading boundary\n  // somewhere in the tree. If not, we can skip the prefetch for the data,\n  // because we know it would be an empty response. (For a static/PPR route,\n  // this value is disregarded, because in that model `loading.tsx` is treated\n  // like any other Suspense boundary.)\n  hasLoadingBoundary: HasLoadingBoundary\n\n  // Indicates whether this route has a runtime prefetch that we can request.\n  // This is determined by the server; it's not purely a user configuration\n  // because the server may determine that a route is fully static and doesn't\n  // need runtime prefetching regardless of the configuration.\n  hasRuntimePrefetch: boolean\n}\n\ntype LayoutRouteTree = RouteTreeShared & {\n  isPage: false\n  varyPath: SegmentVaryPath\n}\n\ntype PageRouteTree = RouteTreeShared & {\n  isPage: true\n  varyPath: PageVaryPath\n}\n\nexport type RouteTree = LayoutRouteTree | PageRouteTree\n\ntype RouteCacheEntryShared = {\n  // This is false only if we're certain the route cannot be intercepted. It's\n  // true in all other cases, including on initialization when we haven't yet\n  // received a response from the server.\n  couldBeIntercepted: boolean\n\n  // Map-related fields.\n  ref: null | MapEntry<RouteCacheEntry>\n  size: number\n  staleAt: number\n  version: number\n}\n\n/**\n * Tracks the status of a cache entry as it progresses from no data (Empty),\n * waiting for server data (Pending), and finished (either Fulfilled or\n * Rejected depending on the response from the server.\n */\nexport const enum EntryStatus {\n  Empty = 0,\n  Pending = 1,\n  Fulfilled = 2,\n  Rejected = 3,\n}\n\ntype PendingRouteCacheEntry = RouteCacheEntryShared & {\n  status: EntryStatus.Empty | EntryStatus.Pending\n  blockedTasks: Set<PrefetchTask> | null\n  canonicalUrl: null\n  renderedSearch: null\n  tree: null\n  metadata: null\n  isPPREnabled: false\n}\n\ntype RejectedRouteCacheEntry = RouteCacheEntryShared & {\n  status: EntryStatus.Rejected\n  blockedTasks: Set<PrefetchTask> | null\n  canonicalUrl: null\n  renderedSearch: null\n  tree: null\n  metadata: null\n  isPPREnabled: boolean\n}\n\nexport type FulfilledRouteCacheEntry = RouteCacheEntryShared & {\n  status: EntryStatus.Fulfilled\n  blockedTasks: null\n  canonicalUrl: string\n  renderedSearch: NormalizedSearch\n  tree: RouteTree\n  metadata: RouteTree\n  isPPREnabled: boolean\n}\n\nexport type RouteCacheEntry =\n  | PendingRouteCacheEntry\n  | FulfilledRouteCacheEntry\n  | RejectedRouteCacheEntry\n\ntype SegmentCacheEntryShared = {\n  fetchStrategy: FetchStrategy\n\n  // Map-related fields.\n  ref: null | MapEntry<SegmentCacheEntry>\n  size: number\n  staleAt: number\n  version: number\n}\n\nexport type EmptySegmentCacheEntry = SegmentCacheEntryShared & {\n  status: EntryStatus.Empty\n  rsc: null\n  loading: null\n  isPartial: true\n  promise: null\n}\n\nexport type PendingSegmentCacheEntry = SegmentCacheEntryShared & {\n  status: EntryStatus.Pending\n  rsc: null\n  loading: null\n  isPartial: true\n  promise: null | PromiseWithResolvers<FulfilledSegmentCacheEntry | null>\n}\n\ntype RejectedSegmentCacheEntry = SegmentCacheEntryShared & {\n  status: EntryStatus.Rejected\n  rsc: null\n  loading: null\n  isPartial: true\n  promise: null\n}\n\nexport type FulfilledSegmentCacheEntry = SegmentCacheEntryShared & {\n  status: EntryStatus.Fulfilled\n  rsc: React.ReactNode | null\n  loading: LoadingModuleData | Promise<LoadingModuleData>\n  isPartial: boolean\n  promise: null\n}\n\nexport type SegmentCacheEntry =\n  | EmptySegmentCacheEntry\n  | PendingSegmentCacheEntry\n  | RejectedSegmentCacheEntry\n  | FulfilledSegmentCacheEntry\n\nexport type NonEmptySegmentCacheEntry = Exclude<\n  SegmentCacheEntry,\n  EmptySegmentCacheEntry\n>\n\nconst isOutputExportMode =\n  process.env.NODE_ENV === 'production' &&\n  process.env.__NEXT_CONFIG_OUTPUT === 'export'\n\nconst MetadataOnlyRequestTree: FlightRouterState = [\n  '',\n  {},\n  null,\n  'metadata-only',\n]\n\nlet routeCacheMap: CacheMap<RouteCacheEntry> = createCacheMap()\nlet segmentCacheMap: CacheMap<SegmentCacheEntry> = createCacheMap()\n\n// All invalidation listeners for the whole cache are tracked in single set.\n// Since we don't yet support tag or path-based invalidation, there's no point\n// tracking them any more granularly than this. Once we add granular\n// invalidation, that may change, though generally the model is to just notify\n// the listeners and allow the caller to poll the prefetch cache with a new\n// prefetch task if desired.\nlet invalidationListeners: Set<PrefetchTask> | null = null\n\n// Incrementing counter used to track cache invalidations.\nlet currentCacheVersion = 0\n\nexport function getCurrentCacheVersion(): number {\n  return currentCacheVersion\n}\n\n/**\n * Used to clear the client prefetch cache when a server action calls\n * revalidatePath or revalidateTag. Eventually we will support only clearing the\n * segments that were actually affected, but there's more work to be done on the\n * server before the client is able to do this correctly.\n */\nexport function revalidateEntireCache(\n  nextUrl: string | null,\n  tree: FlightRouterState\n) {\n  // Increment the current cache version. This does not eagerly evict anything\n  // from the cache, but because all the entries are versioned, and we check\n  // the version when reading from the cache, this effectively causes all\n  // entries to be evicted lazily. We do it lazily because in the future,\n  // actions like revalidateTag or refresh will not evict the entire cache,\n  // but rather some subset of the entries.\n  currentCacheVersion++\n\n  // Start a cooldown before re-prefetching to allow CDN cache propagation.\n  startRevalidationCooldown()\n\n  // Prefetch all the currently visible links again, to re-fill the cache.\n  pingVisibleLinks(nextUrl, tree)\n\n  // Similarly, notify all invalidation listeners (i.e. those passed to\n  // `router.prefetch(onInvalidate)`), so they can trigger a new prefetch\n  // if needed.\n  pingInvalidationListeners(nextUrl, tree)\n}\n\nfunction attachInvalidationListener(task: PrefetchTask): void {\n  // This function is called whenever a prefetch task reads a cache entry. If\n  // the task has an onInvalidate function associated with it — i.e. the one\n  // optionally passed to router.prefetch(onInvalidate) — then we attach that\n  // listener to the every cache entry that the task reads. Then, if an entry\n  // is invalidated, we call the function.\n  if (task.onInvalidate !== null) {\n    if (invalidationListeners === null) {\n      invalidationListeners = new Set([task])\n    } else {\n      invalidationListeners.add(task)\n    }\n  }\n}\n\nfunction notifyInvalidationListener(task: PrefetchTask): void {\n  const onInvalidate = task.onInvalidate\n  if (onInvalidate !== null) {\n    // Clear the callback from the task object to guarantee it's not called more\n    // than once.\n    task.onInvalidate = null\n\n    // This is a user-space function, so we must wrap in try/catch.\n    try {\n      onInvalidate()\n    } catch (error) {\n      if (typeof reportError === 'function') {\n        reportError(error)\n      } else {\n        console.error(error)\n      }\n    }\n  }\n}\n\nexport function pingInvalidationListeners(\n  nextUrl: string | null,\n  tree: FlightRouterState\n): void {\n  // The rough equivalent of pingVisibleLinks, but for onInvalidate callbacks.\n  // This is called when the Next-Url or the base tree changes, since those\n  // may affect the result of a prefetch task. It's also called after a\n  // cache invalidation.\n  if (invalidationListeners !== null) {\n    const tasks = invalidationListeners\n    invalidationListeners = null\n    for (const task of tasks) {\n      if (isPrefetchTaskDirty(task, nextUrl, tree)) {\n        notifyInvalidationListener(task)\n      }\n    }\n  }\n}\n\nexport function readRouteCacheEntry(\n  now: number,\n  key: RouteCacheKey\n): RouteCacheEntry | null {\n  const varyPath: RouteVaryPath = getRouteVaryPath(\n    key.pathname,\n    key.search,\n    key.nextUrl\n  )\n  const isRevalidation = false\n  return getFromCacheMap(\n    now,\n    getCurrentCacheVersion(),\n    routeCacheMap,\n    varyPath,\n    isRevalidation\n  )\n}\n\nexport function readSegmentCacheEntry(\n  now: number,\n  varyPath: SegmentVaryPath\n): SegmentCacheEntry | null {\n  const isRevalidation = false\n  return getFromCacheMap(\n    now,\n    getCurrentCacheVersion(),\n    segmentCacheMap,\n    varyPath,\n    isRevalidation\n  )\n}\n\nfunction readRevalidatingSegmentCacheEntry(\n  now: number,\n  varyPath: SegmentVaryPath\n): SegmentCacheEntry | null {\n  const isRevalidation = true\n  return getFromCacheMap(\n    now,\n    getCurrentCacheVersion(),\n    segmentCacheMap,\n    varyPath,\n    isRevalidation\n  )\n}\n\nexport function waitForSegmentCacheEntry(\n  pendingEntry: PendingSegmentCacheEntry\n): Promise<FulfilledSegmentCacheEntry | null> {\n  // Because the entry is pending, there's already a in-progress request.\n  // Attach a promise to the entry that will resolve when the server responds.\n  let promiseWithResolvers = pendingEntry.promise\n  if (promiseWithResolvers === null) {\n    promiseWithResolvers = pendingEntry.promise =\n      createPromiseWithResolvers<FulfilledSegmentCacheEntry | null>()\n  } else {\n    // There's already a promise we can use\n  }\n  return promiseWithResolvers.promise\n}\n\n/**\n * Checks if an entry for a route exists in the cache. If so, it returns the\n * entry, If not, it adds an empty entry to the cache and returns it.\n */\nexport function readOrCreateRouteCacheEntry(\n  now: number,\n  task: PrefetchTask,\n  key: RouteCacheKey\n): RouteCacheEntry {\n  attachInvalidationListener(task)\n\n  const existingEntry = readRouteCacheEntry(now, key)\n  if (existingEntry !== null) {\n    return existingEntry\n  }\n  // Create a pending entry and add it to the cache.\n  const pendingEntry: PendingRouteCacheEntry = {\n    canonicalUrl: null,\n    status: EntryStatus.Empty,\n    blockedTasks: null,\n    tree: null,\n    metadata: null,\n    // This is initialized to true because we don't know yet whether the route\n    // could be intercepted. It's only set to false once we receive a response\n    // from the server.\n    couldBeIntercepted: true,\n    // Similarly, we don't yet know if the route supports PPR.\n    isPPREnabled: false,\n    renderedSearch: null,\n\n    // Map-related fields\n    ref: null,\n    size: 0,\n    // Since this is an empty entry, there's no reason to ever evict it. It will\n    // be updated when the data is populated.\n    staleAt: Infinity,\n    version: getCurrentCacheVersion(),\n  }\n  const varyPath: RouteVaryPath = getRouteVaryPath(\n    key.pathname,\n    key.search,\n    key.nextUrl\n  )\n  const isRevalidation = false\n  setInCacheMap(routeCacheMap, varyPath, pendingEntry, isRevalidation)\n  return pendingEntry\n}\n\nexport function requestOptimisticRouteCacheEntry(\n  now: number,\n  requestedUrl: URL,\n  nextUrl: string | null\n): FulfilledRouteCacheEntry | null {\n  // This function is called during a navigation when there was no matching\n  // route tree in the prefetch cache. Before de-opting to a blocking,\n  // unprefetched navigation, we will first attempt to construct an \"optimistic\"\n  // route tree by checking the cache for similar routes.\n  //\n  // Check if there's a route with the same pathname, but with different\n  // search params. We can then base our optimistic route tree on this entry.\n  //\n  // Conceptually, we are simulating what would happen if we did perform a\n  // prefetch the requested URL, under the assumption that the server will\n  // not redirect or rewrite the request in a different manner than the\n  // base route tree. This assumption might not hold, in which case we'll have\n  // to recover when we perform the dynamic navigation request. However, this\n  // is what would happen if a route were dynamically rewritten/redirected\n  // in between the prefetch and the navigation. So the logic needs to exist\n  // to handle this case regardless.\n\n  // Look for a route with the same pathname, but with an empty search string.\n  // TODO: There's nothing inherently special about the empty search string;\n  // it's chosen somewhat arbitrarily, with the rationale that it's the most\n  // likely one to exist. But we should update this to match _any_ search\n  // string. The plan is to generalize this logic alongside other improvements\n  // related to \"fallback\" cache entries.\n  const requestedSearch = requestedUrl.search as NormalizedSearch\n  if (requestedSearch === '') {\n    // The caller would have already checked if a route with an empty search\n    // string is in the cache. So we can bail out here.\n    return null\n  }\n  const urlWithoutSearchParams = new URL(requestedUrl)\n  urlWithoutSearchParams.search = ''\n  const routeWithNoSearchParams = readRouteCacheEntry(\n    now,\n    createPrefetchRequestKey(urlWithoutSearchParams.href, nextUrl)\n  )\n\n  if (\n    routeWithNoSearchParams === null ||\n    routeWithNoSearchParams.status !== EntryStatus.Fulfilled\n  ) {\n    // Bail out of constructing an optimistic route tree. This will result in\n    // a blocking, unprefetched navigation.\n    return null\n  }\n\n  // Now we have a base route tree we can \"patch\" with our optimistic values.\n\n  // Optimistically assume that redirects for the requested pathname do\n  // not vary on the search string. Therefore, if the base route was\n  // redirected to a different search string, then the optimistic route\n  // should be redirected to the same search string. Otherwise, we use\n  // the requested search string.\n  const canonicalUrlForRouteWithNoSearchParams = new URL(\n    routeWithNoSearchParams.canonicalUrl,\n    requestedUrl.origin\n  )\n  const optimisticCanonicalSearch =\n    canonicalUrlForRouteWithNoSearchParams.search !== ''\n      ? // Base route was redirected. Reuse the same redirected search string.\n        canonicalUrlForRouteWithNoSearchParams.search\n      : requestedSearch\n\n  // Similarly, optimistically assume that rewrites for the requested\n  // pathname do not vary on the search string. Therefore, if the base\n  // route was rewritten to a different search string, then the optimistic\n  // route should be rewritten to the same search string. Otherwise, we use\n  // the requested search string.\n  const optimisticRenderedSearch =\n    routeWithNoSearchParams.renderedSearch !== ''\n      ? // Base route was rewritten. Reuse the same rewritten search string.\n        routeWithNoSearchParams.renderedSearch\n      : requestedSearch\n\n  const optimisticUrl = new URL(\n    routeWithNoSearchParams.canonicalUrl,\n    location.origin\n  )\n  optimisticUrl.search = optimisticCanonicalSearch\n  const optimisticCanonicalUrl = createHrefFromUrl(optimisticUrl)\n\n  const optimisticRouteTree = createOptimisticRouteTree(\n    routeWithNoSearchParams.tree,\n    optimisticRenderedSearch\n  )\n  const optimisticMetadataTree = createOptimisticRouteTree(\n    routeWithNoSearchParams.metadata,\n    optimisticRenderedSearch\n  )\n\n  // Clone the base route tree, and override the relevant fields with our\n  // optimistic values.\n  const optimisticEntry: FulfilledRouteCacheEntry = {\n    canonicalUrl: optimisticCanonicalUrl,\n\n    status: EntryStatus.Fulfilled,\n    // This isn't cloned because it's instance-specific\n    blockedTasks: null,\n    tree: optimisticRouteTree,\n    metadata: optimisticMetadataTree,\n    couldBeIntercepted: routeWithNoSearchParams.couldBeIntercepted,\n    isPPREnabled: routeWithNoSearchParams.isPPREnabled,\n\n    // Override the rendered search with the optimistic value.\n    renderedSearch: optimisticRenderedSearch,\n\n    // Map-related fields\n    ref: null,\n    size: 0,\n    staleAt: routeWithNoSearchParams.staleAt,\n    version: routeWithNoSearchParams.version,\n  }\n\n  // Do not insert this entry into the cache. It only exists so we can\n  // perform the current navigation. Just return it to the caller.\n  return optimisticEntry\n}\n\nfunction createOptimisticRouteTree(\n  tree: RouteTree,\n  newRenderedSearch: NormalizedSearch\n): RouteTree {\n  // Create a new route tree that identical to the original one except for\n  // the rendered search string, which is contained in the vary path.\n\n  let clonedSlots: Record<string, RouteTree> | null = null\n  const originalSlots = tree.slots\n  if (originalSlots !== null) {\n    clonedSlots = {}\n    for (const parallelRouteKey in originalSlots) {\n      const childTree = originalSlots[parallelRouteKey]\n      clonedSlots[parallelRouteKey] = createOptimisticRouteTree(\n        childTree,\n        newRenderedSearch\n      )\n    }\n  }\n\n  // We only need to clone the vary path if the route is a page.\n  if (tree.isPage) {\n    return {\n      requestKey: tree.requestKey,\n      segment: tree.segment,\n      varyPath: clonePageVaryPathWithNewSearchParams(\n        tree.varyPath,\n        newRenderedSearch\n      ),\n      isPage: true,\n      slots: clonedSlots,\n      isRootLayout: tree.isRootLayout,\n      hasLoadingBoundary: tree.hasLoadingBoundary,\n      hasRuntimePrefetch: tree.hasRuntimePrefetch,\n    }\n  }\n\n  return {\n    requestKey: tree.requestKey,\n    segment: tree.segment,\n    varyPath: tree.varyPath,\n    isPage: false,\n    slots: clonedSlots,\n    isRootLayout: tree.isRootLayout,\n    hasLoadingBoundary: tree.hasLoadingBoundary,\n    hasRuntimePrefetch: tree.hasRuntimePrefetch,\n  }\n}\n\n/**\n * Checks if an entry for a segment exists in the cache. If so, it returns the\n * entry, If not, it adds an empty entry to the cache and returns it.\n */\nexport function readOrCreateSegmentCacheEntry(\n  now: number,\n  fetchStrategy: FetchStrategy,\n  route: FulfilledRouteCacheEntry,\n  tree: RouteTree\n): SegmentCacheEntry {\n  const existingEntry = readSegmentCacheEntry(now, tree.varyPath)\n  if (existingEntry !== null) {\n    return existingEntry\n  }\n  // Create a pending entry and add it to the cache.\n  const varyPathForRequest = getSegmentVaryPathForRequest(fetchStrategy, tree)\n  const pendingEntry = createDetachedSegmentCacheEntry(route.staleAt)\n  const isRevalidation = false\n  setInCacheMap(\n    segmentCacheMap,\n    varyPathForRequest,\n    pendingEntry,\n    isRevalidation\n  )\n  return pendingEntry\n}\n\nexport function readOrCreateRevalidatingSegmentEntry(\n  now: number,\n  fetchStrategy: FetchStrategy,\n  route: FulfilledRouteCacheEntry,\n  tree: RouteTree\n): SegmentCacheEntry {\n  // This function is called when we've already confirmed that a particular\n  // segment is cached, but we want to perform another request anyway in case it\n  // returns more complete and/or fresher data than we already have. The logic\n  // for deciding whether to replace the existing entry is handled elsewhere;\n  // this function just handles retrieving a cache entry that we can use to\n  // track the revalidation.\n  //\n  // The reason revalidations are stored in the cache is because we need to be\n  // able to dedupe multiple revalidation requests. The reason they have to be\n  // handled specially is because we shouldn't overwrite a \"normal\" entry if\n  // one exists at the same keypath. So, for each internal cache location, there\n  // is a special \"revalidation\" slot that is used solely for this purpose.\n  //\n  // You can think of it as if all the revalidation entries were stored in a\n  // separate cache map from the canonical entries, and then transfered to the\n  // canonical cache map once the request is complete — this isn't how it's\n  // actually implemented, since it's more efficient to store them in the same\n  // data structure as the normal entries, but that's how it's modeled\n  // conceptually.\n\n  // TODO: Once we implement Fallback behavior for params, where an entry is\n  // re-keyed based on response information, we'll need to account for the\n  // possibility that the keypath of the previous entry is more generic than\n  // the keypath of the revalidating entry. In other words, the server could\n  // return a less generic entry upon revalidation. For now, though, this isn't\n  // a concern because the keypath is based solely on the prefetch strategy,\n  // not on data contained in the response.\n  const existingEntry = readRevalidatingSegmentCacheEntry(now, tree.varyPath)\n  if (existingEntry !== null) {\n    return existingEntry\n  }\n  // Create a pending entry and add it to the cache.\n  const varyPathForRequest = getSegmentVaryPathForRequest(fetchStrategy, tree)\n  const pendingEntry = createDetachedSegmentCacheEntry(route.staleAt)\n  const isRevalidation = true\n  setInCacheMap(\n    segmentCacheMap,\n    varyPathForRequest,\n    pendingEntry,\n    isRevalidation\n  )\n  return pendingEntry\n}\n\nexport function overwriteRevalidatingSegmentCacheEntry(\n  fetchStrategy: FetchStrategy,\n  route: FulfilledRouteCacheEntry,\n  tree: RouteTree\n) {\n  // This function is called when we've already decided to replace an existing\n  // revalidation entry. Create a new entry and write it into the cache,\n  // overwriting the previous value.\n  const varyPathForRequest = getSegmentVaryPathForRequest(fetchStrategy, tree)\n  const pendingEntry = createDetachedSegmentCacheEntry(route.staleAt)\n  const isRevalidation = true\n  setInCacheMap(\n    segmentCacheMap,\n    varyPathForRequest,\n    pendingEntry,\n    isRevalidation\n  )\n  return pendingEntry\n}\n\nexport function upsertSegmentEntry(\n  now: number,\n  varyPath: SegmentVaryPath,\n  candidateEntry: SegmentCacheEntry\n): SegmentCacheEntry | null {\n  // We have a new entry that has not yet been inserted into the cache. Before\n  // we do so, we need to confirm whether it takes precedence over the existing\n  // entry (if one exists).\n  // TODO: We should not upsert an entry if its key was invalidated in the time\n  // since the request was made. We can do that by passing the \"owner\" entry to\n  // this function and confirming it's the same as `existingEntry`.\n\n  if (isValueExpired(now, getCurrentCacheVersion(), candidateEntry)) {\n    // The entry is expired. We cannot upsert it.\n    return null\n  }\n\n  const existingEntry = readSegmentCacheEntry(now, varyPath)\n  if (existingEntry !== null) {\n    // Don't replace a more specific segment with a less-specific one. A case where this\n    // might happen is if the existing segment was fetched via\n    // `<Link prefetch={true}>`.\n    if (\n      // We fetched the new segment using a different, less specific fetch strategy\n      // than the segment we already have in the cache, so it can't have more content.\n      (candidateEntry.fetchStrategy !== existingEntry.fetchStrategy &&\n        !canNewFetchStrategyProvideMoreContent(\n          existingEntry.fetchStrategy,\n          candidateEntry.fetchStrategy\n        )) ||\n      // The existing entry isn't partial, but the new one is.\n      // (TODO: can this be true if `candidateEntry.fetchStrategy >= existingEntry.fetchStrategy`?)\n      (!existingEntry.isPartial && candidateEntry.isPartial)\n    ) {\n      // We're going to leave revalidating entry in the cache so that it doesn't\n      // get revalidated again unnecessarily. Downgrade the Fulfilled entry to\n      // Rejected and null out the data so it can be garbage collected. We leave\n      // `staleAt` intact to prevent subsequent revalidation attempts only until\n      // the entry expires.\n      const rejectedEntry: RejectedSegmentCacheEntry = candidateEntry as any\n      rejectedEntry.status = EntryStatus.Rejected\n      rejectedEntry.loading = null\n      rejectedEntry.rsc = null\n      return null\n    }\n\n    // Evict the existing entry from the cache.\n    deleteFromCacheMap(existingEntry)\n  }\n\n  const isRevalidation = false\n  setInCacheMap(segmentCacheMap, varyPath, candidateEntry, isRevalidation)\n  return candidateEntry\n}\n\nexport function createDetachedSegmentCacheEntry(\n  staleAt: number\n): EmptySegmentCacheEntry {\n  const emptyEntry: EmptySegmentCacheEntry = {\n    status: EntryStatus.Empty,\n    // Default to assuming the fetch strategy will be PPR. This will be updated\n    // when a fetch is actually initiated.\n    fetchStrategy: FetchStrategy.PPR,\n    rsc: null,\n    loading: null,\n    isPartial: true,\n    promise: null,\n\n    // Map-related fields\n    ref: null,\n    size: 0,\n    staleAt,\n    version: 0,\n  }\n  return emptyEntry\n}\n\nexport function upgradeToPendingSegment(\n  emptyEntry: EmptySegmentCacheEntry,\n  fetchStrategy: FetchStrategy\n): PendingSegmentCacheEntry {\n  const pendingEntry: PendingSegmentCacheEntry = emptyEntry as any\n  pendingEntry.status = EntryStatus.Pending\n  pendingEntry.fetchStrategy = fetchStrategy\n  // Set the version here, since this is right before the request is initiated.\n  // The next time the global cache version is incremented, the entry will\n  // effectively be evicted. This happens before initiating the request, rather\n  // than when receiving the response, because it's guaranteed to happen\n  // before the data is read on the server.\n  pendingEntry.version = getCurrentCacheVersion()\n  return pendingEntry\n}\n\nfunction pingBlockedTasks(entry: {\n  blockedTasks: Set<PrefetchTask> | null\n}): void {\n  const blockedTasks = entry.blockedTasks\n  if (blockedTasks !== null) {\n    for (const task of blockedTasks) {\n      pingPrefetchTask(task)\n    }\n    entry.blockedTasks = null\n  }\n}\n\nfunction fulfillRouteCacheEntry(\n  entry: RouteCacheEntry,\n  tree: RouteTree,\n  metadataVaryPath: PageVaryPath,\n  staleAt: number,\n  couldBeIntercepted: boolean,\n  canonicalUrl: string,\n  renderedSearch: NormalizedSearch,\n  isPPREnabled: boolean\n): FulfilledRouteCacheEntry {\n  // The Head is not actually part of the route tree, but other than that, it's\n  // fetched and cached like a segment. Some functions expect a RouteTree\n  // object, so rather than fork the logic in all those places, we use this\n  // \"fake\" one.\n  const metadata: RouteTree = {\n    requestKey: HEAD_REQUEST_KEY,\n    segment: HEAD_REQUEST_KEY,\n    varyPath: metadataVaryPath,\n    // The metadata isn't really a \"page\" (though it isn't really a \"segment\"\n    // either) but for the purposes of how this field is used, it behaves like\n    // one. If this logic ever gets more complex we can change this to an enum.\n    isPage: true,\n    slots: null,\n    isRootLayout: false,\n    hasLoadingBoundary: HasLoadingBoundary.SubtreeHasNoLoadingBoundary,\n    hasRuntimePrefetch: false,\n  }\n  const fulfilledEntry: FulfilledRouteCacheEntry = entry as any\n  fulfilledEntry.status = EntryStatus.Fulfilled\n  fulfilledEntry.tree = tree\n  fulfilledEntry.metadata = metadata\n  fulfilledEntry.staleAt = staleAt\n  fulfilledEntry.couldBeIntercepted = couldBeIntercepted\n  fulfilledEntry.canonicalUrl = canonicalUrl\n  fulfilledEntry.renderedSearch = renderedSearch\n  fulfilledEntry.isPPREnabled = isPPREnabled\n  pingBlockedTasks(entry)\n  return fulfilledEntry\n}\n\nfunction fulfillSegmentCacheEntry(\n  segmentCacheEntry: PendingSegmentCacheEntry,\n  rsc: React.ReactNode,\n  loading: LoadingModuleData | Promise<LoadingModuleData>,\n  staleAt: number,\n  isPartial: boolean\n): FulfilledSegmentCacheEntry {\n  const fulfilledEntry: FulfilledSegmentCacheEntry = segmentCacheEntry as any\n  fulfilledEntry.status = EntryStatus.Fulfilled\n  fulfilledEntry.rsc = rsc\n  fulfilledEntry.loading = loading\n  fulfilledEntry.staleAt = staleAt\n  fulfilledEntry.isPartial = isPartial\n  // Resolve any listeners that were waiting for this data.\n  if (segmentCacheEntry.promise !== null) {\n    segmentCacheEntry.promise.resolve(fulfilledEntry)\n    // Free the promise for garbage collection.\n    fulfilledEntry.promise = null\n  }\n  return fulfilledEntry\n}\n\nfunction rejectRouteCacheEntry(\n  entry: PendingRouteCacheEntry,\n  staleAt: number\n): void {\n  const rejectedEntry: RejectedRouteCacheEntry = entry as any\n  rejectedEntry.status = EntryStatus.Rejected\n  rejectedEntry.staleAt = staleAt\n  pingBlockedTasks(entry)\n}\n\nfunction rejectSegmentCacheEntry(\n  entry: PendingSegmentCacheEntry,\n  staleAt: number\n): void {\n  const rejectedEntry: RejectedSegmentCacheEntry = entry as any\n  rejectedEntry.status = EntryStatus.Rejected\n  rejectedEntry.staleAt = staleAt\n  if (entry.promise !== null) {\n    // NOTE: We don't currently propagate the reason the prefetch was canceled\n    // but we could by accepting a `reason` argument.\n    entry.promise.resolve(null)\n    entry.promise = null\n  }\n}\n\ntype RouteTreeAccumulator = {\n  metadataVaryPath: PageVaryPath | null\n}\n\nfunction convertRootTreePrefetchToRouteTree(\n  rootTree: RootTreePrefetch,\n  renderedPathname: string,\n  renderedSearch: NormalizedSearch,\n  acc: RouteTreeAccumulator\n) {\n  // Remove trailing and leading slashes\n  const pathnameParts = renderedPathname.split('/').filter((p) => p !== '')\n  const index = 0\n  const rootSegment = ROOT_SEGMENT_REQUEST_KEY\n  return convertTreePrefetchToRouteTree(\n    rootTree.tree,\n    rootSegment,\n    null,\n    ROOT_SEGMENT_REQUEST_KEY,\n    pathnameParts,\n    index,\n    renderedSearch,\n    acc\n  )\n}\n\nfunction convertTreePrefetchToRouteTree(\n  prefetch: TreePrefetch,\n  segment: FlightRouterStateSegment,\n  partialVaryPath: PartialSegmentVaryPath | null,\n  requestKey: SegmentRequestKey,\n  pathnameParts: Array<string>,\n  pathnamePartsIndex: number,\n  renderedSearch: NormalizedSearch,\n  acc: RouteTreeAccumulator\n): RouteTree {\n  // Converts the route tree sent by the server into the format used by the\n  // cache. The cached version of the tree includes additional fields, such as a\n  // cache key for each segment. Since this is frequently accessed, we compute\n  // it once instead of on every access. This same cache key is also used to\n  // request the segment from the server.\n\n  let slots: { [parallelRouteKey: string]: RouteTree } | null = null\n  let isPage: boolean\n  let varyPath: SegmentVaryPath\n  const prefetchSlots = prefetch.slots\n  if (prefetchSlots !== null) {\n    isPage = false\n    varyPath = finalizeLayoutVaryPath(requestKey, partialVaryPath)\n\n    slots = {}\n    for (let parallelRouteKey in prefetchSlots) {\n      const childPrefetch = prefetchSlots[parallelRouteKey]\n      const childParamName = childPrefetch.name\n      const childParamType = childPrefetch.paramType\n      const childServerSentParamKey = childPrefetch.paramKey\n\n      let childDoesAppearInURL: boolean\n      let childSegment: FlightRouterStateSegment\n      let childPartialVaryPath: PartialSegmentVaryPath | null\n      if (childParamType !== null) {\n        // This segment is parameterized. Get the param from the pathname.\n        const childParamValue = parseDynamicParamFromURLPart(\n          childParamType,\n          pathnameParts,\n          pathnamePartsIndex\n        )\n\n        // Assign a cache key to the segment, based on the param value. In the\n        // pre-Segment Cache implementation, the server computes this and sends\n        // it in the body of the response. In the Segment Cache implementation,\n        // the server sends an empty string and we fill it in here.\n\n        // TODO: We're intentionally not adding the search param to page\n        // segments here; it's tracked separately and added back during a read.\n        // This would clearer if we waited to construct the segment until it's\n        // read from the cache, since that's effectively what we're\n        // doing anyway.\n        const childParamKey =\n          // The server omits this field from the prefetch response when\n          // cacheComponents is enabled.\n          childServerSentParamKey !== null\n            ? childServerSentParamKey\n            : // If no param key was sent, use the value parsed on the client.\n              getCacheKeyForDynamicParam(\n                childParamValue,\n                '' as NormalizedSearch\n              )\n\n        childPartialVaryPath = appendLayoutVaryPath(\n          partialVaryPath,\n          childParamKey\n        )\n        childSegment = [childParamName, childParamKey, childParamType]\n        childDoesAppearInURL = true\n      } else {\n        // This segment does not have a param. Inherit the partial vary path of\n        // the parent.\n        childPartialVaryPath = partialVaryPath\n        childSegment = childParamName\n        childDoesAppearInURL = doesStaticSegmentAppearInURL(childParamName)\n      }\n\n      // Only increment the index if the segment appears in the URL. If it's a\n      // \"virtual\" segment, like a route group, it remains the same.\n      const childPathnamePartsIndex = childDoesAppearInURL\n        ? pathnamePartsIndex + 1\n        : pathnamePartsIndex\n\n      const childRequestKeyPart = createSegmentRequestKeyPart(childSegment)\n      const childRequestKey = appendSegmentRequestKeyPart(\n        requestKey,\n        parallelRouteKey,\n        childRequestKeyPart\n      )\n      slots[parallelRouteKey] = convertTreePrefetchToRouteTree(\n        childPrefetch,\n        childSegment,\n        childPartialVaryPath,\n        childRequestKey,\n        pathnameParts,\n        childPathnamePartsIndex,\n        renderedSearch,\n        acc\n      )\n    }\n  } else {\n    if (requestKey.endsWith(PAGE_SEGMENT_KEY)) {\n      // This is a page segment.\n      isPage = true\n      varyPath = finalizePageVaryPath(\n        requestKey,\n        renderedSearch,\n        partialVaryPath\n      )\n      // The metadata \"segment\" is not part the route tree, but it has the same\n      // conceptual params as a page segment. Write the vary path into the\n      // accumulator object. If there are multiple parallel pages, we use the\n      // first one. Which page we choose is arbitrary as long as it's\n      // consistently the same one every time every time. See\n      // finalizeMetadataVaryPath for more details.\n      if (acc.metadataVaryPath === null) {\n        acc.metadataVaryPath = finalizeMetadataVaryPath(\n          requestKey,\n          renderedSearch,\n          partialVaryPath\n        )\n      }\n    } else {\n      // This is a layout segment.\n      isPage = false\n      varyPath = finalizeLayoutVaryPath(requestKey, partialVaryPath)\n    }\n  }\n\n  return {\n    requestKey,\n    segment,\n    varyPath,\n    // TODO: Cheating the type system here a bit because TypeScript can't tell\n    // that the type of isPage and varyPath are consistent. The fix would be to\n    // create separate constructors and call the appropriate one from each of\n    // the branches above. Just seems a bit overkill only for one field so I'll\n    // leave it as-is for now. If isPage were wrong it would break the behavior\n    // and we'd catch it quickly, anyway.\n    isPage: isPage as boolean as any,\n    slots,\n    isRootLayout: prefetch.isRootLayout,\n    // This field is only relevant to dynamic routes. For a PPR/static route,\n    // there's always some partial loading state we can fetch.\n    hasLoadingBoundary: HasLoadingBoundary.SegmentHasLoadingBoundary,\n    hasRuntimePrefetch: prefetch.hasRuntimePrefetch,\n  }\n}\n\nfunction convertRootFlightRouterStateToRouteTree(\n  flightRouterState: FlightRouterState,\n  renderedSearch: NormalizedSearch,\n  acc: RouteTreeAccumulator\n): RouteTree {\n  return convertFlightRouterStateToRouteTree(\n    flightRouterState,\n    ROOT_SEGMENT_REQUEST_KEY,\n    null,\n    renderedSearch,\n    acc\n  )\n}\n\nfunction convertFlightRouterStateToRouteTree(\n  flightRouterState: FlightRouterState,\n  requestKey: SegmentRequestKey,\n  parentPartialVaryPath: PartialSegmentVaryPath | null,\n  renderedSearch: NormalizedSearch,\n  acc: RouteTreeAccumulator\n): RouteTree {\n  const originalSegment = flightRouterState[0]\n\n  let segment: FlightRouterStateSegment\n  let partialVaryPath: PartialSegmentVaryPath | null\n  let isPage: boolean\n  let varyPath: SegmentVaryPath\n  if (Array.isArray(originalSegment)) {\n    isPage = false\n    const paramCacheKey = originalSegment[1]\n    partialVaryPath = appendLayoutVaryPath(parentPartialVaryPath, paramCacheKey)\n    varyPath = finalizeLayoutVaryPath(requestKey, partialVaryPath)\n    segment = originalSegment\n  } else {\n    // This segment does not have a param. Inherit the partial vary path of\n    // the parent.\n    partialVaryPath = parentPartialVaryPath\n    if (requestKey.endsWith(PAGE_SEGMENT_KEY)) {\n      // This is a page segment.\n      isPage = true\n\n      // The navigation implementation expects the search params to be included\n      // in the segment. However, in the case of a static response, the search\n      // params are omitted. So the client needs to add them back in when reading\n      // from the Segment Cache.\n      //\n      // For consistency, we'll do this for dynamic responses, too.\n      //\n      // TODO: We should move search params out of FlightRouterState and handle\n      // them entirely on the client, similar to our plan for dynamic params.\n      segment = PAGE_SEGMENT_KEY\n      varyPath = finalizePageVaryPath(\n        requestKey,\n        renderedSearch,\n        partialVaryPath\n      )\n      // The metadata \"segment\" is not part the route tree, but it has the same\n      // conceptual params as a page segment. Write the vary path into the\n      // accumulator object. If there are multiple parallel pages, we use the\n      // first one. Which page we choose is arbitrary as long as it's\n      // consistently the same one every time every time. See\n      // finalizeMetadataVaryPath for more details.\n      if (acc.metadataVaryPath === null) {\n        acc.metadataVaryPath = finalizeMetadataVaryPath(\n          requestKey,\n          renderedSearch,\n          partialVaryPath\n        )\n      }\n    } else {\n      // This is a layout segment.\n      isPage = false\n      segment = originalSegment\n      varyPath = finalizeLayoutVaryPath(requestKey, partialVaryPath)\n    }\n  }\n\n  let slots: { [parallelRouteKey: string]: RouteTree } | null = null\n\n  const parallelRoutes = flightRouterState[1]\n  for (let parallelRouteKey in parallelRoutes) {\n    const childRouterState = parallelRoutes[parallelRouteKey]\n    const childSegment = childRouterState[0]\n    // TODO: Eventually, the param values will not be included in the response\n    // from the server. We'll instead fill them in on the client by parsing\n    // the URL. This is where we'll do that.\n    const childRequestKeyPart = createSegmentRequestKeyPart(childSegment)\n    const childRequestKey = appendSegmentRequestKeyPart(\n      requestKey,\n      parallelRouteKey,\n      childRequestKeyPart\n    )\n    const childTree = convertFlightRouterStateToRouteTree(\n      childRouterState,\n      childRequestKey,\n      partialVaryPath,\n      renderedSearch,\n      acc\n    )\n    if (slots === null) {\n      slots = {\n        [parallelRouteKey]: childTree,\n      }\n    } else {\n      slots[parallelRouteKey] = childTree\n    }\n  }\n\n  return {\n    requestKey,\n    segment,\n    varyPath,\n    // TODO: Cheating the type system here a bit because TypeScript can't tell\n    // that the type of isPage and varyPath are consistent. The fix would be to\n    // create separate constructors and call the appropriate one from each of\n    // the branches above. Just seems a bit overkill only for one field so I'll\n    // leave it as-is for now. If isPage were wrong it would break the behavior\n    // and we'd catch it quickly, anyway.\n    isPage: isPage as boolean as any,\n    slots,\n    isRootLayout: flightRouterState[4] === true,\n    hasLoadingBoundary:\n      flightRouterState[5] !== undefined\n        ? flightRouterState[5]\n        : HasLoadingBoundary.SubtreeHasNoLoadingBoundary,\n\n    // Non-static tree responses are only used by apps that haven't adopted\n    // Cache Components. So this is always false.\n    hasRuntimePrefetch: false,\n  }\n}\n\nexport function convertRouteTreeToFlightRouterState(\n  routeTree: RouteTree\n): FlightRouterState {\n  const parallelRoutes: Record<string, FlightRouterState> = {}\n  if (routeTree.slots !== null) {\n    for (const parallelRouteKey in routeTree.slots) {\n      parallelRoutes[parallelRouteKey] = convertRouteTreeToFlightRouterState(\n        routeTree.slots[parallelRouteKey]\n      )\n    }\n  }\n  const flightRouterState: FlightRouterState = [\n    routeTree.segment,\n    parallelRoutes,\n    null,\n    null,\n    routeTree.isRootLayout,\n  ]\n  return flightRouterState\n}\n\nexport async function fetchRouteOnCacheMiss(\n  entry: PendingRouteCacheEntry,\n  task: PrefetchTask,\n  key: RouteCacheKey\n): Promise<PrefetchSubtaskResult<null> | null> {\n  // This function is allowed to use async/await because it contains the actual\n  // fetch that gets issued on a cache miss. Notice it writes the result to the\n  // cache entry directly, rather than return data that is then written by\n  // the caller.\n  const pathname = key.pathname\n  const search = key.search\n  const nextUrl = key.nextUrl\n  const segmentPath = '/_tree' as SegmentRequestKey\n\n  const headers: RequestHeaders = {\n    [RSC_HEADER]: '1',\n    [NEXT_ROUTER_PREFETCH_HEADER]: '1',\n    [NEXT_ROUTER_SEGMENT_PREFETCH_HEADER]: segmentPath,\n  }\n  if (nextUrl !== null) {\n    headers[NEXT_URL] = nextUrl\n  }\n\n  try {\n    const url = new URL(pathname + search, location.origin)\n    let response\n    let urlAfterRedirects\n    if (isOutputExportMode) {\n      // In output: \"export\" mode, we can't use headers to request a particular\n      // segment. Instead, we encode the extra request information into the URL.\n      // This is not part of the \"public\" interface of the app; it's an internal\n      // Next.js implementation detail that the app developer should not need to\n      // concern themselves with.\n      //\n      // For example, to request a segment:\n      //\n      //   Path passed to <Link>:   /path/to/page\n      //   Path passed to fetch:    /path/to/page/__next-segments/_tree\n      //\n      //   (This is not the exact protocol, just an illustration.)\n      //\n      // Before we do that, though, we need to account for redirects. Even in\n      // output: \"export\" mode, a proxy might redirect the page to a different\n      // location, but we shouldn't assume or expect that they also redirect all\n      // the segment files, too.\n      //\n      // To check whether the page is redirected, we perform a range request of\n      // the first N bytes of the HTML document. The canonical URL is determined\n      // from the response.\n      //\n      // Then we can use the canonical URL to request the route tree.\n      //\n      // NOTE: We could embed the route tree into the HTML document, to avoid\n      // a second request. We're not doing that currently because it would make\n      // the HTML document larger and affect normal page loads.\n      const htmlResponse = await fetch(url, {\n        headers: {\n          Range: DOC_PREFETCH_RANGE_HEADER_VALUE,\n        },\n      })\n      const partialHtml = await htmlResponse.text()\n      if (!doesExportedHtmlMatchBuildId(partialHtml, getAppBuildId())) {\n        // The target page is not part of this app, or it belongs to a\n        // different build.\n        rejectRouteCacheEntry(entry, Date.now() + 10 * 1000)\n        return null\n      }\n      urlAfterRedirects = htmlResponse.redirected\n        ? new URL(htmlResponse.url)\n        : url\n      response = await fetchPrefetchResponse(\n        addSegmentPathToUrlInOutputExportMode(urlAfterRedirects, segmentPath),\n        headers\n      )\n    } else {\n      // \"Server\" mode. We can use request headers instead of the pathname.\n      // TODO: The eventual plan is to get rid of our custom request headers and\n      // encode everything into the URL, using a similar strategy to the\n      // \"output: export\" block above.\n      response = await fetchPrefetchResponse(url, headers)\n      urlAfterRedirects =\n        response !== null && response.redirected ? new URL(response.url) : url\n    }\n\n    if (\n      !response ||\n      !response.ok ||\n      // 204 is a Cache miss. Though theoretically this shouldn't happen when\n      // PPR is enabled, because we always respond to route tree requests, even\n      // if it needs to be blockingly generated on demand.\n      response.status === 204 ||\n      !response.body\n    ) {\n      // Server responded with an error, or with a miss. We should still cache\n      // the response, but we can try again after 10 seconds.\n      rejectRouteCacheEntry(entry, Date.now() + 10 * 1000)\n      return null\n    }\n\n    // TODO: The canonical URL is the href without the origin. I think\n    // historically the reason for this is because the initial canonical URL\n    // gets passed as a prop to the top-level React component, which means it\n    // needs to be computed during SSR. If it were to include the origin, it\n    // would need to always be same as location.origin on the client, to prevent\n    // a hydration mismatch. To sidestep this complexity, we omit the origin.\n    //\n    // However, since this is neither a native URL object nor a fully qualified\n    // URL string, we need to be careful about how we use it. To prevent subtle\n    // mistakes, we should create a special type for it, instead of just string.\n    // Or, we should just use a (readonly) URL object instead. The type of the\n    // prop that we pass to seed the initial state does not need to be the same\n    // type as the state itself.\n    const canonicalUrl = createHrefFromUrl(urlAfterRedirects)\n\n    // Check whether the response varies based on the Next-Url header.\n    const varyHeader = response.headers.get('vary')\n    const couldBeIntercepted =\n      varyHeader !== null && varyHeader.includes(NEXT_URL)\n\n    // Track when the network connection closes.\n    const closed = createPromiseWithResolvers<void>()\n\n    // This checks whether the response was served from the per-segment cache,\n    // rather than the old prefetching flow. If it fails, it implies that PPR\n    // is disabled on this route.\n    const routeIsPPREnabled =\n      response.headers.get(NEXT_DID_POSTPONE_HEADER) === '2' ||\n      // In output: \"export\" mode, we can't rely on response headers. But if we\n      // receive a well-formed response, we can assume it's a static response,\n      // because all data is static in this mode.\n      isOutputExportMode\n\n    if (routeIsPPREnabled) {\n      const prefetchStream = createPrefetchResponseStream(\n        response.body,\n        closed.resolve,\n        function onResponseSizeUpdate(size) {\n          setSizeInCacheMap(entry, size)\n        }\n      )\n      const serverData = await createFromNextReadableStream<RootTreePrefetch>(\n        prefetchStream,\n        headers\n      )\n      if (serverData.buildId !== getAppBuildId()) {\n        // The server build does not match the client. Treat as a 404. During\n        // an actual navigation, the router will trigger an MPA navigation.\n        // TODO: Consider moving the build ID to a response header so we can check\n        // it before decoding the response, and so there's one way of checking\n        // across all response types.\n        // TODO: We should cache the fact that this is an MPA navigation.\n        rejectRouteCacheEntry(entry, Date.now() + 10 * 1000)\n        return null\n      }\n\n      // Get the params that were used to render the target page. These may\n      // be different from the params in the request URL, if the page\n      // was rewritten.\n      const renderedPathname = getRenderedPathname(response)\n      const renderedSearch = getRenderedSearch(response)\n\n      // Convert the server-sent data into the RouteTree format used by the\n      // client cache.\n      //\n      // During this traversal, we accumulate additional data into this\n      // \"accumulator\" object.\n      const acc: RouteTreeAccumulator = { metadataVaryPath: null }\n      const routeTree = convertRootTreePrefetchToRouteTree(\n        serverData,\n        renderedPathname,\n        renderedSearch,\n        acc\n      )\n      const metadataVaryPath = acc.metadataVaryPath\n      if (metadataVaryPath === null) {\n        rejectRouteCacheEntry(entry, Date.now() + 10 * 1000)\n        return null\n      }\n\n      const staleTimeMs = getStaleTimeMs(serverData.staleTime)\n      fulfillRouteCacheEntry(\n        entry,\n        routeTree,\n        metadataVaryPath,\n        Date.now() + staleTimeMs,\n        couldBeIntercepted,\n        canonicalUrl,\n        renderedSearch,\n        routeIsPPREnabled\n      )\n    } else {\n      // PPR is not enabled for this route. The server responds with a\n      // different format (FlightRouterState) that we need to convert.\n      // TODO: We will unify the responses eventually. I'm keeping the types\n      // separate for now because FlightRouterState has so many\n      // overloaded concerns.\n      const prefetchStream = createPrefetchResponseStream(\n        response.body,\n        closed.resolve,\n        function onResponseSizeUpdate(size) {\n          setSizeInCacheMap(entry, size)\n        }\n      )\n      const serverData =\n        await createFromNextReadableStream<NavigationFlightResponse>(\n          prefetchStream,\n          headers\n        )\n      if (serverData.b !== getAppBuildId()) {\n        // The server build does not match the client. Treat as a 404. During\n        // an actual navigation, the router will trigger an MPA navigation.\n        // TODO: Consider moving the build ID to a response header so we can check\n        // it before decoding the response, and so there's one way of checking\n        // across all response types.\n        // TODO: We should cache the fact that this is an MPA navigation.\n        rejectRouteCacheEntry(entry, Date.now() + 10 * 1000)\n        return null\n      }\n\n      writeDynamicTreeResponseIntoCache(\n        Date.now(),\n        task,\n        // The non-PPR response format is what we'd get if we prefetched these segments\n        // using the LoadingBoundary fetch strategy, so mark their cache entries accordingly.\n        FetchStrategy.LoadingBoundary,\n        response as RSCResponse<NavigationFlightResponse>,\n        serverData,\n        entry,\n        couldBeIntercepted,\n        canonicalUrl,\n        routeIsPPREnabled\n      )\n    }\n\n    if (!couldBeIntercepted) {\n      // This route will never be intercepted. So we can use this entry for all\n      // requests to this route, regardless of the Next-Url header. This works\n      // because when reading the cache we always check for a valid\n      // non-intercepted entry first.\n\n      // Re-key the entry. The `set` implementation handles removing it from\n      // its previous position in the cache. We don't need to do anything to\n      // update the LRU, because the entry is already in it.\n      // TODO: Treat this as an upsert — should check if an entry already\n      // exists at the new keypath, and if so, whether we should keep that\n      // one instead.\n      const fulfilledVaryPath: RouteVaryPath = getFulfilledRouteVaryPath(\n        pathname,\n        search,\n        nextUrl,\n        couldBeIntercepted\n      )\n      const isRevalidation = false\n      setInCacheMap(routeCacheMap, fulfilledVaryPath, entry, isRevalidation)\n    }\n    // Return a promise that resolves when the network connection closes, so\n    // the scheduler can track the number of concurrent network connections.\n    return { value: null, closed: closed.promise }\n  } catch (error) {\n    // Either the connection itself failed, or something bad happened while\n    // decoding the response.\n    rejectRouteCacheEntry(entry, Date.now() + 10 * 1000)\n    return null\n  }\n}\n\nexport async function fetchSegmentOnCacheMiss(\n  route: FulfilledRouteCacheEntry,\n  segmentCacheEntry: PendingSegmentCacheEntry,\n  routeKey: RouteCacheKey,\n  tree: RouteTree\n): Promise<PrefetchSubtaskResult<FulfilledSegmentCacheEntry> | null> {\n  // This function is allowed to use async/await because it contains the actual\n  // fetch that gets issued on a cache miss. Notice it writes the result to the\n  // cache entry directly, rather than return data that is then written by\n  // the caller.\n  //\n  // Segment fetches are non-blocking so we don't need to ping the scheduler\n  // on completion.\n\n  // Use the canonical URL to request the segment, not the original URL. These\n  // are usually the same, but the canonical URL will be different if the route\n  // tree response was redirected. To avoid an extra waterfall on every segment\n  // request, we pass the redirected URL instead of the original one.\n  const url = new URL(route.canonicalUrl, location.origin)\n  const nextUrl = routeKey.nextUrl\n\n  const requestKey = tree.requestKey\n  const normalizedRequestKey =\n    requestKey === ROOT_SEGMENT_REQUEST_KEY\n      ? // The root segment is a special case. To simplify the server-side\n        // handling of these requests, we encode the root segment path as\n        // `_index` instead of as an empty string. This should be treated as\n        // an implementation detail and not as a stable part of the protocol.\n        // It just needs to match the equivalent logic that happens when\n        // prerendering the responses. It should not leak outside of Next.js.\n        ('/_index' as SegmentRequestKey)\n      : requestKey\n\n  const headers: RequestHeaders = {\n    [RSC_HEADER]: '1',\n    [NEXT_ROUTER_PREFETCH_HEADER]: '1',\n    [NEXT_ROUTER_SEGMENT_PREFETCH_HEADER]: normalizedRequestKey,\n  }\n  if (nextUrl !== null) {\n    headers[NEXT_URL] = nextUrl\n  }\n\n  const requestUrl = isOutputExportMode\n    ? // In output: \"export\" mode, we need to add the segment path to the URL.\n      addSegmentPathToUrlInOutputExportMode(url, normalizedRequestKey)\n    : url\n  try {\n    const response = await fetchPrefetchResponse(requestUrl, headers)\n    if (\n      !response ||\n      !response.ok ||\n      response.status === 204 || // Cache miss\n      // This checks whether the response was served from the per-segment cache,\n      // rather than the old prefetching flow. If it fails, it implies that PPR\n      // is disabled on this route. Theoretically this should never happen\n      // because we only issue requests for segments once we've verified that\n      // the route supports PPR.\n      (response.headers.get(NEXT_DID_POSTPONE_HEADER) !== '2' &&\n        // In output: \"export\" mode, we can't rely on response headers. But if\n        // we receive a well-formed response, we can assume it's a static\n        // response, because all data is static in this mode.\n        !isOutputExportMode) ||\n      !response.body\n    ) {\n      // Server responded with an error, or with a miss. We should still cache\n      // the response, but we can try again after 10 seconds.\n      rejectSegmentCacheEntry(segmentCacheEntry, Date.now() + 10 * 1000)\n      return null\n    }\n\n    // Track when the network connection closes.\n    const closed = createPromiseWithResolvers<void>()\n\n    // Wrap the original stream in a new stream that never closes. That way the\n    // Flight client doesn't error if there's a hanging promise.\n    const prefetchStream = createPrefetchResponseStream(\n      response.body,\n      closed.resolve,\n      function onResponseSizeUpdate(size) {\n        setSizeInCacheMap(segmentCacheEntry, size)\n      }\n    )\n    const serverData = await (createFromNextReadableStream(\n      prefetchStream,\n      headers\n    ) as Promise<SegmentPrefetch>)\n    if (serverData.buildId !== getAppBuildId()) {\n      // The server build does not match the client. Treat as a 404. During\n      // an actual navigation, the router will trigger an MPA navigation.\n      // TODO: Consider moving the build ID to a response header so we can check\n      // it before decoding the response, and so there's one way of checking\n      // across all response types.\n      rejectSegmentCacheEntry(segmentCacheEntry, Date.now() + 10 * 1000)\n      return null\n    }\n    return {\n      value: fulfillSegmentCacheEntry(\n        segmentCacheEntry,\n        serverData.rsc,\n        serverData.loading,\n        // TODO: The server does not currently provide per-segment stale time.\n        // So we use the stale time of the route.\n        route.staleAt,\n        serverData.isPartial\n      ),\n      // Return a promise that resolves when the network connection closes, so\n      // the scheduler can track the number of concurrent network connections.\n      closed: closed.promise,\n    }\n  } catch (error) {\n    // Either the connection itself failed, or something bad happened while\n    // decoding the response.\n    rejectSegmentCacheEntry(segmentCacheEntry, Date.now() + 10 * 1000)\n    return null\n  }\n}\n\nexport async function fetchSegmentPrefetchesUsingDynamicRequest(\n  task: PrefetchTask,\n  route: FulfilledRouteCacheEntry,\n  fetchStrategy:\n    | FetchStrategy.LoadingBoundary\n    | FetchStrategy.PPRRuntime\n    | FetchStrategy.Full,\n  dynamicRequestTree: FlightRouterState,\n  spawnedEntries: Map<SegmentRequestKey, PendingSegmentCacheEntry>\n): Promise<PrefetchSubtaskResult<null> | null> {\n  const key = task.key\n  const url = new URL(route.canonicalUrl, location.origin)\n  const nextUrl = key.nextUrl\n\n  if (\n    spawnedEntries.size === 1 &&\n    spawnedEntries.has(route.metadata.requestKey)\n  ) {\n    // The only thing pending is the head. Instruct the server to\n    // skip over everything else.\n    dynamicRequestTree = MetadataOnlyRequestTree\n  }\n\n  const headers: RequestHeaders = {\n    [RSC_HEADER]: '1',\n    [NEXT_ROUTER_STATE_TREE_HEADER]:\n      prepareFlightRouterStateForRequest(dynamicRequestTree),\n  }\n  if (nextUrl !== null) {\n    headers[NEXT_URL] = nextUrl\n  }\n  switch (fetchStrategy) {\n    case FetchStrategy.Full: {\n      // We omit the prefetch header from a full prefetch because it's essentially\n      // just a navigation request that happens ahead of time — it should include\n      // all the same data in the response.\n      break\n    }\n    case FetchStrategy.PPRRuntime: {\n      headers[NEXT_ROUTER_PREFETCH_HEADER] = '2'\n      break\n    }\n    case FetchStrategy.LoadingBoundary: {\n      headers[NEXT_ROUTER_PREFETCH_HEADER] = '1'\n      break\n    }\n    default: {\n      fetchStrategy satisfies never\n    }\n  }\n\n  try {\n    const response = await fetchPrefetchResponse(url, headers)\n    if (!response || !response.ok || !response.body) {\n      // Server responded with an error, or with a miss. We should still cache\n      // the response, but we can try again after 10 seconds.\n      rejectSegmentEntriesIfStillPending(spawnedEntries, Date.now() + 10 * 1000)\n      return null\n    }\n\n    const renderedSearch = getRenderedSearch(response)\n    if (renderedSearch !== route.renderedSearch) {\n      // The search params that were used to render the target page are\n      // different from the search params in the request URL. This only happens\n      // when there's a dynamic rewrite in between the tree prefetch and the\n      // data prefetch.\n      // TODO: For now, since this is an edge case, we reject the prefetch, but\n      // the proper way to handle this is to evict the stale route tree entry\n      // then fill the cache with the new response.\n      rejectSegmentEntriesIfStillPending(spawnedEntries, Date.now() + 10 * 1000)\n      return null\n    }\n\n    // Track when the network connection closes.\n    const closed = createPromiseWithResolvers<void>()\n\n    let fulfilledEntries: Array<FulfilledSegmentCacheEntry> | null = null\n    const prefetchStream = createPrefetchResponseStream(\n      response.body,\n      closed.resolve,\n      function onResponseSizeUpdate(totalBytesReceivedSoFar) {\n        // When processing a dynamic response, we don't know how large each\n        // individual segment is, so approximate by assiging each segment\n        // the average of the total response size.\n        if (fulfilledEntries === null) {\n          // Haven't received enough data yet to know which segments\n          // were included.\n          return\n        }\n        const averageSize = totalBytesReceivedSoFar / fulfilledEntries.length\n        for (const entry of fulfilledEntries) {\n          setSizeInCacheMap(entry, averageSize)\n        }\n      }\n    )\n    const serverData = await (createFromNextReadableStream(\n      prefetchStream,\n      headers\n    ) as Promise<NavigationFlightResponse>)\n\n    const isResponsePartial =\n      fetchStrategy === FetchStrategy.PPRRuntime\n        ? // A runtime prefetch may have holes.\n          serverData.rp?.[0] === true\n        : // Full and LoadingBoundary prefetches cannot have holes.\n          // (even if we did set the prefetch header, we only use this codepath for non-PPR-enabled routes)\n          false\n\n    // Aside from writing the data into the cache, this function also returns\n    // the entries that were fulfilled, so we can streamingly update their sizes\n    // in the LRU as more data comes in.\n    fulfilledEntries = writeDynamicRenderResponseIntoCache(\n      Date.now(),\n      task,\n      fetchStrategy,\n      response as RSCResponse<NavigationFlightResponse>,\n      serverData,\n      isResponsePartial,\n      route,\n      spawnedEntries\n    )\n\n    // Return a promise that resolves when the network connection closes, so\n    // the scheduler can track the number of concurrent network connections.\n    return { value: null, closed: closed.promise }\n  } catch (error) {\n    rejectSegmentEntriesIfStillPending(spawnedEntries, Date.now() + 10 * 1000)\n    return null\n  }\n}\n\nfunction writeDynamicTreeResponseIntoCache(\n  now: number,\n  task: PrefetchTask,\n  fetchStrategy:\n    | FetchStrategy.LoadingBoundary\n    | FetchStrategy.PPRRuntime\n    | FetchStrategy.Full,\n  response: RSCResponse<NavigationFlightResponse>,\n  serverData: NavigationFlightResponse,\n  entry: PendingRouteCacheEntry,\n  couldBeIntercepted: boolean,\n  canonicalUrl: string,\n  routeIsPPREnabled: boolean\n) {\n  // Get the URL that was used to render the target page. This may be different\n  // from the URL in the request URL, if the page was rewritten.\n  const renderedSearch = getRenderedSearch(response)\n\n  const normalizedFlightDataResult = normalizeFlightData(serverData.f)\n  if (\n    // A string result means navigating to this route will result in an\n    // MPA navigation.\n    typeof normalizedFlightDataResult === 'string' ||\n    normalizedFlightDataResult.length !== 1\n  ) {\n    rejectRouteCacheEntry(entry, now + 10 * 1000)\n    return\n  }\n  const flightData = normalizedFlightDataResult[0]\n  if (!flightData.isRootRender) {\n    // Unexpected response format.\n    rejectRouteCacheEntry(entry, now + 10 * 1000)\n    return\n  }\n\n  const flightRouterState = flightData.tree\n  // For runtime prefetches, stale time is in the payload at rp[1].\n  // For other responses, fall back to the header.\n  const staleTimeSeconds =\n    typeof serverData.rp?.[1] === 'number'\n      ? serverData.rp[1]\n      : parseInt(response.headers.get(NEXT_ROUTER_STALE_TIME_HEADER) ?? '', 10)\n  const staleTimeMs = !isNaN(staleTimeSeconds)\n    ? getStaleTimeMs(staleTimeSeconds)\n    : STATIC_STALETIME_MS\n\n  // If the response contains dynamic holes, then we must conservatively assume\n  // that any individual segment might contain dynamic holes, and also the\n  // head. If it did not contain dynamic holes, then we can assume every segment\n  // and the head is completely static.\n  const isResponsePartial =\n    response.headers.get(NEXT_DID_POSTPONE_HEADER) === '1'\n\n  // Convert the server-sent data into the RouteTree format used by the\n  // client cache.\n  //\n  // During this traversal, we accumulate additional data into this\n  // \"accumulator\" object.\n  const acc: RouteTreeAccumulator = { metadataVaryPath: null }\n  const routeTree = convertRootFlightRouterStateToRouteTree(\n    flightRouterState,\n    renderedSearch,\n    acc\n  )\n  const metadataVaryPath = acc.metadataVaryPath\n  if (metadataVaryPath === null) {\n    rejectRouteCacheEntry(entry, now + 10 * 1000)\n    return\n  }\n\n  const fulfilledEntry = fulfillRouteCacheEntry(\n    entry,\n    routeTree,\n    metadataVaryPath,\n    now + staleTimeMs,\n    couldBeIntercepted,\n    canonicalUrl,\n    renderedSearch,\n    routeIsPPREnabled\n  )\n\n  // If the server sent segment data as part of the response, we should write\n  // it into the cache to prevent a second, redundant prefetch request.\n  //\n  // TODO: When `clientSegmentCache` is enabled, the server does not include\n  // segment data when responding to a route tree prefetch request. However,\n  // when `clientSegmentCache` is set to \"client-only\", and PPR is enabled (or\n  // the page is fully static), the normal check is bypassed and the server\n  // responds with the full page. This is a temporary situation until we can\n  // remove the \"client-only\" option. Then, we can delete this function call.\n  writeDynamicRenderResponseIntoCache(\n    now,\n    task,\n    fetchStrategy,\n    response,\n    serverData,\n    isResponsePartial,\n    fulfilledEntry,\n    null\n  )\n}\n\nfunction rejectSegmentEntriesIfStillPending(\n  entries: Map<SegmentRequestKey, SegmentCacheEntry>,\n  staleAt: number\n): Array<FulfilledSegmentCacheEntry> {\n  const fulfilledEntries = []\n  for (const entry of entries.values()) {\n    if (entry.status === EntryStatus.Pending) {\n      rejectSegmentCacheEntry(entry, staleAt)\n    } else if (entry.status === EntryStatus.Fulfilled) {\n      fulfilledEntries.push(entry)\n    }\n  }\n  return fulfilledEntries\n}\n\nfunction writeDynamicRenderResponseIntoCache(\n  now: number,\n  task: PrefetchTask,\n  fetchStrategy:\n    | FetchStrategy.LoadingBoundary\n    | FetchStrategy.PPRRuntime\n    | FetchStrategy.Full,\n  response: RSCResponse<NavigationFlightResponse>,\n  serverData: NavigationFlightResponse,\n  isResponsePartial: boolean,\n  route: FulfilledRouteCacheEntry,\n  spawnedEntries: Map<SegmentRequestKey, PendingSegmentCacheEntry> | null\n): Array<FulfilledSegmentCacheEntry> | null {\n  if (serverData.b !== getAppBuildId()) {\n    // The server build does not match the client. Treat as a 404. During\n    // an actual navigation, the router will trigger an MPA navigation.\n    // TODO: Consider moving the build ID to a response header so we can check\n    // it before decoding the response, and so there's one way of checking\n    // across all response types.\n    if (spawnedEntries !== null) {\n      rejectSegmentEntriesIfStillPending(spawnedEntries, now + 10 * 1000)\n    }\n    return null\n  }\n\n  const flightDatas = normalizeFlightData(serverData.f)\n  if (typeof flightDatas === 'string') {\n    // This means navigating to this route will result in an MPA navigation.\n    // TODO: We should cache this, too, so that the MPA navigation is immediate.\n    return null\n  }\n\n  // For runtime prefetches, stale time is in the payload at rp[1].\n  // For other responses, fall back to the header.\n  const staleTimeSeconds =\n    typeof serverData.rp?.[1] === 'number'\n      ? serverData.rp[1]\n      : parseInt(response.headers.get(NEXT_ROUTER_STALE_TIME_HEADER) ?? '', 10)\n  const staleTimeMs = !isNaN(staleTimeSeconds)\n    ? getStaleTimeMs(staleTimeSeconds)\n    : STATIC_STALETIME_MS\n  const staleAt = now + staleTimeMs\n\n  for (const flightData of flightDatas) {\n    const seedData = flightData.seedData\n    if (seedData !== null) {\n      // The data sent by the server represents only a subtree of the app. We\n      // need to find the part of the task tree that matches the response.\n      //\n      // segmentPath represents the parent path of subtree. It's a repeating\n      // pattern of parallel route key and segment:\n      //\n      //   [string, Segment, string, Segment, string, Segment, ...]\n      const segmentPath = flightData.segmentPath\n      let tree = route.tree\n      for (let i = 0; i < segmentPath.length; i += 2) {\n        const parallelRouteKey: string = segmentPath[i]\n        if (tree?.slots?.[parallelRouteKey] !== undefined) {\n          tree = tree.slots[parallelRouteKey]\n        } else {\n          if (spawnedEntries !== null) {\n            rejectSegmentEntriesIfStillPending(spawnedEntries, now + 10 * 1000)\n          }\n          return null\n        }\n      }\n\n      writeSeedDataIntoCache(\n        now,\n        task,\n        fetchStrategy,\n        route,\n        tree,\n        staleAt,\n        seedData,\n        isResponsePartial,\n        spawnedEntries\n      )\n    }\n\n    const head = flightData.head\n    if (head !== null) {\n      fulfillEntrySpawnedByRuntimePrefetch(\n        now,\n        fetchStrategy,\n        route,\n        head,\n        null,\n        flightData.isHeadPartial,\n        staleAt,\n        route.metadata,\n        spawnedEntries\n      )\n    }\n  }\n  // Any entry that's still pending was intentionally not rendered by the\n  // server, because it was inside the loading boundary. Mark them as rejected\n  // so we know not to fetch them again.\n  // TODO: If PPR is enabled on some routes but not others, then it's possible\n  // that a different page is able to do a per-segment prefetch of one of the\n  // segments we're marking as rejected here. We should mark on the segment\n  // somehow that the reason for the rejection is because of a non-PPR prefetch.\n  // That way a per-segment prefetch knows to disregard the rejection.\n  if (spawnedEntries !== null) {\n    const fulfilledEntries = rejectSegmentEntriesIfStillPending(\n      spawnedEntries,\n      now + 10 * 1000\n    )\n    return fulfilledEntries\n  }\n  return null\n}\n\nfunction writeSeedDataIntoCache(\n  now: number,\n  task: PrefetchTask,\n  fetchStrategy:\n    | FetchStrategy.LoadingBoundary\n    | FetchStrategy.PPRRuntime\n    | FetchStrategy.Full,\n  route: FulfilledRouteCacheEntry,\n  tree: RouteTree,\n  staleAt: number,\n  seedData: CacheNodeSeedData,\n  isResponsePartial: boolean,\n  entriesOwnedByCurrentTask: Map<\n    SegmentRequestKey,\n    PendingSegmentCacheEntry\n  > | null\n) {\n  // This function is used to write the result of a runtime server request\n  // (CacheNodeSeedData) into the prefetch cache.\n  const rsc = seedData[0]\n  const loading = seedData[2]\n  const isPartial = rsc === null || isResponsePartial\n  fulfillEntrySpawnedByRuntimePrefetch(\n    now,\n    fetchStrategy,\n    route,\n    rsc,\n    loading,\n    isPartial,\n    staleAt,\n    tree,\n    entriesOwnedByCurrentTask\n  )\n\n  // Recursively write the child data into the cache.\n  const slots = tree.slots\n  if (slots !== null) {\n    const seedDataChildren = seedData[1]\n    for (const parallelRouteKey in slots) {\n      const childTree = slots[parallelRouteKey]\n      const childSeedData: CacheNodeSeedData | null | void =\n        seedDataChildren[parallelRouteKey]\n      if (childSeedData !== null && childSeedData !== undefined) {\n        writeSeedDataIntoCache(\n          now,\n          task,\n          fetchStrategy,\n          route,\n          childTree,\n          staleAt,\n          childSeedData,\n          isResponsePartial,\n          entriesOwnedByCurrentTask\n        )\n      }\n    }\n  }\n}\n\nfunction fulfillEntrySpawnedByRuntimePrefetch(\n  now: number,\n  fetchStrategy:\n    | FetchStrategy.LoadingBoundary\n    | FetchStrategy.PPRRuntime\n    | FetchStrategy.Full,\n  route: FulfilledRouteCacheEntry,\n  rsc: React.ReactNode,\n  loading: LoadingModuleData | Promise<LoadingModuleData>,\n  isPartial: boolean,\n  staleAt: number,\n  tree: RouteTree,\n  entriesOwnedByCurrentTask: Map<\n    SegmentRequestKey,\n    PendingSegmentCacheEntry\n  > | null\n) {\n  // We should only write into cache entries that are owned by us. Or create\n  // a new one and write into that. We must never write over an entry that was\n  // created by a different task, because that causes data races.\n  const ownedEntry =\n    entriesOwnedByCurrentTask !== null\n      ? entriesOwnedByCurrentTask.get(tree.requestKey)\n      : undefined\n  if (ownedEntry !== undefined) {\n    fulfillSegmentCacheEntry(ownedEntry, rsc, loading, staleAt, isPartial)\n  } else {\n    // There's no matching entry. Attempt to create a new one.\n    const possiblyNewEntry = readOrCreateSegmentCacheEntry(\n      now,\n      fetchStrategy,\n      route,\n      tree\n    )\n    if (possiblyNewEntry.status === EntryStatus.Empty) {\n      // Confirmed this is a new entry. We can fulfill it.\n      const newEntry = possiblyNewEntry\n      fulfillSegmentCacheEntry(\n        upgradeToPendingSegment(newEntry, fetchStrategy),\n        rsc,\n        loading,\n        staleAt,\n        isPartial\n      )\n    } else {\n      // There was already an entry in the cache. But we may be able to\n      // replace it with the new one from the server.\n      const newEntry = fulfillSegmentCacheEntry(\n        upgradeToPendingSegment(\n          createDetachedSegmentCacheEntry(staleAt),\n          fetchStrategy\n        ),\n        rsc,\n        loading,\n        staleAt,\n        isPartial\n      )\n      upsertSegmentEntry(\n        now,\n        getSegmentVaryPathForRequest(fetchStrategy, tree),\n        newEntry\n      )\n    }\n  }\n}\n\nasync function fetchPrefetchResponse<T>(\n  url: URL,\n  headers: RequestHeaders\n): Promise<RSCResponse<T> | null> {\n  const fetchPriority = 'low'\n  // When issuing a prefetch request, don't immediately decode the response; we\n  // use the lower level `createFromResponse` API instead because we need to do\n  // some extra processing of the response stream. See\n  // `createPrefetchResponseStream` for more details.\n  const shouldImmediatelyDecode = false\n  const response = await createFetch<T>(\n    url,\n    headers,\n    fetchPriority,\n    shouldImmediatelyDecode\n  )\n  if (!response.ok) {\n    return null\n  }\n\n  // Check the content type\n  if (isOutputExportMode) {\n    // In output: \"export\" mode, we relaxed about the content type, since it's\n    // not Next.js that's serving the response. If the status is OK, assume the\n    // response is valid. If it's not a valid response, the Flight client won't\n    // be able to decode it, and we'll treat it as a miss.\n  } else {\n    const contentType = response.headers.get('content-type')\n    const isFlightResponse =\n      contentType && contentType.startsWith(RSC_CONTENT_TYPE_HEADER)\n    if (!isFlightResponse) {\n      return null\n    }\n  }\n  return response\n}\n\nfunction createPrefetchResponseStream(\n  originalFlightStream: ReadableStream<Uint8Array>,\n  onStreamClose: () => void,\n  onResponseSizeUpdate: (size: number) => void\n): ReadableStream<Uint8Array> {\n  // When PPR is enabled, prefetch streams may contain references that never\n  // resolve, because that's how we encode dynamic data access. In the decoded\n  // object returned by the Flight client, these are reified into hanging\n  // promises that suspend during render, which is effectively what we want.\n  // The UI resolves when it switches to the dynamic data stream\n  // (via useDeferredValue(dynamic, static)).\n  //\n  // However, the Flight implementation currently errors if the server closes\n  // the response before all the references are resolved. As a cheat to work\n  // around this, we wrap the original stream in a new stream that never closes,\n  // and therefore doesn't error.\n  //\n  // While processing the original stream, we also incrementally update the size\n  // of the cache entry in the LRU.\n  let totalByteLength = 0\n  const reader = originalFlightStream.getReader()\n  return new ReadableStream({\n    async pull(controller) {\n      while (true) {\n        const { done, value } = await reader.read()\n        if (!done) {\n          // Pass to the target stream and keep consuming the Flight response\n          // from the server.\n          controller.enqueue(value)\n\n          // Incrementally update the size of the cache entry in the LRU.\n          // NOTE: Since prefetch responses are delivered in a single chunk,\n          // it's not really necessary to do this streamingly, but I'm doing it\n          // anyway in case this changes in the future.\n          totalByteLength += value.byteLength\n          onResponseSizeUpdate(totalByteLength)\n          continue\n        }\n        // The server stream has closed. Exit, but intentionally do not close\n        // the target stream. We do notify the caller, though.\n        onStreamClose()\n        return\n      }\n    },\n  })\n}\n\nfunction addSegmentPathToUrlInOutputExportMode(\n  url: URL,\n  segmentPath: SegmentRequestKey\n): URL {\n  if (isOutputExportMode) {\n    // In output: \"export\" mode, we cannot use a header to encode the segment\n    // path. Instead, we append it to the end of the pathname.\n    const staticUrl = new URL(url)\n    const routeDir = staticUrl.pathname.endsWith('/')\n      ? staticUrl.pathname.slice(0, -1)\n      : staticUrl.pathname\n    const staticExportFilename =\n      convertSegmentPathToStaticExportFilename(segmentPath)\n    staticUrl.pathname = `${routeDir}/${staticExportFilename}`\n    return staticUrl\n  }\n  return url\n}\n\n/**\n * Checks whether the new fetch strategy is likely to provide more content than the old one.\n *\n * Generally, when an app uses dynamic data, a \"more specific\" fetch strategy is expected to provide more content:\n * - `LoadingBoundary` only provides static layouts\n * - `PPR` can provide shells for each segment (even for segments that use dynamic data)\n * - `PPRRuntime` can additionally include content that uses searchParams, params, or cookies\n * - `Full` includes all the content, even if it uses dynamic data\n *\n * However, it's possible that a more specific fetch strategy *won't* give us more content if:\n * - a segment is fully static\n *   (then, `PPR`/`PPRRuntime`/`Full` will all yield equivalent results)\n * - providing searchParams/params/cookies doesn't reveal any more content, e.g. because of an `await connection()`\n *   (then, `PPR` and `PPRRuntime` will yield equivalent results, only `Full` will give us more)\n * Because of this, when comparing two segments, we should also check if the existing segment is partial.\n * If it's not partial, then there's no need to prefetch it again, even using a \"more specific\" strategy.\n * There's currently no way to know if `PPRRuntime` will yield more data that `PPR`, so we have to assume it will.\n *\n * Also note that, in practice, we don't expect to be comparing `LoadingBoundary` to `PPR`/`PPRRuntime`,\n * because a non-PPR-enabled route wouldn't ever use the latter strategies. It might however use `Full`.\n */\nexport function canNewFetchStrategyProvideMoreContent(\n  currentStrategy: FetchStrategy,\n  newStrategy: FetchStrategy\n): boolean {\n  return currentStrategy < newStrategy\n}\n","import type {\n  FlightRouterState,\n  Segment as FlightRouterStateSegment,\n  Segment,\n} from '../../../shared/lib/app-router-types'\nimport { HasLoadingBoundary } from '../../../shared/lib/app-router-types'\nimport { matchSegment } from '../match-segments'\nimport {\n  readOrCreateRouteCacheEntry,\n  readOrCreateSegmentCacheEntry,\n  fetchRouteOnCacheMiss,\n  fetchSegmentOnCacheMiss,\n  EntryStatus,\n  type FulfilledRouteCacheEntry,\n  type RouteCacheEntry,\n  type SegmentCacheEntry,\n  type RouteTree,\n  fetchSegmentPrefetchesUsingDynamicRequest,\n  type PendingSegmentCacheEntry,\n  convertRouteTreeToFlightRouterState,\n  readOrCreateRevalidatingSegmentEntry,\n  upsertSegmentEntry,\n  type FulfilledSegmentCacheEntry,\n  upgradeToPendingSegment,\n  waitForSegmentCacheEntry,\n  overwriteRevalidatingSegmentCacheEntry,\n  canNewFetchStrategyProvideMoreContent,\n} from './cache'\nimport { getSegmentVaryPathForRequest, type SegmentVaryPath } from './vary-path'\nimport type { RouteCacheKey } from './cache-key'\nimport { createCacheKey } from './cache-key'\nimport {\n  FetchStrategy,\n  type PrefetchTaskFetchStrategy,\n  PrefetchPriority,\n} from './types'\nimport { getCurrentCacheVersion } from './cache'\nimport {\n  addSearchParamsIfPageSegment,\n  PAGE_SEGMENT_KEY,\n} from '../../../shared/lib/segment'\nimport type { SegmentRequestKey } from '../../../shared/lib/segment-cache/segment-value-encoding'\n\nconst scheduleMicrotask =\n  typeof queueMicrotask === 'function'\n    ? queueMicrotask\n    : (fn: () => unknown) =>\n        Promise.resolve()\n          .then(fn)\n          .catch((error) =>\n            setTimeout(() => {\n              throw error\n            })\n          )\n\nexport type PrefetchTask = {\n  key: RouteCacheKey\n\n  /**\n   * The FlightRouterState at the time the task was initiated. This is needed\n   * when falling back to the non-PPR behavior, which only prefetches up to\n   * the first loading boundary.\n   */\n  treeAtTimeOfPrefetch: FlightRouterState\n\n  /**\n   * The cache version at the time the task was initiated. This is used to\n   * determine if the cache was invalidated since the task was initiated.\n   */\n  cacheVersion: number\n\n  /**\n   * Whether to prefetch dynamic data, in addition to static data. This is\n   * used by `<Link prefetch={true}>`.\n   *\n   * Note that a task with `FetchStrategy.PPR` might need to use\n   * `FetchStrategy.LoadingBoundary` instead if we find out that a route\n   * does not support PPR after doing the initial route prefetch.\n   */\n  fetchStrategy: PrefetchTaskFetchStrategy\n\n  /**\n   * sortId is an incrementing counter\n   *\n   * Newer prefetches are prioritized over older ones, so that as new links\n   * enter the viewport, they are not starved by older links that are no\n   * longer relevant. In the future, we can add additional prioritization\n   * heuristics, like removing prefetches once a link leaves the viewport.\n   *\n   * The sortId is assigned when the prefetch is initiated, and reassigned if\n   * the same task is prefetched again (effectively bumping it to the top of\n   * the queue).\n   *\n   * TODO: We can add additional fields here to indicate what kind of prefetch\n   * it is. For example, was it initiated by a link? Or was it an imperative\n   * call? If it was initiated by a link, we can remove it from the queue when\n   * the link leaves the viewport, but if it was an imperative call, then we\n   * should keep it in the queue until it's fulfilled.\n   *\n   * We can also add priority levels. For example, hovering over a link could\n   * increase the priority of its prefetch.\n   */\n  sortId: number\n\n  /**\n   * The priority of the task. Like sortId, this affects the task's position in\n   * the queue, so it must never be updated without resifting the heap.\n   */\n  priority: PrefetchPriority\n\n  /**\n   * The phase of the task. Tasks are split into multiple phases so that their\n   * priority can be adjusted based on what kind of work they're doing.\n   * Concretely, prefetching the route tree is higher priority than prefetching\n   * segment data.\n   */\n  phase: PrefetchPhase\n\n  /**\n   * These fields are temporary state for tracking the currently running task.\n   * They are reset after each iteration of the task queue.\n   */\n  hasBackgroundWork: boolean\n  spawnedRuntimePrefetches: Set<SegmentRequestKey> | null\n\n  /**\n   * True if the prefetch was cancelled.\n   */\n  isCanceled: boolean\n\n  /**\n   * The callback passed to `router.prefetch`, if given.\n   */\n  onInvalidate: null | (() => void)\n\n  /**\n   * The index of the task in the heap's backing array. Used to efficiently\n   * change the priority of a task by re-sifting it, which requires knowing\n   * where it is in the array. This is only used internally by the heap\n   * algorithm. The naive alternative is indexOf every time a task is queued,\n   * which has O(n) complexity.\n   *\n   * We also use this field to check whether a task is currently in the queue.\n   */\n  _heapIndex: number\n}\n\nconst enum PrefetchTaskExitStatus {\n  /**\n   * The task yielded because there are too many requests in progress.\n   */\n  InProgress,\n\n  /**\n   * The task is blocked. It needs more data before it can proceed.\n   *\n   * Currently the only reason this happens is we're still waiting to receive a\n   * route tree from the server, because we can't start prefetching the segments\n   * until we know what to prefetch.\n   */\n  Blocked,\n\n  /**\n   * There's nothing left to prefetch.\n   */\n  Done,\n}\n\n/**\n * Prefetch tasks are processed in two phases: first the route tree is fetched,\n * then the segments. We use this to priortize tasks that have not yet fetched\n * the route tree.\n */\nconst enum PrefetchPhase {\n  RouteTree = 1,\n  Segments = 0,\n}\n\nexport type PrefetchSubtaskResult<T> = {\n  /**\n   * A promise that resolves when the network connection is closed.\n   */\n  closed: Promise<void>\n  value: T\n}\n\nconst taskHeap: Array<PrefetchTask> = []\n\nlet inProgressRequests = 0\n\nlet sortIdCounter = 0\nlet didScheduleMicrotask = false\n\n// The most recently hovered (or touched, etc) link, i.e. the most recent task\n// scheduled at Intent priority. There's only ever a single task at Intent\n// priority at a time. We reserve special network bandwidth for this task only.\nlet mostRecentlyHoveredLink: PrefetchTask | null = null\n\n// CDN cache propagation delay after revalidation (in milliseconds)\nconst REVALIDATION_COOLDOWN_MS = 300\n\n// Timeout handle for the revalidation cooldown. When non-null, prefetch\n// requests are blocked to allow CDN cache propagation.\nlet revalidationCooldownTimeoutHandle: ReturnType<typeof setTimeout> | null =\n  null\n\n/**\n * Called by the cache when revalidation occurs. Starts a cooldown period\n * during which prefetch requests are blocked to allow CDN cache propagation.\n */\nexport function startRevalidationCooldown(): void {\n  // Clear any existing timeout in case multiple revalidations happen\n  // in quick succession.\n  if (revalidationCooldownTimeoutHandle !== null) {\n    clearTimeout(revalidationCooldownTimeoutHandle)\n  }\n\n  // Schedule the cooldown to expire after the delay.\n  revalidationCooldownTimeoutHandle = setTimeout(() => {\n    revalidationCooldownTimeoutHandle = null\n    // Retry the prefetch queue now that the cooldown has expired.\n    ensureWorkIsScheduled()\n  }, REVALIDATION_COOLDOWN_MS)\n}\n\nexport type IncludeDynamicData = null | 'full' | 'dynamic'\n\n/**\n * Initiates a prefetch task for the given URL. If a prefetch for the same URL\n * is already in progress, this will bump it to the top of the queue.\n *\n * This is not a user-facing function. By the time this is called, the href is\n * expected to be validated and normalized.\n *\n * @param key The RouteCacheKey to prefetch.\n * @param treeAtTimeOfPrefetch The app's current FlightRouterState\n * @param fetchStrategy Whether to prefetch dynamic data, in addition to\n * static data. This is used by `<Link prefetch={true}>`.\n */\nexport function schedulePrefetchTask(\n  key: RouteCacheKey,\n  treeAtTimeOfPrefetch: FlightRouterState,\n  fetchStrategy: PrefetchTaskFetchStrategy,\n  priority: PrefetchPriority,\n  onInvalidate: null | (() => void)\n): PrefetchTask {\n  // Spawn a new prefetch task\n  const task: PrefetchTask = {\n    key,\n    treeAtTimeOfPrefetch,\n    cacheVersion: getCurrentCacheVersion(),\n    priority,\n    phase: PrefetchPhase.RouteTree,\n    hasBackgroundWork: false,\n    spawnedRuntimePrefetches: null,\n    fetchStrategy,\n    sortId: sortIdCounter++,\n    isCanceled: false,\n    onInvalidate,\n    _heapIndex: -1,\n  }\n\n  trackMostRecentlyHoveredLink(task)\n\n  heapPush(taskHeap, task)\n\n  // Schedule an async task to process the queue.\n  //\n  // The main reason we process the queue in an async task is for batching.\n  // It's common for a single JS task/event to trigger multiple prefetches.\n  // By deferring to a microtask, we only process the queue once per JS task.\n  // If they have different priorities, it also ensures they are processed in\n  // the optimal order.\n  ensureWorkIsScheduled()\n\n  return task\n}\n\nexport function cancelPrefetchTask(task: PrefetchTask): void {\n  // Remove the prefetch task from the queue. If the task already completed,\n  // then this is a no-op.\n  //\n  // We must also explicitly mark the task as canceled so that a blocked task\n  // does not get added back to the queue when it's pinged by the network.\n  task.isCanceled = true\n  heapDelete(taskHeap, task)\n}\n\nexport function reschedulePrefetchTask(\n  task: PrefetchTask,\n  treeAtTimeOfPrefetch: FlightRouterState,\n  fetchStrategy: PrefetchTaskFetchStrategy,\n  priority: PrefetchPriority\n): void {\n  // Bump the prefetch task to the top of the queue, as if it were a fresh\n  // task. This is essentially the same as canceling the task and scheduling\n  // a new one, except it reuses the original object.\n  //\n  // The primary use case is to increase the priority of a Link-initated\n  // prefetch on hover.\n\n  // Un-cancel the task, in case it was previously canceled.\n  task.isCanceled = false\n  task.phase = PrefetchPhase.RouteTree\n\n  // Assign a new sort ID to move it ahead of all other tasks at the same\n  // priority level. (Higher sort IDs are processed first.)\n  task.sortId = sortIdCounter++\n  task.priority =\n    // If this task is the most recently hovered link, maintain its\n    // Intent priority, even if the rescheduled priority is lower.\n    task === mostRecentlyHoveredLink ? PrefetchPriority.Intent : priority\n\n  task.treeAtTimeOfPrefetch = treeAtTimeOfPrefetch\n  task.fetchStrategy = fetchStrategy\n\n  trackMostRecentlyHoveredLink(task)\n\n  if (task._heapIndex !== -1) {\n    // The task is already in the queue.\n    heapResift(taskHeap, task)\n  } else {\n    heapPush(taskHeap, task)\n  }\n  ensureWorkIsScheduled()\n}\n\nexport function isPrefetchTaskDirty(\n  task: PrefetchTask,\n  nextUrl: string | null,\n  tree: FlightRouterState\n): boolean {\n  // This is used to quickly bail out of a prefetch task if the result is\n  // guaranteed to not have changed since the task was initiated. This is\n  // strictly an optimization — theoretically, if it always returned true, no\n  // behavior should change because a full prefetch task will effectively\n  // perform the same checks.\n  const currentCacheVersion = getCurrentCacheVersion()\n  return (\n    task.cacheVersion !== currentCacheVersion ||\n    task.treeAtTimeOfPrefetch !== tree ||\n    task.key.nextUrl !== nextUrl\n  )\n}\n\nfunction trackMostRecentlyHoveredLink(task: PrefetchTask) {\n  // Track the mostly recently hovered link, i.e. the most recently scheduled\n  // task at Intent priority. There must only be one such task at a time.\n  if (\n    task.priority === PrefetchPriority.Intent &&\n    task !== mostRecentlyHoveredLink\n  ) {\n    if (mostRecentlyHoveredLink !== null) {\n      // Bump the previously hovered link's priority down to Default.\n      if (mostRecentlyHoveredLink.priority !== PrefetchPriority.Background) {\n        mostRecentlyHoveredLink.priority = PrefetchPriority.Default\n        heapResift(taskHeap, mostRecentlyHoveredLink)\n      }\n    }\n    mostRecentlyHoveredLink = task\n  }\n}\n\nfunction ensureWorkIsScheduled() {\n  if (didScheduleMicrotask) {\n    // Already scheduled a task to process the queue\n    return\n  }\n  didScheduleMicrotask = true\n  scheduleMicrotask(processQueueInMicrotask)\n}\n\n/**\n * Checks if we've exceeded the maximum number of concurrent prefetch requests,\n * to avoid saturating the browser's internal network queue. This is a\n * cooperative limit — prefetch tasks should check this before issuing\n * new requests.\n *\n * Also checks if we're within the revalidation cooldown window, during which\n * prefetch requests are delayed to allow CDN cache propagation.\n */\nfunction hasNetworkBandwidth(task: PrefetchTask): boolean {\n  // Check if we're within the revalidation cooldown window\n  if (revalidationCooldownTimeoutHandle !== null) {\n    // We're within the cooldown window. Return false to prevent prefetching.\n    // When the cooldown expires, the timeout will call ensureWorkIsScheduled()\n    // to retry the queue.\n    return false\n  }\n\n  // TODO: Also check if there's an in-progress navigation. We should never\n  // add prefetch requests to the network queue if an actual navigation is\n  // taking place, to ensure there's sufficient bandwidth for render-blocking\n  // data and resources.\n\n  // TODO: Consider reserving some amount of bandwidth for static prefetches.\n\n  if (task.priority === PrefetchPriority.Intent) {\n    // The most recently hovered link is allowed to exceed the default limit.\n    //\n    // The goal is to always have enough bandwidth to start a new prefetch\n    // request when hovering over a link.\n    //\n    // However, because we don't abort in-progress requests, it's still possible\n    // we'll run out of bandwidth. When links are hovered in quick succession,\n    // there could be multiple hover requests running simultaneously.\n    return inProgressRequests < 12\n  }\n\n  // The default limit is lower than the limit for a hovered link.\n  return inProgressRequests < 4\n}\n\nfunction spawnPrefetchSubtask<T>(\n  prefetchSubtask: Promise<PrefetchSubtaskResult<T> | null>\n): Promise<T | null> {\n  // When the scheduler spawns an async task, we don't await its result.\n  // Instead, the async task writes its result directly into the cache, then\n  // pings the scheduler to continue.\n  //\n  // We process server responses streamingly, so the prefetch subtask will\n  // likely resolve before we're finished receiving all the data. The subtask\n  // result includes a promise that resolves once the network connection is\n  // closed. The scheduler uses this to control network bandwidth by tracking\n  // and limiting the number of concurrent requests.\n  inProgressRequests++\n  return prefetchSubtask.then((result) => {\n    if (result === null) {\n      // The prefetch task errored before it could start processing the\n      // network stream. Assume the connection is closed.\n      onPrefetchConnectionClosed()\n      return null\n    }\n    // Wait for the connection to close before freeing up more bandwidth.\n    result.closed.then(onPrefetchConnectionClosed)\n    return result.value\n  })\n}\n\nfunction onPrefetchConnectionClosed(): void {\n  inProgressRequests--\n\n  // Notify the scheduler that we have more bandwidth, and can continue\n  // processing tasks.\n  ensureWorkIsScheduled()\n}\n\n/**\n * Notify the scheduler that we've received new data for an in-progress\n * prefetch. The corresponding task will be added back to the queue (unless the\n * task has been canceled in the meantime).\n */\nexport function pingPrefetchTask(task: PrefetchTask) {\n  // \"Ping\" a prefetch that's already in progress to notify it of new data.\n  if (\n    // Check if prefetch was canceled.\n    task.isCanceled ||\n    // Check if prefetch is already queued.\n    task._heapIndex !== -1\n  ) {\n    return\n  }\n  // Add the task back to the queue.\n  heapPush(taskHeap, task)\n  ensureWorkIsScheduled()\n}\n\nfunction processQueueInMicrotask() {\n  didScheduleMicrotask = false\n\n  // We aim to minimize how often we read the current time. Since nearly all\n  // functions in the prefetch scheduler are synchronous, we can read the time\n  // once and pass it as an argument wherever it's needed.\n  const now = Date.now()\n\n  // Process the task queue until we run out of network bandwidth.\n  let task = heapPeek(taskHeap)\n  while (task !== null && hasNetworkBandwidth(task)) {\n    task.cacheVersion = getCurrentCacheVersion()\n\n    const exitStatus = pingRoute(now, task)\n\n    // These fields are only valid for a single attempt. Reset them after each\n    // iteration of the task queue.\n    const hasBackgroundWork = task.hasBackgroundWork\n    task.hasBackgroundWork = false\n    task.spawnedRuntimePrefetches = null\n\n    switch (exitStatus) {\n      case PrefetchTaskExitStatus.InProgress:\n        // The task yielded because there are too many requests in progress.\n        // Stop processing tasks until we have more bandwidth.\n        return\n      case PrefetchTaskExitStatus.Blocked:\n        // The task is blocked. It needs more data before it can proceed.\n        // Keep the task out of the queue until the server responds.\n        heapPop(taskHeap)\n        // Continue to the next task\n        task = heapPeek(taskHeap)\n        continue\n      case PrefetchTaskExitStatus.Done:\n        if (task.phase === PrefetchPhase.RouteTree) {\n          // Finished prefetching the route tree. Proceed to prefetching\n          // the segments.\n          task.phase = PrefetchPhase.Segments\n          heapResift(taskHeap, task)\n        } else if (hasBackgroundWork) {\n          // The task spawned additional background work. Reschedule the task\n          // at background priority.\n          task.priority = PrefetchPriority.Background\n          heapResift(taskHeap, task)\n        } else {\n          // The prefetch is complete. Continue to the next task.\n          heapPop(taskHeap)\n        }\n        task = heapPeek(taskHeap)\n        continue\n      default:\n        exitStatus satisfies never\n    }\n  }\n}\n\n/**\n * Check this during a prefetch task to determine if background work can be\n * performed. If so, it evaluates to `true`. Otherwise, it returns `false`,\n * while also scheduling a background task to run later. Usage:\n *\n * @example\n * if (background(task)) {\n *   // Perform background-pri work\n * }\n */\nfunction background(task: PrefetchTask): boolean {\n  if (task.priority === PrefetchPriority.Background) {\n    return true\n  }\n  task.hasBackgroundWork = true\n  return false\n}\n\nfunction pingRoute(now: number, task: PrefetchTask): PrefetchTaskExitStatus {\n  const key = task.key\n  const route = readOrCreateRouteCacheEntry(now, task, key)\n  const exitStatus = pingRootRouteTree(now, task, route)\n\n  if (exitStatus !== PrefetchTaskExitStatus.InProgress && key.search !== '') {\n    // If the URL has a non-empty search string, also prefetch the pathname\n    // without the search string. We use the searchless route tree as a base for\n    // optimistic routing; see requestOptimisticRouteCacheEntry for details.\n    //\n    // Note that we don't need to prefetch any of the segment data. Just the\n    // route tree.\n    //\n    // TODO: This is a temporary solution; the plan is to replace this by adding\n    // a wildcard lookup method to the TupleMap implementation. This is\n    // non-trivial to implement because it needs to account for things like\n    // fallback route entries, hence this temporary workaround.\n    const url = new URL(key.pathname, location.origin)\n    const keyWithoutSearch = createCacheKey(url.href, key.nextUrl)\n    const routeWithoutSearch = readOrCreateRouteCacheEntry(\n      now,\n      task,\n      keyWithoutSearch\n    )\n    switch (routeWithoutSearch.status) {\n      case EntryStatus.Empty: {\n        if (background(task)) {\n          routeWithoutSearch.status = EntryStatus.Pending\n          spawnPrefetchSubtask(\n            fetchRouteOnCacheMiss(routeWithoutSearch, task, keyWithoutSearch)\n          )\n        }\n        break\n      }\n      case EntryStatus.Pending:\n      case EntryStatus.Fulfilled:\n      case EntryStatus.Rejected: {\n        // Either the route tree is already cached, or there's already a\n        // request in progress. Since we don't need to fetch any segment data\n        // for this route, there's nothing left to do.\n        break\n      }\n      default:\n        routeWithoutSearch satisfies never\n    }\n  }\n\n  return exitStatus\n}\n\nfunction pingRootRouteTree(\n  now: number,\n  task: PrefetchTask,\n  route: RouteCacheEntry\n): PrefetchTaskExitStatus {\n  switch (route.status) {\n    case EntryStatus.Empty: {\n      // Route is not yet cached, and there's no request already in progress.\n      // Spawn a task to request the route, load it into the cache, and ping\n      // the task to continue.\n\n      // TODO: There are multiple strategies in the <Link> API for prefetching\n      // a route. Currently we've only implemented the main one: per-segment,\n      // static-data only.\n      //\n      // There's also `<Link prefetch={true}>`\n      // which prefetch both static *and* dynamic data.\n      // Similarly, we need to fallback to the old, per-page\n      // behavior if PPR is disabled for a route (via the incremental opt-in).\n      //\n      // Those cases will be handled here.\n      spawnPrefetchSubtask(fetchRouteOnCacheMiss(route, task, task.key))\n\n      // If the request takes longer than a minute, a subsequent request should\n      // retry instead of waiting for this one. When the response is received,\n      // this value will be replaced by a new value based on the stale time sent\n      // from the server.\n      // TODO: We should probably also manually abort the fetch task, to reclaim\n      // server bandwidth.\n      route.staleAt = now + 60 * 1000\n\n      // Upgrade to Pending so we know there's already a request in progress\n      route.status = EntryStatus.Pending\n\n      // Intentional fallthrough to the Pending branch\n    }\n    case EntryStatus.Pending: {\n      // Still pending. We can't start prefetching the segments until the route\n      // tree has loaded. Add the task to the set of blocked tasks so that it\n      // is notified when the route tree is ready.\n      const blockedTasks = route.blockedTasks\n      if (blockedTasks === null) {\n        route.blockedTasks = new Set([task])\n      } else {\n        blockedTasks.add(task)\n      }\n      return PrefetchTaskExitStatus.Blocked\n    }\n    case EntryStatus.Rejected: {\n      // Route tree failed to load. Treat as a 404.\n      return PrefetchTaskExitStatus.Done\n    }\n    case EntryStatus.Fulfilled: {\n      if (task.phase !== PrefetchPhase.Segments) {\n        // Do not prefetch segment data until we've entered the segment phase.\n        return PrefetchTaskExitStatus.Done\n      }\n      // Recursively fill in the segment tree.\n      if (!hasNetworkBandwidth(task)) {\n        // Stop prefetching segments until there's more bandwidth.\n        return PrefetchTaskExitStatus.InProgress\n      }\n      const tree = route.tree\n\n      // A task's fetch strategy gets set to `PPR` for any \"auto\" prefetch.\n      // If it turned out that the route isn't PPR-enabled, we need to use `LoadingBoundary` instead.\n      // We don't need to do this for runtime prefetches, because those are only available in\n      // `cacheComponents`, where every route is PPR.\n      const fetchStrategy =\n        task.fetchStrategy === FetchStrategy.PPR\n          ? route.isPPREnabled\n            ? FetchStrategy.PPR\n            : FetchStrategy.LoadingBoundary\n          : task.fetchStrategy\n\n      switch (fetchStrategy) {\n        case FetchStrategy.PPR: {\n          // For Cache Components pages, each segment may be prefetched\n          // statically or using a runtime request, based on various\n          // configurations and heuristics. We'll do this in two passes: first\n          // traverse the tree and perform all the static prefetches.\n          //\n          // Then, if there are any segments that need a runtime request,\n          // do another pass to perform a runtime prefetch.\n          pingStaticHead(now, task, route)\n          const exitStatus = pingSharedPartOfCacheComponentsTree(\n            now,\n            task,\n            route,\n            task.treeAtTimeOfPrefetch,\n            tree\n          )\n          if (exitStatus === PrefetchTaskExitStatus.InProgress) {\n            // Child yielded without finishing.\n            return PrefetchTaskExitStatus.InProgress\n          }\n          const spawnedRuntimePrefetches = task.spawnedRuntimePrefetches\n          if (spawnedRuntimePrefetches !== null) {\n            // During the first pass, we discovered segments that require a\n            // runtime prefetch. Do a second pass to construct a request tree.\n            const spawnedEntries = new Map<\n              SegmentRequestKey,\n              PendingSegmentCacheEntry\n            >()\n            pingRuntimeHead(\n              now,\n              task,\n              route,\n              spawnedEntries,\n              FetchStrategy.PPRRuntime\n            )\n            const requestTree = pingRuntimePrefetches(\n              now,\n              task,\n              route,\n              tree,\n              spawnedRuntimePrefetches,\n              spawnedEntries\n            )\n            let needsDynamicRequest = spawnedEntries.size > 0\n            if (needsDynamicRequest) {\n              // Perform a dynamic prefetch request and populate the cache with\n              // the result.\n              spawnPrefetchSubtask(\n                fetchSegmentPrefetchesUsingDynamicRequest(\n                  task,\n                  route,\n                  FetchStrategy.PPRRuntime,\n                  requestTree,\n                  spawnedEntries\n                )\n              )\n            }\n          }\n          return PrefetchTaskExitStatus.Done\n        }\n        case FetchStrategy.Full:\n        case FetchStrategy.PPRRuntime:\n        case FetchStrategy.LoadingBoundary: {\n          // Prefetch multiple segments using a single dynamic request.\n          // TODO: We can consolidate this branch with previous one by modeling\n          // it as if the first segment in the new tree has runtime prefetching\n          // enabled. Will do this as a follow-up refactor. Might want to remove\n          // the special metatdata case below first. In the meantime, it's not\n          // really that much duplication, just would be nice to remove one of\n          // these codepaths.\n          const spawnedEntries = new Map<\n            SegmentRequestKey,\n            PendingSegmentCacheEntry\n          >()\n          pingRuntimeHead(now, task, route, spawnedEntries, fetchStrategy)\n          const dynamicRequestTree = diffRouteTreeAgainstCurrent(\n            now,\n            task,\n            route,\n            task.treeAtTimeOfPrefetch,\n            tree,\n            spawnedEntries,\n            fetchStrategy\n          )\n          let needsDynamicRequest = spawnedEntries.size > 0\n          if (needsDynamicRequest) {\n            spawnPrefetchSubtask(\n              fetchSegmentPrefetchesUsingDynamicRequest(\n                task,\n                route,\n                fetchStrategy,\n                dynamicRequestTree,\n                spawnedEntries\n              )\n            )\n          }\n          return PrefetchTaskExitStatus.Done\n        }\n        default:\n          fetchStrategy satisfies never\n      }\n      break\n    }\n    default: {\n      route satisfies never\n    }\n  }\n  return PrefetchTaskExitStatus.Done\n}\n\nfunction pingStaticHead(\n  now: number,\n  task: PrefetchTask,\n  route: FulfilledRouteCacheEntry\n): void {\n  // The Head data for a page (metadata, viewport) is not really a route\n  // segment, in the sense that it doesn't appear in the route tree. But we\n  // store it in the cache as if it were, using a special key.\n  pingStaticSegmentData(\n    now,\n    task,\n    route,\n    readOrCreateSegmentCacheEntry(\n      now,\n      FetchStrategy.PPR,\n      route,\n      route.metadata\n    ),\n    task.key,\n    route.metadata\n  )\n}\n\nfunction pingRuntimeHead(\n  now: number,\n  task: PrefetchTask,\n  route: FulfilledRouteCacheEntry,\n  spawnedEntries: Map<SegmentRequestKey, PendingSegmentCacheEntry>,\n  fetchStrategy:\n    | FetchStrategy.Full\n    | FetchStrategy.PPRRuntime\n    | FetchStrategy.LoadingBoundary\n): void {\n  pingRouteTreeAndIncludeDynamicData(\n    now,\n    task,\n    route,\n    route.metadata,\n    false,\n    spawnedEntries,\n    // When prefetching the head, there's no difference between Full\n    // and LoadingBoundary\n    fetchStrategy === FetchStrategy.LoadingBoundary\n      ? FetchStrategy.Full\n      : fetchStrategy\n  )\n}\n\n// TODO: Rename dynamic -> runtime throughout this module\n\nfunction pingSharedPartOfCacheComponentsTree(\n  now: number,\n  task: PrefetchTask,\n  route: FulfilledRouteCacheEntry,\n  oldTree: FlightRouterState,\n  newTree: RouteTree\n): PrefetchTaskExitStatus {\n  // When Cache Components is enabled (or PPR, or a fully static route when PPR\n  // is disabled; those cases are treated equivalently to Cache Components), we\n  // start by prefetching each segment individually. Once we reach the \"new\"\n  // part of the tree — the part that doesn't exist on the current page — we\n  // may choose to switch to a runtime prefetch instead, based on the\n  // information sent by the server in the route tree.\n  //\n  // The traversal starts in the \"shared\" part of the tree. Once we reach the\n  // \"new\" part of the tree, we switch to a different traversal,\n  // pingNewPartOfCacheComponentsTree.\n\n  // Prefetch this segment's static data.\n  const segment = readOrCreateSegmentCacheEntry(\n    now,\n    task.fetchStrategy,\n    route,\n    newTree\n  )\n  pingStaticSegmentData(now, task, route, segment, task.key, newTree)\n\n  // Recursively ping the children.\n  const oldTreeChildren = oldTree[1]\n  const newTreeChildren = newTree.slots\n  if (newTreeChildren !== null) {\n    for (const parallelRouteKey in newTreeChildren) {\n      if (!hasNetworkBandwidth(task)) {\n        // Stop prefetching segments until there's more bandwidth.\n        return PrefetchTaskExitStatus.InProgress\n      }\n      const newTreeChild = newTreeChildren[parallelRouteKey]\n      const newTreeChildSegment = newTreeChild.segment\n      const oldTreeChild: FlightRouterState | void =\n        oldTreeChildren[parallelRouteKey]\n      const oldTreeChildSegment: FlightRouterStateSegment | void =\n        oldTreeChild?.[0]\n      let childExitStatus\n      if (\n        oldTreeChildSegment !== undefined &&\n        doesCurrentSegmentMatchCachedSegment(\n          route,\n          newTreeChildSegment,\n          oldTreeChildSegment\n        )\n      ) {\n        // We're still in the \"shared\" part of the tree.\n        childExitStatus = pingSharedPartOfCacheComponentsTree(\n          now,\n          task,\n          route,\n          oldTreeChild,\n          newTreeChild\n        )\n      } else {\n        // We've entered the \"new\" part of the tree. Switch\n        // traversal functions.\n        childExitStatus = pingNewPartOfCacheComponentsTree(\n          now,\n          task,\n          route,\n          newTreeChild\n        )\n      }\n      if (childExitStatus === PrefetchTaskExitStatus.InProgress) {\n        // Child yielded without finishing.\n        return PrefetchTaskExitStatus.InProgress\n      }\n    }\n  }\n\n  return PrefetchTaskExitStatus.Done\n}\n\nfunction pingNewPartOfCacheComponentsTree(\n  now: number,\n  task: PrefetchTask,\n  route: FulfilledRouteCacheEntry,\n  tree: RouteTree\n): PrefetchTaskExitStatus.InProgress | PrefetchTaskExitStatus.Done {\n  // We're now prefetching in the \"new\" part of the tree, the part that doesn't\n  // exist on the current page. (In other words, we're deeper than the\n  // shared layouts.) Segments in here default to being prefetched statically.\n  // However, if the server instructs us to, we may switch to a runtime\n  // prefetch instead. Traverse the tree and check at each segment.\n  if (tree.hasRuntimePrefetch) {\n    // This route has a runtime prefetch response. Since we're below the shared\n    // layout, everything from this point should be prefetched using a single,\n    // combined runtime request, rather than using per-segment static requests.\n    // This is true even if some of the child segments are known to be fully\n    // static — once we've decided to perform a runtime prefetch, we might as\n    // well respond with the static segments in the same roundtrip. (That's how\n    // regular navigations work, too.) We'll still skip over segments that are\n    // already cached, though.\n    //\n    // It's the server's responsibility to set a reasonable value of\n    // `hasRuntimePrefetch`. Currently it's user-defined, but eventually, the\n    // server may send a value of `false` even if the user opts in, if it\n    // determines during build that the route is always fully static. There are\n    // more optimizations we can do once we implement fallback param\n    // tracking, too.\n    //\n    // Use the task object to collect the segments that need a runtime prefetch.\n    // This will signal to the outer task queue that a second traversal is\n    // required to construct a request tree.\n    if (task.spawnedRuntimePrefetches === null) {\n      task.spawnedRuntimePrefetches = new Set([tree.requestKey])\n    } else {\n      task.spawnedRuntimePrefetches.add(tree.requestKey)\n    }\n    // Then exit the traversal without prefetching anything further.\n    return PrefetchTaskExitStatus.Done\n  }\n\n  // This segment should not be runtime prefetched. Prefetch its static data.\n  const segment = readOrCreateSegmentCacheEntry(\n    now,\n    task.fetchStrategy,\n    route,\n    tree\n  )\n  pingStaticSegmentData(now, task, route, segment, task.key, tree)\n  if (tree.slots !== null) {\n    if (!hasNetworkBandwidth(task)) {\n      // Stop prefetching segments until there's more bandwidth.\n      return PrefetchTaskExitStatus.InProgress\n    }\n    // Recursively ping the children.\n    for (const parallelRouteKey in tree.slots) {\n      const childTree = tree.slots[parallelRouteKey]\n      const childExitStatus = pingNewPartOfCacheComponentsTree(\n        now,\n        task,\n        route,\n        childTree\n      )\n      if (childExitStatus === PrefetchTaskExitStatus.InProgress) {\n        // Child yielded without finishing.\n        return PrefetchTaskExitStatus.InProgress\n      }\n    }\n  }\n  // This segment and all its children have finished prefetching.\n  return PrefetchTaskExitStatus.Done\n}\n\nfunction diffRouteTreeAgainstCurrent(\n  now: number,\n  task: PrefetchTask,\n  route: FulfilledRouteCacheEntry,\n  oldTree: FlightRouterState,\n  newTree: RouteTree,\n  spawnedEntries: Map<SegmentRequestKey, PendingSegmentCacheEntry>,\n  fetchStrategy:\n    | FetchStrategy.Full\n    | FetchStrategy.PPRRuntime\n    | FetchStrategy.LoadingBoundary\n): FlightRouterState {\n  // This is a single recursive traversal that does multiple things:\n  // - Finds the parts of the target route (newTree) that are not part of\n  //   of the current page (oldTree) by diffing them, using the same algorithm\n  //   as a real navigation.\n  // - Constructs a request tree (FlightRouterState) that describes which\n  //   segments need to be prefetched and which ones are already cached.\n  // - Creates a set of pending cache entries for the segments that need to\n  //   be prefetched, so that a subsequent prefetch task does not request the\n  //   same segments again.\n  const oldTreeChildren = oldTree[1]\n  const newTreeChildren = newTree.slots\n  let requestTreeChildren: Record<string, FlightRouterState> = {}\n  if (newTreeChildren !== null) {\n    for (const parallelRouteKey in newTreeChildren) {\n      const newTreeChild = newTreeChildren[parallelRouteKey]\n      const newTreeChildSegment = newTreeChild.segment\n      const oldTreeChild: FlightRouterState | void =\n        oldTreeChildren[parallelRouteKey]\n      const oldTreeChildSegment: FlightRouterStateSegment | void =\n        oldTreeChild?.[0]\n      if (\n        oldTreeChildSegment !== undefined &&\n        doesCurrentSegmentMatchCachedSegment(\n          route,\n          newTreeChildSegment,\n          oldTreeChildSegment\n        )\n      ) {\n        // This segment is already part of the current route. Keep traversing.\n        const requestTreeChild = diffRouteTreeAgainstCurrent(\n          now,\n          task,\n          route,\n          oldTreeChild,\n          newTreeChild,\n          spawnedEntries,\n          fetchStrategy\n        )\n        requestTreeChildren[parallelRouteKey] = requestTreeChild\n      } else {\n        // This segment is not part of the current route. We're entering a\n        // part of the tree that we need to prefetch (unless everything is\n        // already cached).\n        switch (fetchStrategy) {\n          case FetchStrategy.LoadingBoundary: {\n            // When PPR is disabled, we can't prefetch per segment. We must\n            // fallback to the old prefetch behavior and send a dynamic request.\n            // Only routes that include a loading boundary can be prefetched in\n            // this way.\n            //\n            // This is simlar to a \"full\" prefetch, but we're much more\n            // conservative about which segments to include in the request.\n            //\n            // The server will only render up to the first loading boundary\n            // inside new part of the tree. If there's no loading boundary\n            // anywhere in the tree, the server will never return any data, so\n            // we can skip the request.\n            const subtreeHasLoadingBoundary =\n              newTreeChild.hasLoadingBoundary !==\n              HasLoadingBoundary.SubtreeHasNoLoadingBoundary\n            const requestTreeChild = subtreeHasLoadingBoundary\n              ? pingPPRDisabledRouteTreeUpToLoadingBoundary(\n                  now,\n                  task,\n                  route,\n                  newTreeChild,\n                  null,\n                  spawnedEntries\n                )\n              : // There's no loading boundary within this tree. Bail out.\n                convertRouteTreeToFlightRouterState(newTreeChild)\n            requestTreeChildren[parallelRouteKey] = requestTreeChild\n            break\n          }\n          case FetchStrategy.PPRRuntime: {\n            // This is a runtime prefetch. Fetch all cacheable data in the tree,\n            // not just the static PPR shell.\n            const requestTreeChild = pingRouteTreeAndIncludeDynamicData(\n              now,\n              task,\n              route,\n              newTreeChild,\n              false,\n              spawnedEntries,\n              fetchStrategy\n            )\n            requestTreeChildren[parallelRouteKey] = requestTreeChild\n            break\n          }\n          case FetchStrategy.Full: {\n            // This is a \"full\" prefetch. Fetch all the data in the tree, both\n            // static and dynamic. We issue roughly the same request that we\n            // would during a real navigation. The goal is that once the\n            // navigation occurs, the router should not have to fetch any\n            // additional data.\n            //\n            // Although the response will include dynamic data, opting into a\n            // Full prefetch — via <Link prefetch={true}> — implicitly\n            // instructs the cache to treat the response as \"static\", or non-\n            // dynamic, since the whole point is to cache it for\n            // future navigations.\n            //\n            // Construct a tree (currently a FlightRouterState) that represents\n            // which segments need to be prefetched and which ones are already\n            // cached. If the tree is empty, then we can exit. Otherwise, we'll\n            // send the request tree to the server and use the response to\n            // populate the segment cache.\n            const requestTreeChild = pingRouteTreeAndIncludeDynamicData(\n              now,\n              task,\n              route,\n              newTreeChild,\n              false,\n              spawnedEntries,\n              fetchStrategy\n            )\n            requestTreeChildren[parallelRouteKey] = requestTreeChild\n            break\n          }\n          default:\n            fetchStrategy satisfies never\n        }\n      }\n    }\n  }\n  const requestTree: FlightRouterState = [\n    newTree.segment,\n    requestTreeChildren,\n    null,\n    null,\n    newTree.isRootLayout,\n  ]\n  return requestTree\n}\n\nfunction pingPPRDisabledRouteTreeUpToLoadingBoundary(\n  now: number,\n  task: PrefetchTask,\n  route: FulfilledRouteCacheEntry,\n  tree: RouteTree,\n  refetchMarkerContext: 'refetch' | 'inside-shared-layout' | null,\n  spawnedEntries: Map<SegmentRequestKey, PendingSegmentCacheEntry>\n): FlightRouterState {\n  // This function is similar to pingRouteTreeAndIncludeDynamicData, except the\n  // server is only going to return a minimal loading state — it will stop\n  // rendering at the first loading boundary. Whereas a Full prefetch is\n  // intentionally aggressive and tries to pretfetch all the data that will be\n  // needed for a navigation, a LoadingBoundary prefetch is much more\n  // conservative. For example, it will omit from the request tree any segment\n  // that is already cached, regardles of whether it's partial or full. By\n  // contrast, a Full prefetch will refetch partial segments.\n\n  // \"inside-shared-layout\" tells the server where to start looking for a\n  // loading boundary.\n  let refetchMarker: 'refetch' | 'inside-shared-layout' | null =\n    refetchMarkerContext === null ? 'inside-shared-layout' : null\n\n  const segment = readOrCreateSegmentCacheEntry(\n    now,\n    task.fetchStrategy,\n    route,\n    tree\n  )\n  switch (segment.status) {\n    case EntryStatus.Empty: {\n      // This segment is not cached. Add a refetch marker so the server knows\n      // to start rendering here.\n      // TODO: Instead of a \"refetch\" marker, we could just omit this subtree's\n      // FlightRouterState from the request tree. I think this would probably\n      // already work even without any updates to the server. For consistency,\n      // though, I'll send the full tree and we'll look into this later as part\n      // of a larger redesign of the request protocol.\n\n      // Add the pending cache entry to the result map.\n      spawnedEntries.set(\n        tree.requestKey,\n        upgradeToPendingSegment(\n          segment,\n          // Set the fetch strategy to LoadingBoundary to indicate that the server\n          // might not include it in the pending response. If another route is able\n          // to issue a per-segment request, we'll do that in the background.\n          FetchStrategy.LoadingBoundary\n        )\n      )\n      if (refetchMarkerContext !== 'refetch') {\n        refetchMarker = refetchMarkerContext = 'refetch'\n      } else {\n        // There's already a parent with a refetch marker, so we don't need\n        // to add another one.\n      }\n      break\n    }\n    case EntryStatus.Fulfilled: {\n      // The segment is already cached.\n      const segmentHasLoadingBoundary =\n        tree.hasLoadingBoundary === HasLoadingBoundary.SegmentHasLoadingBoundary\n      if (segmentHasLoadingBoundary) {\n        // This segment has a loading boundary, which means the server won't\n        // render its children. So there's nothing left to prefetch along this\n        // path. We can bail out.\n        return convertRouteTreeToFlightRouterState(tree)\n      }\n      // NOTE: If the cached segment were fetched using PPR, then it might be\n      // partial. We could get a more complete version of the segment by\n      // including it in this non-PPR request.\n      //\n      // We're intentionally choosing not to, though, because it's generally\n      // better to avoid doing a full prefetch whenever possible.\n      break\n    }\n    case EntryStatus.Pending: {\n      // There's another prefetch currently in progress. Don't add the refetch\n      // marker yet, so the server knows it can skip rendering this segment.\n      break\n    }\n    case EntryStatus.Rejected: {\n      // The segment failed to load. We shouldn't issue another request until\n      // the stale time has elapsed.\n      break\n    }\n    default:\n      segment satisfies never\n  }\n  const requestTreeChildren: Record<string, FlightRouterState> = {}\n  if (tree.slots !== null) {\n    for (const parallelRouteKey in tree.slots) {\n      const childTree = tree.slots[parallelRouteKey]\n      requestTreeChildren[parallelRouteKey] =\n        pingPPRDisabledRouteTreeUpToLoadingBoundary(\n          now,\n          task,\n          route,\n          childTree,\n          refetchMarkerContext,\n          spawnedEntries\n        )\n    }\n  }\n  const requestTree: FlightRouterState = [\n    tree.segment,\n    requestTreeChildren,\n    null,\n    refetchMarker,\n    tree.isRootLayout,\n  ]\n  return requestTree\n}\n\nfunction pingRouteTreeAndIncludeDynamicData(\n  now: number,\n  task: PrefetchTask,\n  route: FulfilledRouteCacheEntry,\n  tree: RouteTree,\n  isInsideRefetchingParent: boolean,\n  spawnedEntries: Map<SegmentRequestKey, PendingSegmentCacheEntry>,\n  fetchStrategy: FetchStrategy.Full | FetchStrategy.PPRRuntime\n): FlightRouterState {\n  // The tree we're constructing is the same shape as the tree we're navigating\n  // to. But even though this is a \"new\" tree, some of the individual segments\n  // may be cached as a result of other route prefetches.\n  //\n  // So we need to find the first uncached segment along each path add an\n  // explicit \"refetch\" marker so the server knows where to start rendering.\n  // Once the server starts rendering along a path, it keeps rendering the\n  // entire subtree.\n  const segment = readOrCreateSegmentCacheEntry(\n    now,\n    // Note that `fetchStrategy` might be different from `task.fetchStrategy`,\n    // and we have to use the former here.\n    // We can have a task with `FetchStrategy.PPR` where some of its segments are configured to\n    // always use runtime prefetching (via `export const prefetch`), and those should check for\n    // entries that include search params.\n    fetchStrategy,\n    route,\n    tree\n  )\n\n  let spawnedSegment: PendingSegmentCacheEntry | null = null\n\n  switch (segment.status) {\n    case EntryStatus.Empty: {\n      // This segment is not cached. Include it in the request.\n      spawnedSegment = upgradeToPendingSegment(segment, fetchStrategy)\n      break\n    }\n    case EntryStatus.Fulfilled: {\n      // The segment is already cached.\n      if (\n        segment.isPartial &&\n        canNewFetchStrategyProvideMoreContent(\n          segment.fetchStrategy,\n          fetchStrategy\n        )\n      ) {\n        // The cached segment contains dynamic holes, and was prefetched using a less specific strategy than the current one.\n        // This means we're in one of these cases:\n        //   - we have a static prefetch, and we're doing a runtime prefetch\n        //   - we have a static or runtime prefetch, and we're doing a Full prefetch (or a navigation).\n        // In either case, we need to include it in the request to get a more specific (or full) version.\n        spawnedSegment = pingFullSegmentRevalidation(\n          now,\n          route,\n          tree,\n          fetchStrategy\n        )\n      }\n      break\n    }\n    case EntryStatus.Pending:\n    case EntryStatus.Rejected: {\n      // There's either another prefetch currently in progress, or the previous\n      // attempt failed. If the new strategy can provide more content, fetch it again.\n      if (\n        canNewFetchStrategyProvideMoreContent(\n          segment.fetchStrategy,\n          fetchStrategy\n        )\n      ) {\n        spawnedSegment = pingFullSegmentRevalidation(\n          now,\n          route,\n          tree,\n          fetchStrategy\n        )\n      }\n      break\n    }\n    default:\n      segment satisfies never\n  }\n  const requestTreeChildren: Record<string, FlightRouterState> = {}\n  if (tree.slots !== null) {\n    for (const parallelRouteKey in tree.slots) {\n      const childTree = tree.slots[parallelRouteKey]\n      requestTreeChildren[parallelRouteKey] =\n        pingRouteTreeAndIncludeDynamicData(\n          now,\n          task,\n          route,\n          childTree,\n          isInsideRefetchingParent || spawnedSegment !== null,\n          spawnedEntries,\n          fetchStrategy\n        )\n    }\n  }\n\n  if (spawnedSegment !== null) {\n    // Add the pending entry to the result map.\n    spawnedEntries.set(tree.requestKey, spawnedSegment)\n  }\n\n  // Don't bother to add a refetch marker if one is already present in a parent.\n  const refetchMarker =\n    !isInsideRefetchingParent && spawnedSegment !== null ? 'refetch' : null\n\n  const requestTree: FlightRouterState = [\n    tree.segment,\n    requestTreeChildren,\n    null,\n    refetchMarker,\n    tree.isRootLayout,\n  ]\n  return requestTree\n}\n\nfunction pingRuntimePrefetches(\n  now: number,\n  task: PrefetchTask,\n  route: FulfilledRouteCacheEntry,\n  tree: RouteTree,\n  spawnedRuntimePrefetches: Set<SegmentRequestKey>,\n  spawnedEntries: Map<SegmentRequestKey, PendingSegmentCacheEntry>\n): FlightRouterState {\n  // Construct a request tree (FlightRouterState) for a runtime prefetch. If\n  // a segment is part of the runtime prefetch, the tree is constructed by\n  // diffing against what's already in the prefetch cache. Otherwise, we send\n  // a regular FlightRouterState with no special markers.\n  //\n  // See pingRouteTreeAndIncludeDynamicData for details.\n  if (spawnedRuntimePrefetches.has(tree.requestKey)) {\n    // This segment needs a runtime prefetch.\n    return pingRouteTreeAndIncludeDynamicData(\n      now,\n      task,\n      route,\n      tree,\n      false,\n      spawnedEntries,\n      FetchStrategy.PPRRuntime\n    )\n  }\n  let requestTreeChildren: Record<string, FlightRouterState> = {}\n  const slots = tree.slots\n  if (slots !== null) {\n    for (const parallelRouteKey in slots) {\n      const childTree = slots[parallelRouteKey]\n      requestTreeChildren[parallelRouteKey] = pingRuntimePrefetches(\n        now,\n        task,\n        route,\n        childTree,\n        spawnedRuntimePrefetches,\n        spawnedEntries\n      )\n    }\n  }\n\n  // This segment is not part of the runtime prefetch. Clone the base tree.\n  const requestTree: FlightRouterState = [\n    tree.segment,\n    requestTreeChildren,\n    null,\n    null,\n  ]\n  return requestTree\n}\n\nfunction pingStaticSegmentData(\n  now: number,\n  task: PrefetchTask,\n  route: FulfilledRouteCacheEntry,\n  segment: SegmentCacheEntry,\n  routeKey: RouteCacheKey,\n  tree: RouteTree\n): void {\n  switch (segment.status) {\n    case EntryStatus.Empty:\n      // Upgrade to Pending so we know there's already a request in progress\n      spawnPrefetchSubtask(\n        fetchSegmentOnCacheMiss(\n          route,\n          upgradeToPendingSegment(segment, FetchStrategy.PPR),\n          routeKey,\n          tree\n        )\n      )\n      break\n    case EntryStatus.Pending: {\n      // There's already a request in progress. Depending on what kind of\n      // request it is, we may want to revalidate it.\n      switch (segment.fetchStrategy) {\n        case FetchStrategy.PPR:\n        case FetchStrategy.PPRRuntime:\n        case FetchStrategy.Full:\n          // There's already a request in progress. Don't do anything.\n          break\n        case FetchStrategy.LoadingBoundary:\n          // There's a pending request, but because it's using the old\n          // prefetching strategy, we can't be sure if it will be fulfilled by\n          // the response — it might be inside the loading boundary. Perform\n          // a revalidation, but because it's speculative, wait to do it at\n          // background priority.\n          if (background(task)) {\n            // TODO: Instead of speculatively revalidating, consider including\n            // `hasLoading` in the route tree prefetch response.\n            pingPPRSegmentRevalidation(now, route, routeKey, tree)\n          }\n          break\n        default:\n          segment.fetchStrategy satisfies never\n      }\n      break\n    }\n    case EntryStatus.Rejected: {\n      // The existing entry in the cache was rejected. Depending on how it\n      // was originally fetched, we may or may not want to revalidate it.\n      switch (segment.fetchStrategy) {\n        case FetchStrategy.PPR:\n        case FetchStrategy.PPRRuntime:\n        case FetchStrategy.Full:\n          // The previous attempt to fetch this entry failed. Don't attempt to\n          // fetch it again until the entry expires.\n          break\n        case FetchStrategy.LoadingBoundary:\n          // There's a rejected entry, but it was fetched using the loading\n          // boundary strategy. So the reason it wasn't returned by the server\n          // might just be because it was inside a loading boundary. Or because\n          // there was a dynamic rewrite. Revalidate it using the per-\n          // segment strategy.\n          //\n          // Because a rejected segment will definitely prevent the segment (and\n          // all of its children) from rendering, we perform this revalidation\n          // immediately instead of deferring it to a background task.\n          pingPPRSegmentRevalidation(now, route, routeKey, tree)\n          break\n        default:\n          segment.fetchStrategy satisfies never\n      }\n      break\n    }\n    case EntryStatus.Fulfilled:\n      // Segment is already cached. There's nothing left to prefetch.\n      break\n    default:\n      segment satisfies never\n  }\n\n  // Segments do not have dependent tasks, so once the prefetch is initiated,\n  // there's nothing else for us to do (except write the server data into the\n  // entry, which is handled by `fetchSegmentOnCacheMiss`).\n}\n\nfunction pingPPRSegmentRevalidation(\n  now: number,\n  route: FulfilledRouteCacheEntry,\n  routeKey: RouteCacheKey,\n  tree: RouteTree\n): void {\n  const revalidatingSegment = readOrCreateRevalidatingSegmentEntry(\n    now,\n    FetchStrategy.PPR,\n    route,\n    tree\n  )\n  switch (revalidatingSegment.status) {\n    case EntryStatus.Empty:\n      // Spawn a prefetch request and upsert the segment into the cache\n      // upon completion.\n      upsertSegmentOnCompletion(\n        spawnPrefetchSubtask(\n          fetchSegmentOnCacheMiss(\n            route,\n            upgradeToPendingSegment(revalidatingSegment, FetchStrategy.PPR),\n            routeKey,\n            tree\n          )\n        ),\n        getSegmentVaryPathForRequest(FetchStrategy.PPR, tree)\n      )\n      break\n    case EntryStatus.Pending:\n      // There's already a revalidation in progress.\n      break\n    case EntryStatus.Fulfilled:\n    case EntryStatus.Rejected:\n      // A previous revalidation attempt finished, but we chose not to replace\n      // the existing entry in the cache. Don't try again until or unless the\n      // revalidation entry expires.\n      break\n    default:\n      revalidatingSegment satisfies never\n  }\n}\n\nfunction pingFullSegmentRevalidation(\n  now: number,\n  route: FulfilledRouteCacheEntry,\n  tree: RouteTree,\n  fetchStrategy: FetchStrategy.Full | FetchStrategy.PPRRuntime\n): PendingSegmentCacheEntry | null {\n  const revalidatingSegment = readOrCreateRevalidatingSegmentEntry(\n    now,\n    fetchStrategy,\n    route,\n    tree\n  )\n  if (revalidatingSegment.status === EntryStatus.Empty) {\n    // During a Full/PPRRuntime prefetch, a single dynamic request is made for all the\n    // segments that we need. So we don't initiate a request here directly. By\n    // returning a pending entry from this function, it signals to the caller\n    // that this segment should be included in the request that's sent to\n    // the server.\n    const pendingSegment = upgradeToPendingSegment(\n      revalidatingSegment,\n      fetchStrategy\n    )\n    upsertSegmentOnCompletion(\n      waitForSegmentCacheEntry(pendingSegment),\n      getSegmentVaryPathForRequest(fetchStrategy, tree)\n    )\n    return pendingSegment\n  } else {\n    // There's already a revalidation in progress.\n    const nonEmptyRevalidatingSegment = revalidatingSegment\n    if (\n      canNewFetchStrategyProvideMoreContent(\n        nonEmptyRevalidatingSegment.fetchStrategy,\n        fetchStrategy\n      )\n    ) {\n      // The existing revalidation was fetched using a less specific strategy.\n      // Reset it and start a new revalidation.\n      const emptySegment = overwriteRevalidatingSegmentCacheEntry(\n        fetchStrategy,\n        route,\n        tree\n      )\n      const pendingSegment = upgradeToPendingSegment(\n        emptySegment,\n        fetchStrategy\n      )\n      upsertSegmentOnCompletion(\n        waitForSegmentCacheEntry(pendingSegment),\n        getSegmentVaryPathForRequest(fetchStrategy, tree)\n      )\n      return pendingSegment\n    }\n    switch (nonEmptyRevalidatingSegment.status) {\n      case EntryStatus.Pending:\n        // There's already an in-progress prefetch that includes this segment.\n        return null\n      case EntryStatus.Fulfilled:\n      case EntryStatus.Rejected:\n        // A previous revalidation attempt finished, but we chose not to replace\n        // the existing entry in the cache. Don't try again until or unless the\n        // revalidation entry expires.\n        return null\n      default:\n        nonEmptyRevalidatingSegment satisfies never\n        return null\n    }\n  }\n}\n\nconst noop = () => {}\n\nfunction upsertSegmentOnCompletion(\n  promise: Promise<FulfilledSegmentCacheEntry | null>,\n  varyPath: SegmentVaryPath\n) {\n  // Wait for a segment to finish loading, then upsert it into the cache\n  promise.then((fulfilled) => {\n    if (fulfilled !== null) {\n      // Received new data. Attempt to replace the existing entry in the cache.\n      upsertSegmentEntry(Date.now(), varyPath, fulfilled)\n    }\n  }, noop)\n}\n\nfunction doesCurrentSegmentMatchCachedSegment(\n  route: FulfilledRouteCacheEntry,\n  currentSegment: Segment,\n  cachedSegment: Segment\n): boolean {\n  if (cachedSegment === PAGE_SEGMENT_KEY) {\n    // In the FlightRouterState stored by the router, the page segment has the\n    // rendered search params appended to the name of the segment. In the\n    // prefetch cache, however, this is stored separately. So, when comparing\n    // the router's current FlightRouterState to the cached FlightRouterState,\n    // we need to make sure we compare both parts of the segment.\n    // TODO: This is not modeled clearly. We use the same type,\n    // FlightRouterState, for both the CacheNode tree _and_ the prefetch cache\n    // _and_ the server response format, when conceptually those are three\n    // different things and treated in different ways. We should encode more of\n    // this information into the type design so mistakes are less likely.\n    return (\n      currentSegment ===\n      addSearchParamsIfPageSegment(\n        PAGE_SEGMENT_KEY,\n        Object.fromEntries(new URLSearchParams(route.renderedSearch))\n      )\n    )\n  }\n  // Non-page segments are compared using the same function as the server\n  return matchSegment(cachedSegment, currentSegment)\n}\n\n// -----------------------------------------------------------------------------\n// The remainder of the module is a MinHeap implementation. Try not to put any\n// logic below here unless it's related to the heap algorithm. We can extract\n// this to a separate module if/when we need multiple kinds of heaps.\n// -----------------------------------------------------------------------------\n\nfunction compareQueuePriority(a: PrefetchTask, b: PrefetchTask) {\n  // Since the queue is a MinHeap, this should return a positive number if b is\n  // higher priority than a, and a negative number if a is higher priority\n  // than b.\n\n  // `priority` is an integer, where higher numbers are higher priority.\n  const priorityDiff = b.priority - a.priority\n  if (priorityDiff !== 0) {\n    return priorityDiff\n  }\n\n  // If the priority is the same, check which phase the prefetch is in — is it\n  // prefetching the route tree, or the segments? Route trees are prioritized.\n  const phaseDiff = b.phase - a.phase\n  if (phaseDiff !== 0) {\n    return phaseDiff\n  }\n\n  // Finally, check the insertion order. `sortId` is an incrementing counter\n  // assigned to prefetches. We want to process the newest prefetches first.\n  return b.sortId - a.sortId\n}\n\nfunction heapPush(heap: Array<PrefetchTask>, node: PrefetchTask): void {\n  const index = heap.length\n  heap.push(node)\n  node._heapIndex = index\n  heapSiftUp(heap, node, index)\n}\n\nfunction heapPeek(heap: Array<PrefetchTask>): PrefetchTask | null {\n  return heap.length === 0 ? null : heap[0]\n}\n\nfunction heapPop(heap: Array<PrefetchTask>): PrefetchTask | null {\n  if (heap.length === 0) {\n    return null\n  }\n  const first = heap[0]\n  first._heapIndex = -1\n  const last = heap.pop() as PrefetchTask\n  if (last !== first) {\n    heap[0] = last\n    last._heapIndex = 0\n    heapSiftDown(heap, last, 0)\n  }\n  return first\n}\n\nfunction heapDelete(heap: Array<PrefetchTask>, node: PrefetchTask): void {\n  const index = node._heapIndex\n  if (index !== -1) {\n    node._heapIndex = -1\n    if (heap.length !== 0) {\n      const last = heap.pop() as PrefetchTask\n      if (last !== node) {\n        heap[index] = last\n        last._heapIndex = index\n        heapSiftDown(heap, last, index)\n      }\n    }\n  }\n}\n\nfunction heapResift(heap: Array<PrefetchTask>, node: PrefetchTask): void {\n  const index = node._heapIndex\n  if (index !== -1) {\n    if (index === 0) {\n      heapSiftDown(heap, node, 0)\n    } else {\n      const parentIndex = (index - 1) >>> 1\n      const parent = heap[parentIndex]\n      if (compareQueuePriority(parent, node) > 0) {\n        // The parent is larger. Sift up.\n        heapSiftUp(heap, node, index)\n      } else {\n        // The parent is smaller (or equal). Sift down.\n        heapSiftDown(heap, node, index)\n      }\n    }\n  }\n}\n\nfunction heapSiftUp(\n  heap: Array<PrefetchTask>,\n  node: PrefetchTask,\n  i: number\n): void {\n  let index = i\n  while (index > 0) {\n    const parentIndex = (index - 1) >>> 1\n    const parent = heap[parentIndex]\n    if (compareQueuePriority(parent, node) > 0) {\n      // The parent is larger. Swap positions.\n      heap[parentIndex] = node\n      node._heapIndex = parentIndex\n      heap[index] = parent\n      parent._heapIndex = index\n\n      index = parentIndex\n    } else {\n      // The parent is smaller. Exit.\n      return\n    }\n  }\n}\n\nfunction heapSiftDown(\n  heap: Array<PrefetchTask>,\n  node: PrefetchTask,\n  i: number\n): void {\n  let index = i\n  const length = heap.length\n  const halfLength = length >>> 1\n  while (index < halfLength) {\n    const leftIndex = (index + 1) * 2 - 1\n    const left = heap[leftIndex]\n    const rightIndex = leftIndex + 1\n    const right = heap[rightIndex]\n\n    // If the left or right node is smaller, swap with the smaller of those.\n    if (compareQueuePriority(left, node) < 0) {\n      if (rightIndex < length && compareQueuePriority(right, left) < 0) {\n        heap[index] = right\n        right._heapIndex = index\n        heap[rightIndex] = node\n        node._heapIndex = rightIndex\n\n        index = rightIndex\n      } else {\n        heap[index] = left\n        left._heapIndex = index\n        heap[leftIndex] = node\n        node._heapIndex = leftIndex\n\n        index = leftIndex\n      }\n    } else if (rightIndex < length && compareQueuePriority(right, node) < 0) {\n      heap[index] = right\n      right._heapIndex = index\n      heap[rightIndex] = node\n      node._heapIndex = rightIndex\n\n      index = rightIndex\n    } else {\n      // Neither child is smaller. Exit.\n      return\n    }\n  }\n}\n","import type { FlightRouterState } from '../../shared/lib/app-router-types'\nimport type { AppRouterInstance } from '../../shared/lib/app-router-context.shared-runtime'\nimport {\n  FetchStrategy,\n  type PrefetchTaskFetchStrategy,\n  PrefetchPriority,\n} from './segment-cache/types'\nimport { createCacheKey } from './segment-cache/cache-key'\nimport {\n  type PrefetchTask,\n  schedulePrefetchTask as scheduleSegmentPrefetchTask,\n  cancelPrefetchTask,\n  reschedulePrefetchTask,\n  isPrefetchTaskDirty,\n} from './segment-cache/scheduler'\nimport { startTransition } from 'react'\n\ntype LinkElement = HTMLAnchorElement | SVGAElement\n\ntype Element = LinkElement | HTMLFormElement\n\n// Properties that are shared between Link and Form instances. We use the same\n// shape for both to prevent a polymorphic de-opt in the VM.\ntype LinkOrFormInstanceShared = {\n  router: AppRouterInstance\n  fetchStrategy: PrefetchTaskFetchStrategy\n\n  isVisible: boolean\n\n  // The most recently initiated prefetch task. It may or may not have\n  // already completed. The same prefetch task object can be reused across\n  // multiple prefetches of the same link.\n  prefetchTask: PrefetchTask | null\n}\n\nexport type FormInstance = LinkOrFormInstanceShared & {\n  prefetchHref: string\n  setOptimisticLinkStatus: null\n}\n\ntype PrefetchableLinkInstance = LinkOrFormInstanceShared & {\n  prefetchHref: string\n  setOptimisticLinkStatus: (status: { pending: boolean }) => void\n}\n\ntype NonPrefetchableLinkInstance = LinkOrFormInstanceShared & {\n  prefetchHref: null\n  setOptimisticLinkStatus: (status: { pending: boolean }) => void\n}\n\ntype PrefetchableInstance = PrefetchableLinkInstance | FormInstance\n\nexport type LinkInstance =\n  | PrefetchableLinkInstance\n  | NonPrefetchableLinkInstance\n\n// Tracks the most recently navigated link instance. When null, indicates\n// the current navigation was not initiated by a link click.\nlet linkForMostRecentNavigation: LinkInstance | null = null\n\n// Status object indicating link is pending\nexport const PENDING_LINK_STATUS = { pending: true }\n\n// Status object indicating link is idle\nexport const IDLE_LINK_STATUS = { pending: false }\n\n// Updates the loading state when navigating between links\n// - Resets the previous link's loading state\n// - Sets the new link's loading state\n// - Updates tracking of current navigation\nexport function setLinkForCurrentNavigation(link: LinkInstance | null) {\n  startTransition(() => {\n    linkForMostRecentNavigation?.setOptimisticLinkStatus(IDLE_LINK_STATUS)\n    link?.setOptimisticLinkStatus(PENDING_LINK_STATUS)\n    linkForMostRecentNavigation = link\n  })\n}\n\n// Unmounts the current link instance from navigation tracking\nexport function unmountLinkForCurrentNavigation(link: LinkInstance) {\n  if (linkForMostRecentNavigation === link) {\n    linkForMostRecentNavigation = null\n  }\n}\n\n// Use a WeakMap to associate a Link instance with its DOM element. This is\n// used by the IntersectionObserver to track the link's visibility.\nconst prefetchable:\n  | WeakMap<Element, PrefetchableInstance>\n  | Map<Element, PrefetchableInstance> =\n  typeof WeakMap === 'function' ? new WeakMap() : new Map()\n\n// A Set of the currently visible links. We re-prefetch visible links after a\n// cache invalidation, or when the current URL changes. It's a separate data\n// structure from the WeakMap above because only the visible links need to\n// be enumerated.\nconst prefetchableAndVisible: Set<PrefetchableInstance> = new Set()\n\n// A single IntersectionObserver instance shared by all <Link> components.\nconst observer: IntersectionObserver | null =\n  typeof IntersectionObserver === 'function'\n    ? new IntersectionObserver(handleIntersect, {\n        rootMargin: '200px',\n      })\n    : null\n\nfunction observeVisibility(element: Element, instance: PrefetchableInstance) {\n  const existingInstance = prefetchable.get(element)\n  if (existingInstance !== undefined) {\n    // This shouldn't happen because each <Link> component should have its own\n    // anchor tag instance, but it's defensive coding to avoid a memory leak in\n    // case there's a logical error somewhere else.\n    unmountPrefetchableInstance(element)\n  }\n  // Only track prefetchable links that have a valid prefetch URL\n  prefetchable.set(element, instance)\n  if (observer !== null) {\n    observer.observe(element)\n  }\n}\n\nfunction coercePrefetchableUrl(href: string): URL | null {\n  if (typeof window !== 'undefined') {\n    const { createPrefetchURL } =\n      require('./app-router-utils') as typeof import('./app-router-utils')\n\n    try {\n      return createPrefetchURL(href)\n    } catch {\n      // createPrefetchURL sometimes throws an error if an invalid URL is\n      // provided, though I'm not sure if it's actually necessary.\n      // TODO: Consider removing the throw from the inner function, or change it\n      // to reportError. Or maybe the error isn't even necessary for automatic\n      // prefetches, just navigations.\n      const reportErrorFn =\n        typeof reportError === 'function' ? reportError : console.error\n      reportErrorFn(\n        `Cannot prefetch '${href}' because it cannot be converted to a URL.`\n      )\n      return null\n    }\n  } else {\n    return null\n  }\n}\n\nexport function mountLinkInstance(\n  element: LinkElement,\n  href: string,\n  router: AppRouterInstance,\n  fetchStrategy: PrefetchTaskFetchStrategy,\n  prefetchEnabled: boolean,\n  setOptimisticLinkStatus: (status: { pending: boolean }) => void\n): LinkInstance {\n  if (prefetchEnabled) {\n    const prefetchURL = coercePrefetchableUrl(href)\n    if (prefetchURL !== null) {\n      const instance: PrefetchableLinkInstance = {\n        router,\n        fetchStrategy,\n        isVisible: false,\n        prefetchTask: null,\n        prefetchHref: prefetchURL.href,\n        setOptimisticLinkStatus,\n      }\n      // We only observe the link's visibility if it's prefetchable. For\n      // example, this excludes links to external URLs.\n      observeVisibility(element, instance)\n      return instance\n    }\n  }\n  // If the link is not prefetchable, we still create an instance so we can\n  // track its optimistic state (i.e. useLinkStatus).\n  const instance: NonPrefetchableLinkInstance = {\n    router,\n    fetchStrategy,\n    isVisible: false,\n    prefetchTask: null,\n    prefetchHref: null,\n    setOptimisticLinkStatus,\n  }\n  return instance\n}\n\nexport function mountFormInstance(\n  element: HTMLFormElement,\n  href: string,\n  router: AppRouterInstance,\n  fetchStrategy: PrefetchTaskFetchStrategy\n): void {\n  const prefetchURL = coercePrefetchableUrl(href)\n  if (prefetchURL === null) {\n    // This href is not prefetchable, so we don't track it.\n    // TODO: We currently observe/unobserve a form every time its href changes.\n    // For Links, this isn't a big deal because the href doesn't usually change,\n    // but for forms it's extremely common. We should optimize this.\n    return\n  }\n  const instance: FormInstance = {\n    router,\n    fetchStrategy,\n    isVisible: false,\n    prefetchTask: null,\n    prefetchHref: prefetchURL.href,\n    setOptimisticLinkStatus: null,\n  }\n  observeVisibility(element, instance)\n}\n\nexport function unmountPrefetchableInstance(element: Element) {\n  const instance = prefetchable.get(element)\n  if (instance !== undefined) {\n    prefetchable.delete(element)\n    prefetchableAndVisible.delete(instance)\n    const prefetchTask = instance.prefetchTask\n    if (prefetchTask !== null) {\n      cancelPrefetchTask(prefetchTask)\n    }\n  }\n  if (observer !== null) {\n    observer.unobserve(element)\n  }\n}\n\nfunction handleIntersect(entries: Array<IntersectionObserverEntry>) {\n  for (const entry of entries) {\n    // Some extremely old browsers or polyfills don't reliably support\n    // isIntersecting so we check intersectionRatio instead. (Do we care? Not\n    // really. But whatever this is fine.)\n    const isVisible = entry.intersectionRatio > 0\n    onLinkVisibilityChanged(entry.target as HTMLAnchorElement, isVisible)\n  }\n}\n\nexport function onLinkVisibilityChanged(element: Element, isVisible: boolean) {\n  if (process.env.NODE_ENV !== 'production') {\n    // Prefetching on viewport is disabled in development for performance\n    // reasons, because it requires compiling the target page.\n    // TODO: Investigate re-enabling this.\n    return\n  }\n\n  const instance = prefetchable.get(element)\n  if (instance === undefined) {\n    return\n  }\n\n  instance.isVisible = isVisible\n  if (isVisible) {\n    prefetchableAndVisible.add(instance)\n  } else {\n    prefetchableAndVisible.delete(instance)\n  }\n  rescheduleLinkPrefetch(instance, PrefetchPriority.Default)\n}\n\nexport function onNavigationIntent(\n  element: HTMLAnchorElement | SVGAElement,\n  unstable_upgradeToDynamicPrefetch: boolean\n) {\n  const instance = prefetchable.get(element)\n  if (instance === undefined) {\n    return\n  }\n  // Prefetch the link on hover/touchstart.\n  if (instance !== undefined) {\n    if (\n      process.env.__NEXT_DYNAMIC_ON_HOVER &&\n      unstable_upgradeToDynamicPrefetch\n    ) {\n      // Switch to a full prefetch\n      instance.fetchStrategy = FetchStrategy.Full\n    }\n    rescheduleLinkPrefetch(instance, PrefetchPriority.Intent)\n  }\n}\n\nfunction rescheduleLinkPrefetch(\n  instance: PrefetchableInstance,\n  priority: PrefetchPriority.Default | PrefetchPriority.Intent\n) {\n  // Ensures that app-router-instance is not compiled in the server bundle\n  if (typeof window !== 'undefined') {\n    const existingPrefetchTask = instance.prefetchTask\n\n    if (!instance.isVisible) {\n      // Cancel any in-progress prefetch task. (If it already finished then this\n      // is a no-op.)\n      if (existingPrefetchTask !== null) {\n        cancelPrefetchTask(existingPrefetchTask)\n      }\n      // We don't need to reset the prefetchTask to null upon cancellation; an\n      // old task object can be rescheduled with reschedulePrefetchTask. This is a\n      // micro-optimization but also makes the code simpler (don't need to\n      // worry about whether an old task object is stale).\n      return\n    }\n\n    const { getCurrentAppRouterState } =\n      require('./app-router-instance') as typeof import('./app-router-instance')\n\n    const appRouterState = getCurrentAppRouterState()\n    if (appRouterState !== null) {\n      const treeAtTimeOfPrefetch = appRouterState.tree\n      if (existingPrefetchTask === null) {\n        // Initiate a prefetch task.\n        const nextUrl = appRouterState.nextUrl\n        const cacheKey = createCacheKey(instance.prefetchHref, nextUrl)\n        instance.prefetchTask = scheduleSegmentPrefetchTask(\n          cacheKey,\n          treeAtTimeOfPrefetch,\n          instance.fetchStrategy,\n          priority,\n          null\n        )\n      } else {\n        // We already have an old task object that we can reschedule. This is\n        // effectively the same as canceling the old task and creating a new one.\n        reschedulePrefetchTask(\n          existingPrefetchTask,\n          treeAtTimeOfPrefetch,\n          instance.fetchStrategy,\n          priority\n        )\n      }\n    }\n  }\n}\n\nexport function pingVisibleLinks(\n  nextUrl: string | null,\n  tree: FlightRouterState\n) {\n  // For each currently visible link, cancel the existing prefetch task (if it\n  // exists) and schedule a new one. This is effectively the same as if all the\n  // visible links left and then re-entered the viewport.\n  //\n  // This is called when the Next-Url or the base tree changes, since those\n  // may affect the result of a prefetch task. It's also called after a\n  // cache invalidation.\n  for (const instance of prefetchableAndVisible) {\n    const task = instance.prefetchTask\n    if (task !== null && !isPrefetchTaskDirty(task, nextUrl, tree)) {\n      // The cache has not been invalidated, and none of the inputs have\n      // changed. Bail out.\n      continue\n    }\n    // Something changed. Cancel the existing prefetch task and schedule a\n    // new one.\n    if (task !== null) {\n      cancelPrefetchTask(task)\n    }\n    const cacheKey = createCacheKey(instance.prefetchHref, nextUrl)\n    instance.prefetchTask = scheduleSegmentPrefetchTask(\n      cacheKey,\n      tree,\n      instance.fetchStrategy,\n      PrefetchPriority.Default,\n      null\n    )\n  }\n}\n","import { parsePath } from './parse-path'\n\n/**\n * Checks if a given path starts with a given prefix. It ensures it matches\n * exactly without containing extra chars. e.g. prefix /docs should replace\n * for /docs, /docs/, /docs/a but not /docsss\n * @param path The path to check.\n * @param prefix The prefix to check against.\n */\nexport function pathHasPrefix(path: string, prefix: string) {\n  if (typeof path !== 'string') {\n    return false\n  }\n\n  const { pathname } = parsePath(path)\n  return pathname === prefix || pathname.startsWith(prefix + '/')\n}\n","import { pathHasPrefix } from '../shared/lib/router/utils/path-has-prefix'\n\nconst basePath = (process.env.__NEXT_ROUTER_BASEPATH as string) || ''\n\nexport function hasBasePath(path: string): boolean {\n  return pathHasPrefix(path, basePath)\n}\n","import { isAbsoluteUrl, getLocationOrigin } from '../../utils'\nimport { hasBasePath } from '../../../../client/has-base-path'\n\n/**\n * Detects whether a given url is routable by the Next.js router (browser only).\n */\nexport function isLocalURL(url: string): boolean {\n  // prevent a hydration mismatch on href for url with anchor refs\n  if (!isAbsoluteUrl(url)) return true\n  try {\n    // absolute urls can be local if they are on the same origin\n    const locationOrigin = getLocationOrigin()\n    const resolved = new URL(url, locationOrigin)\n    return resolved.origin === locationOrigin && hasBasePath(resolved.pathname)\n  } catch (_) {\n    return false\n  }\n}\n","let errorOnce = (_: string) => {}\nif (process.env.NODE_ENV !== 'production') {\n  const errors = new Set<string>()\n  errorOnce = (msg: string) => {\n    if (!errors.has(msg)) {\n      console.error(msg)\n    }\n    errors.add(msg)\n  }\n}\n\nexport { errorOnce }\n","'use client'\n\nimport React, { createContext, useContext, useOptimistic, useRef } from 'react'\nimport type { UrlObject } from 'url'\nimport { formatUrl } from '../../shared/lib/router/utils/format-url'\nimport { AppRouterContext } from '../../shared/lib/app-router-context.shared-runtime'\nimport { useMergedRef } from '../use-merged-ref'\nimport { isAbsoluteUrl } from '../../shared/lib/utils'\nimport { addBasePath } from '../add-base-path'\nimport { warnOnce } from '../../shared/lib/utils/warn-once'\nimport type { PENDING_LINK_STATUS } from '../components/links'\nimport {\n  IDLE_LINK_STATUS,\n  mountLinkInstance,\n  onNavigationIntent,\n  unmountLinkForCurrentNavigation,\n  unmountPrefetchableInstance,\n  type LinkInstance,\n} from '../components/links'\nimport { isLocalURL } from '../../shared/lib/router/utils/is-local-url'\nimport {\n  FetchStrategy,\n  type PrefetchTaskFetchStrategy,\n} from '../components/segment-cache/types'\nimport { errorOnce } from '../../shared/lib/utils/error-once'\n\ntype Url = string | UrlObject\ntype RequiredKeys<T> = {\n  [K in keyof T]-?: {} extends Pick<T, K> ? never : K\n}[keyof T]\ntype OptionalKeys<T> = {\n  [K in keyof T]-?: {} extends Pick<T, K> ? K : never\n}[keyof T]\n\ntype OnNavigateEventHandler = (event: { preventDefault: () => void }) => void\n\ntype InternalLinkProps = {\n  /**\n   * **Required**. The path or URL to navigate to. It can also be an object (similar to `URL`).\n   *\n   * @example\n   * ```tsx\n   * // Navigate to /dashboard:\n   * <Link href=\"/dashboard\">Dashboard</Link>\n   *\n   * // Navigate to /about?name=test:\n   * <Link href={{ pathname: '/about', query: { name: 'test' } }}>\n   *   About\n   * </Link>\n   * ```\n   *\n   * @remarks\n   * - For external URLs, use a fully qualified URL such as `https://...`.\n   * - In the App Router, dynamic routes must not include bracketed segments in `href`.\n   */\n  href: Url\n\n  /**\n   * @deprecated v10.0.0: `href` props pointing to a dynamic route are\n   * automatically resolved and no longer require the `as` prop.\n   */\n  as?: Url\n\n  /**\n   * Replace the current `history` state instead of adding a new URL into the stack.\n   *\n   * @defaultValue `false`\n   *\n   * @example\n   * ```tsx\n   * <Link href=\"/about\" replace>\n   *   About (replaces the history state)\n   * </Link>\n   * ```\n   */\n  replace?: boolean\n\n  /**\n   * Whether to override the default scroll behavior. If `true`, Next.js attempts to maintain\n   * the scroll position if the newly navigated page is still visible. If not, it scrolls to the top.\n   *\n   * If `false`, Next.js will not modify the scroll behavior at all.\n   *\n   * @defaultValue `true`\n   *\n   * @example\n   * ```tsx\n   * <Link href=\"/dashboard\" scroll={false}>\n   *   No auto scroll\n   * </Link>\n   * ```\n   */\n  scroll?: boolean\n\n  /**\n   * Update the path of the current page without rerunning data fetching methods\n   * like `getStaticProps`, `getServerSideProps`, or `getInitialProps`.\n   *\n   * @remarks\n   * `shallow` only applies to the Pages Router. For the App Router, see the\n   * [following documentation](https://nextjs.org/docs/app/building-your-application/routing/linking-and-navigating#using-the-native-history-api).\n   *\n   * @defaultValue `false`\n   *\n   * @example\n   * ```tsx\n   * <Link href=\"/blog\" shallow>\n   *   Shallow navigation\n   * </Link>\n   * ```\n   */\n  shallow?: boolean\n\n  /**\n   * Forces `Link` to pass its `href` to the child component. Useful if the child is a custom\n   * component that wraps an `<a>` tag, or if you're using certain styling libraries.\n   *\n   * @defaultValue `false`\n   *\n   * @example\n   * ```tsx\n   * <Link href=\"/dashboard\" passHref legacyBehavior>\n   *   <MyStyledAnchor>Dashboard</MyStyledAnchor>\n   * </Link>\n   * ```\n   */\n  passHref?: boolean\n\n  /**\n   * Prefetch the page in the background.\n   * Any `<Link />` that is in the viewport (initially or through scroll) will be prefetched.\n   * Prefetch can be disabled by passing `prefetch={false}`.\n   *\n   * @remarks\n   * Prefetching is only enabled in production.\n   *\n   * - In the **App Router**:\n   *   - `\"auto\"`, `null`, `undefined` (default): Prefetch behavior depends on static vs dynamic routes:\n   *     - Static routes: fully prefetched\n   *     - Dynamic routes: partial prefetch to the nearest segment with a `loading.js`\n   *   - `true`: Always prefetch the full route and data.\n   *   - `false`: Disable prefetching on both viewport and hover.\n   * - In the **Pages Router**:\n   *   - `true` (default): Prefetches the route and data in the background on viewport or hover.\n   *   - `false`: Prefetch only on hover, not on viewport.\n   *\n   * @defaultValue `true` (Pages Router) or `null` (App Router)\n   *\n   * @example\n   * ```tsx\n   * <Link href=\"/dashboard\" prefetch={false}>\n   *   Dashboard\n   * </Link>\n   * ```\n   */\n  prefetch?: boolean | 'auto' | null\n\n  /**\n   * (unstable) Switch to a full prefetch on hover. Effectively the same as\n   * updating the prefetch prop to `true` in a mouse event.\n   */\n  unstable_dynamicOnHover?: boolean\n\n  /**\n   * The active locale is automatically prepended in the Pages Router. `locale` allows for providing\n   * a different locale, or can be set to `false` to opt out of automatic locale behavior.\n   *\n   * @remarks\n   * Note: locale only applies in the Pages Router and is ignored in the App Router.\n   *\n   * @example\n   * ```tsx\n   * // Use the 'fr' locale:\n   * <Link href=\"/about\" locale=\"fr\">\n   *   About (French)\n   * </Link>\n   *\n   * // Disable locale prefix:\n   * <Link href=\"/about\" locale={false}>\n   *   About (no locale prefix)\n   * </Link>\n   * ```\n   */\n  locale?: string | false\n\n  /**\n   * Enable legacy link behavior.\n   *\n   * @deprecated This will be removed in a future version\n   * @defaultValue `false`\n   * @see https://github.com/vercel/next.js/commit/489e65ed98544e69b0afd7e0cfc3f9f6c2b803b7\n   */\n  legacyBehavior?: boolean\n\n  /**\n   * Optional event handler for when the mouse pointer is moved onto the `<Link>`.\n   */\n  onMouseEnter?: React.MouseEventHandler<HTMLAnchorElement>\n\n  /**\n   * Optional event handler for when the `<Link>` is touched.\n   */\n  onTouchStart?: React.TouchEventHandler<HTMLAnchorElement>\n\n  /**\n   * Optional event handler for when the `<Link>` is clicked.\n   */\n  onClick?: React.MouseEventHandler<HTMLAnchorElement>\n\n  /**\n   * Optional event handler for when the `<Link>` is navigated.\n   */\n  onNavigate?: OnNavigateEventHandler\n}\n\n// TODO-APP: Include the full set of Anchor props\n// adding this to the publicly exported type currently breaks existing apps\n\n// `RouteInferType` is a stub here to avoid breaking `typedRoutes` when the type\n// isn't generated yet. It will be replaced when type generation runs.\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport type LinkProps<RouteInferType = any> = InternalLinkProps\ntype LinkPropsRequired = RequiredKeys<LinkProps>\ntype LinkPropsOptional = OptionalKeys<Omit<InternalLinkProps, 'locale'>>\n\nfunction isModifiedEvent(event: React.MouseEvent): boolean {\n  const eventTarget = event.currentTarget as HTMLAnchorElement | SVGAElement\n  const target = eventTarget.getAttribute('target')\n  return (\n    (target && target !== '_self') ||\n    event.metaKey ||\n    event.ctrlKey ||\n    event.shiftKey ||\n    event.altKey || // triggers resource download\n    (event.nativeEvent && event.nativeEvent.which === 2)\n  )\n}\n\nfunction linkClicked(\n  e: React.MouseEvent,\n  href: string,\n  as: string,\n  linkInstanceRef: React.RefObject<LinkInstance | null>,\n  replace?: boolean,\n  scroll?: boolean,\n  onNavigate?: OnNavigateEventHandler\n): void {\n  if (typeof window !== 'undefined') {\n    const { nodeName } = e.currentTarget\n\n    // anchors inside an svg have a lowercase nodeName\n    const isAnchorNodeName = nodeName.toUpperCase() === 'A'\n    if (\n      (isAnchorNodeName && isModifiedEvent(e)) ||\n      e.currentTarget.hasAttribute('download')\n    ) {\n      // ignore click for browser’s default behavior\n      return\n    }\n\n    if (!isLocalURL(href)) {\n      if (replace) {\n        // browser default behavior does not replace the history state\n        // so we need to do it manually\n        e.preventDefault()\n        location.replace(href)\n      }\n\n      // ignore click for browser’s default behavior\n      return\n    }\n\n    e.preventDefault()\n\n    if (onNavigate) {\n      let isDefaultPrevented = false\n\n      onNavigate({\n        preventDefault: () => {\n          isDefaultPrevented = true\n        },\n      })\n\n      if (isDefaultPrevented) {\n        return\n      }\n    }\n\n    const { dispatchNavigateAction } =\n      require('../components/app-router-instance') as typeof import('../components/app-router-instance')\n\n    React.startTransition(() => {\n      dispatchNavigateAction(\n        as || href,\n        replace ? 'replace' : 'push',\n        scroll ?? true,\n        linkInstanceRef.current\n      )\n    })\n  }\n}\n\nfunction formatStringOrUrl(urlObjOrString: UrlObject | string): string {\n  if (typeof urlObjOrString === 'string') {\n    return urlObjOrString\n  }\n\n  return formatUrl(urlObjOrString)\n}\n\n/**\n * A React component that extends the HTML `<a>` element to provide\n * [prefetching](https://nextjs.org/docs/app/building-your-application/routing/linking-and-navigating#2-prefetching)\n * and client-side navigation. This is the primary way to navigate between routes in Next.js.\n *\n * @remarks\n * - Prefetching is only enabled in production.\n *\n * @see https://nextjs.org/docs/app/api-reference/components/link\n */\nexport default function LinkComponent(\n  props: LinkProps & {\n    children: React.ReactNode\n    ref: React.Ref<HTMLAnchorElement>\n  }\n) {\n  const [linkStatus, setOptimisticLinkStatus] = useOptimistic(IDLE_LINK_STATUS)\n\n  let children: React.ReactNode\n\n  const linkInstanceRef = useRef<LinkInstance | null>(null)\n\n  const {\n    href: hrefProp,\n    as: asProp,\n    children: childrenProp,\n    prefetch: prefetchProp = null,\n    passHref,\n    replace,\n    shallow,\n    scroll,\n    onClick,\n    onMouseEnter: onMouseEnterProp,\n    onTouchStart: onTouchStartProp,\n    legacyBehavior = false,\n    onNavigate,\n    ref: forwardedRef,\n    unstable_dynamicOnHover,\n    ...restProps\n  } = props\n\n  children = childrenProp\n\n  if (\n    legacyBehavior &&\n    (typeof children === 'string' || typeof children === 'number')\n  ) {\n    children = <a>{children}</a>\n  }\n\n  const router = React.useContext(AppRouterContext)\n\n  const prefetchEnabled = prefetchProp !== false\n\n  const fetchStrategy =\n    prefetchProp !== false\n      ? getFetchStrategyFromPrefetchProp(prefetchProp)\n      : // TODO: it makes no sense to assign a fetchStrategy when prefetching is disabled.\n        FetchStrategy.PPR\n\n  if (process.env.NODE_ENV !== 'production') {\n    function createPropError(args: {\n      key: string\n      expected: string\n      actual: string\n    }) {\n      return new Error(\n        `Failed prop type: The prop \\`${args.key}\\` expects a ${args.expected} in \\`<Link>\\`, but got \\`${args.actual}\\` instead.` +\n          (typeof window !== 'undefined'\n            ? \"\\nOpen your browser's console to view the Component stack trace.\"\n            : '')\n      )\n    }\n\n    // TypeScript trick for type-guarding:\n    const requiredPropsGuard: Record<LinkPropsRequired, true> = {\n      href: true,\n    } as const\n    const requiredProps: LinkPropsRequired[] = Object.keys(\n      requiredPropsGuard\n    ) as LinkPropsRequired[]\n    requiredProps.forEach((key: LinkPropsRequired) => {\n      if (key === 'href') {\n        if (\n          props[key] == null ||\n          (typeof props[key] !== 'string' && typeof props[key] !== 'object')\n        ) {\n          throw createPropError({\n            key,\n            expected: '`string` or `object`',\n            actual: props[key] === null ? 'null' : typeof props[key],\n          })\n        }\n      } else {\n        // TypeScript trick for type-guarding:\n        const _: never = key\n      }\n    })\n\n    // TypeScript trick for type-guarding:\n    const optionalPropsGuard: Record<LinkPropsOptional, true> = {\n      as: true,\n      replace: true,\n      scroll: true,\n      shallow: true,\n      passHref: true,\n      prefetch: true,\n      unstable_dynamicOnHover: true,\n      onClick: true,\n      onMouseEnter: true,\n      onTouchStart: true,\n      legacyBehavior: true,\n      onNavigate: true,\n    } as const\n    const optionalProps: LinkPropsOptional[] = Object.keys(\n      optionalPropsGuard\n    ) as LinkPropsOptional[]\n    optionalProps.forEach((key: LinkPropsOptional) => {\n      const valType = typeof props[key]\n\n      if (key === 'as') {\n        if (props[key] && valType !== 'string' && valType !== 'object') {\n          throw createPropError({\n            key,\n            expected: '`string` or `object`',\n            actual: valType,\n          })\n        }\n      } else if (\n        key === 'onClick' ||\n        key === 'onMouseEnter' ||\n        key === 'onTouchStart' ||\n        key === 'onNavigate'\n      ) {\n        if (props[key] && valType !== 'function') {\n          throw createPropError({\n            key,\n            expected: '`function`',\n            actual: valType,\n          })\n        }\n      } else if (\n        key === 'replace' ||\n        key === 'scroll' ||\n        key === 'shallow' ||\n        key === 'passHref' ||\n        key === 'legacyBehavior' ||\n        key === 'unstable_dynamicOnHover'\n      ) {\n        if (props[key] != null && valType !== 'boolean') {\n          throw createPropError({\n            key,\n            expected: '`boolean`',\n            actual: valType,\n          })\n        }\n      } else if (key === 'prefetch') {\n        if (\n          props[key] != null &&\n          valType !== 'boolean' &&\n          props[key] !== 'auto'\n        ) {\n          throw createPropError({\n            key,\n            expected: '`boolean | \"auto\"`',\n            actual: valType,\n          })\n        }\n      } else {\n        // TypeScript trick for type-guarding:\n        const _: never = key\n      }\n    })\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (props.locale) {\n      warnOnce(\n        'The `locale` prop is not supported in `next/link` while using the `app` router. Read more about app router internalization: https://nextjs.org/docs/app/building-your-application/routing/internationalization'\n      )\n    }\n    if (!asProp) {\n      let href: string | undefined\n      if (typeof hrefProp === 'string') {\n        href = hrefProp\n      } else if (\n        typeof hrefProp === 'object' &&\n        typeof hrefProp.pathname === 'string'\n      ) {\n        href = hrefProp.pathname\n      }\n\n      if (href) {\n        const hasDynamicSegment = href\n          .split('/')\n          .some((segment) => segment.startsWith('[') && segment.endsWith(']'))\n\n        if (hasDynamicSegment) {\n          throw new Error(\n            `Dynamic href \\`${href}\\` found in <Link> while using the \\`/app\\` router, this is not supported. Read more: https://nextjs.org/docs/messages/app-dir-dynamic-href`\n          )\n        }\n      }\n    }\n  }\n\n  const { href, as } = React.useMemo(() => {\n    const resolvedHref = formatStringOrUrl(hrefProp)\n    return {\n      href: resolvedHref,\n      as: asProp ? formatStringOrUrl(asProp) : resolvedHref,\n    }\n  }, [hrefProp, asProp])\n\n  // This will return the first child, if multiple are provided it will throw an error\n  let child: any\n  if (legacyBehavior) {\n    if ((children as any)?.$$typeof === Symbol.for('react.lazy')) {\n      throw new Error(\n        `\\`<Link legacyBehavior>\\` received a direct child that is either a Server Component, or JSX that was loaded with React.lazy(). This is not supported. Either remove legacyBehavior, or make the direct child a Client Component that renders the Link's \\`<a>\\` tag.`\n      )\n    }\n\n    if (process.env.NODE_ENV === 'development') {\n      if (onClick) {\n        console.warn(\n          `\"onClick\" was passed to <Link> with \\`href\\` of \\`${hrefProp}\\` but \"legacyBehavior\" was set. The legacy behavior requires onClick be set on the child of next/link`\n        )\n      }\n      if (onMouseEnterProp) {\n        console.warn(\n          `\"onMouseEnter\" was passed to <Link> with \\`href\\` of \\`${hrefProp}\\` but \"legacyBehavior\" was set. The legacy behavior requires onMouseEnter be set on the child of next/link`\n        )\n      }\n      try {\n        child = React.Children.only(children)\n      } catch (err) {\n        if (!children) {\n          throw new Error(\n            `No children were passed to <Link> with \\`href\\` of \\`${hrefProp}\\` but one child is required https://nextjs.org/docs/messages/link-no-children`\n          )\n        }\n        throw new Error(\n          `Multiple children were passed to <Link> with \\`href\\` of \\`${hrefProp}\\` but only one child is supported https://nextjs.org/docs/messages/link-multiple-children` +\n            (typeof window !== 'undefined'\n              ? \" \\nOpen your browser's console to view the Component stack trace.\"\n              : '')\n        )\n      }\n    } else {\n      child = React.Children.only(children)\n    }\n  } else {\n    if (process.env.NODE_ENV === 'development') {\n      if ((children as any)?.type === 'a') {\n        throw new Error(\n          'Invalid <Link> with <a> child. Please remove <a> or use <Link legacyBehavior>.\\nLearn more: https://nextjs.org/docs/messages/invalid-new-link-with-extra-anchor'\n        )\n      }\n    }\n  }\n\n  const childRef: any = legacyBehavior\n    ? child && typeof child === 'object' && child.ref\n    : forwardedRef\n\n  // Use a callback ref to attach an IntersectionObserver to the anchor tag on\n  // mount. In the future we will also use this to keep track of all the\n  // currently mounted <Link> instances, e.g. so we can re-prefetch them after\n  // a revalidation or refresh.\n  const observeLinkVisibilityOnMount = React.useCallback(\n    (element: HTMLAnchorElement | SVGAElement) => {\n      if (router !== null) {\n        linkInstanceRef.current = mountLinkInstance(\n          element,\n          href,\n          router,\n          fetchStrategy,\n          prefetchEnabled,\n          setOptimisticLinkStatus\n        )\n      }\n\n      return () => {\n        if (linkInstanceRef.current) {\n          unmountLinkForCurrentNavigation(linkInstanceRef.current)\n          linkInstanceRef.current = null\n        }\n        unmountPrefetchableInstance(element)\n      }\n    },\n    [prefetchEnabled, href, router, fetchStrategy, setOptimisticLinkStatus]\n  )\n\n  const mergedRef = useMergedRef(observeLinkVisibilityOnMount, childRef)\n\n  const childProps: {\n    onTouchStart?: React.TouchEventHandler<HTMLAnchorElement>\n    onMouseEnter: React.MouseEventHandler<HTMLAnchorElement>\n    onClick: React.MouseEventHandler<HTMLAnchorElement>\n    href?: string\n    ref?: any\n  } = {\n    ref: mergedRef,\n    onClick(e) {\n      if (process.env.NODE_ENV !== 'production') {\n        if (!e) {\n          throw new Error(\n            `Component rendered inside next/link has to pass click event to \"onClick\" prop.`\n          )\n        }\n      }\n\n      if (!legacyBehavior && typeof onClick === 'function') {\n        onClick(e)\n      }\n\n      if (\n        legacyBehavior &&\n        child.props &&\n        typeof child.props.onClick === 'function'\n      ) {\n        child.props.onClick(e)\n      }\n\n      if (!router) {\n        return\n      }\n      if (e.defaultPrevented) {\n        return\n      }\n      linkClicked(e, href, as, linkInstanceRef, replace, scroll, onNavigate)\n    },\n    onMouseEnter(e) {\n      if (!legacyBehavior && typeof onMouseEnterProp === 'function') {\n        onMouseEnterProp(e)\n      }\n\n      if (\n        legacyBehavior &&\n        child.props &&\n        typeof child.props.onMouseEnter === 'function'\n      ) {\n        child.props.onMouseEnter(e)\n      }\n\n      if (!router) {\n        return\n      }\n      if (!prefetchEnabled || process.env.NODE_ENV === 'development') {\n        return\n      }\n\n      const upgradeToDynamicPrefetch = unstable_dynamicOnHover === true\n      onNavigationIntent(\n        e.currentTarget as HTMLAnchorElement | SVGAElement,\n        upgradeToDynamicPrefetch\n      )\n    },\n    onTouchStart: process.env.__NEXT_LINK_NO_TOUCH_START\n      ? undefined\n      : function onTouchStart(e) {\n          if (!legacyBehavior && typeof onTouchStartProp === 'function') {\n            onTouchStartProp(e)\n          }\n\n          if (\n            legacyBehavior &&\n            child.props &&\n            typeof child.props.onTouchStart === 'function'\n          ) {\n            child.props.onTouchStart(e)\n          }\n\n          if (!router) {\n            return\n          }\n          if (!prefetchEnabled) {\n            return\n          }\n\n          const upgradeToDynamicPrefetch = unstable_dynamicOnHover === true\n          onNavigationIntent(\n            e.currentTarget as HTMLAnchorElement | SVGAElement,\n            upgradeToDynamicPrefetch\n          )\n        },\n  }\n\n  // If the url is absolute, we can bypass the logic to prepend the basePath.\n  if (isAbsoluteUrl(as)) {\n    childProps.href = as\n  } else if (\n    !legacyBehavior ||\n    passHref ||\n    (child.type === 'a' && !('href' in child.props))\n  ) {\n    childProps.href = addBasePath(as)\n  }\n\n  let link: React.ReactNode\n\n  if (legacyBehavior) {\n    if (process.env.NODE_ENV === 'development') {\n      errorOnce(\n        '`legacyBehavior` is deprecated and will be removed in a future ' +\n          'release. A codemod is available to upgrade your components:\\n\\n' +\n          'npx @next/codemod@latest new-link .\\n\\n' +\n          'Learn more: https://nextjs.org/docs/app/building-your-application/upgrading/codemods#remove-a-tags-from-link-components'\n      )\n    }\n    link = React.cloneElement(child, childProps)\n  } else {\n    link = (\n      <a {...restProps} {...childProps}>\n        {children}\n      </a>\n    )\n  }\n\n  return (\n    <LinkStatusContext.Provider value={linkStatus}>\n      {link}\n    </LinkStatusContext.Provider>\n  )\n}\n\nconst LinkStatusContext = createContext<\n  typeof PENDING_LINK_STATUS | typeof IDLE_LINK_STATUS\n>(IDLE_LINK_STATUS)\n\nexport const useLinkStatus = () => {\n  return useContext(LinkStatusContext)\n}\n\nfunction getFetchStrategyFromPrefetchProp(\n  prefetchProp: Exclude<LinkProps['prefetch'], undefined | false>\n): PrefetchTaskFetchStrategy {\n  if (process.env.__NEXT_CACHE_COMPONENTS) {\n    if (prefetchProp === true) {\n      return FetchStrategy.Full\n    }\n\n    // `null` or `\"auto\"`: this is the default \"auto\" mode, where we will prefetch partially if the link is in the viewport.\n    // This will also include invalid prop values that don't match the types specified here.\n    // (although those should've been filtered out by prop validation in dev)\n    prefetchProp satisfies null | 'auto'\n    return FetchStrategy.PPR\n  } else {\n    return prefetchProp === null || prefetchProp === 'auto'\n      ? // We default to PPR, and we'll discover whether or not the route supports it with the initial prefetch.\n        FetchStrategy.PPR\n      : // In the old implementation without runtime prefetches, `prefetch={true}` forces all dynamic data to be prefetched.\n        // To preserve backwards-compatibility, anything other than `false`, `null`, or `\"auto\"` results in a full prefetch.\n        // (although invalid values should've been filtered out by prop validation in dev)\n        FetchStrategy.Full\n  }\n}\n","'use client'\n\nimport * as React from 'react'\nimport * as SeparatorPrimitive from '@radix-ui/react-separator'\n\nimport { cn } from '@/lib/utils'\n\nfunction Separator({\n  className,\n  orientation = 'horizontal',\n  decorative = true,\n  ...props\n}: React.ComponentProps<typeof SeparatorPrimitive.Root>) {\n  return (\n    <SeparatorPrimitive.Root\n      data-slot=\"separator\"\n      decorative={decorative}\n      orientation={orientation}\n      className={cn(\n        'bg-border shrink-0 data-[orientation=horizontal]:h-px data-[orientation=horizontal]:w-full data-[orientation=vertical]:h-full data-[orientation=vertical]:w-px',\n        className,\n      )}\n      {...props}\n    />\n  )\n}\n\nexport { Separator }\n","'use client'\n\nimport * as React from 'react'\nimport * as SheetPrimitive from '@radix-ui/react-dialog'\nimport { XIcon } from 'lucide-react'\n\nimport { cn } from '@/lib/utils'\n\nfunction Sheet({ ...props }: React.ComponentProps<typeof SheetPrimitive.Root>) {\n  return <SheetPrimitive.Root data-slot=\"sheet\" {...props} />\n}\n\nfunction SheetTrigger({\n  ...props\n}: React.ComponentProps<typeof SheetPrimitive.Trigger>) {\n  return <SheetPrimitive.Trigger data-slot=\"sheet-trigger\" {...props} />\n}\n\nfunction SheetClose({\n  ...props\n}: React.ComponentProps<typeof SheetPrimitive.Close>) {\n  return <SheetPrimitive.Close data-slot=\"sheet-close\" {...props} />\n}\n\nfunction SheetPortal({\n  ...props\n}: React.ComponentProps<typeof SheetPrimitive.Portal>) {\n  return <SheetPrimitive.Portal data-slot=\"sheet-portal\" {...props} />\n}\n\nfunction SheetOverlay({\n  className,\n  ...props\n}: React.ComponentProps<typeof SheetPrimitive.Overlay>) {\n  return (\n    <SheetPrimitive.Overlay\n      data-slot=\"sheet-overlay\"\n      className={cn(\n        'data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50',\n        className,\n      )}\n      {...props}\n    />\n  )\n}\n\nfunction SheetContent({\n  className,\n  children,\n  side = 'right',\n  ...props\n}: React.ComponentProps<typeof SheetPrimitive.Content> & {\n  side?: 'top' | 'right' | 'bottom' | 'left'\n}) {\n  return (\n    <SheetPortal>\n      <SheetOverlay />\n      <SheetPrimitive.Content\n        data-slot=\"sheet-content\"\n        className={cn(\n          'bg-background data-[state=open]:animate-in data-[state=closed]:animate-out fixed z-50 flex flex-col gap-4 shadow-lg transition ease-in-out data-[state=closed]:duration-300 data-[state=open]:duration-500',\n          side === 'right' &&\n            'data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right inset-y-0 right-0 h-full w-3/4 border-l sm:max-w-sm',\n          side === 'left' &&\n            'data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left inset-y-0 left-0 h-full w-3/4 border-r sm:max-w-sm',\n          side === 'top' &&\n            'data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top inset-x-0 top-0 h-auto border-b',\n          side === 'bottom' &&\n            'data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom inset-x-0 bottom-0 h-auto border-t',\n          className,\n        )}\n        {...props}\n      >\n        {children}\n        <SheetPrimitive.Close className=\"ring-offset-background focus:ring-ring data-[state=open]:bg-secondary absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none\">\n          <XIcon className=\"size-4\" />\n          <span className=\"sr-only\">Close</span>\n        </SheetPrimitive.Close>\n      </SheetPrimitive.Content>\n    </SheetPortal>\n  )\n}\n\nfunction SheetHeader({ className, ...props }: React.ComponentProps<'div'>) {\n  return (\n    <div\n      data-slot=\"sheet-header\"\n      className={cn('flex flex-col gap-1.5 p-4', className)}\n      {...props}\n    />\n  )\n}\n\nfunction SheetFooter({ className, ...props }: React.ComponentProps<'div'>) {\n  return (\n    <div\n      data-slot=\"sheet-footer\"\n      className={cn('mt-auto flex flex-col gap-2 p-4', className)}\n      {...props}\n    />\n  )\n}\n\nfunction SheetTitle({\n  className,\n  ...props\n}: React.ComponentProps<typeof SheetPrimitive.Title>) {\n  return (\n    <SheetPrimitive.Title\n      data-slot=\"sheet-title\"\n      className={cn('text-foreground font-semibold', className)}\n      {...props}\n    />\n  )\n}\n\nfunction SheetDescription({\n  className,\n  ...props\n}: React.ComponentProps<typeof SheetPrimitive.Description>) {\n  return (\n    <SheetPrimitive.Description\n      data-slot=\"sheet-description\"\n      className={cn('text-muted-foreground text-sm', className)}\n      {...props}\n    />\n  )\n}\n\nexport {\n  Sheet,\n  SheetTrigger,\n  SheetClose,\n  SheetContent,\n  SheetHeader,\n  SheetFooter,\n  SheetTitle,\n  SheetDescription,\n}\n","/**\n * Custom positioning reference element.\n * @see https://floating-ui.com/docs/virtual-elements\n */\n\nconst sides = ['top', 'right', 'bottom', 'left'];\nconst alignments = ['start', 'end'];\nconst placements = /*#__PURE__*/sides.reduce((acc, side) => acc.concat(side, side + \"-\" + alignments[0], side + \"-\" + alignments[1]), []);\nconst min = Math.min;\nconst max = Math.max;\nconst round = Math.round;\nconst floor = Math.floor;\nconst createCoords = v => ({\n  x: v,\n  y: v\n});\nconst oppositeSideMap = {\n  left: 'right',\n  right: 'left',\n  bottom: 'top',\n  top: 'bottom'\n};\nconst oppositeAlignmentMap = {\n  start: 'end',\n  end: 'start'\n};\nfunction clamp(start, value, end) {\n  return max(start, min(value, end));\n}\nfunction evaluate(value, param) {\n  return typeof value === 'function' ? value(param) : value;\n}\nfunction getSide(placement) {\n  return placement.split('-')[0];\n}\nfunction getAlignment(placement) {\n  return placement.split('-')[1];\n}\nfunction getOppositeAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}\nfunction getAxisLength(axis) {\n  return axis === 'y' ? 'height' : 'width';\n}\nconst yAxisSides = /*#__PURE__*/new Set(['top', 'bottom']);\nfunction getSideAxis(placement) {\n  return yAxisSides.has(getSide(placement)) ? 'y' : 'x';\n}\nfunction getAlignmentAxis(placement) {\n  return getOppositeAxis(getSideAxis(placement));\n}\nfunction getAlignmentSides(placement, rects, rtl) {\n  if (rtl === void 0) {\n    rtl = false;\n  }\n  const alignment = getAlignment(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const length = getAxisLength(alignmentAxis);\n  let mainAlignmentSide = alignmentAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';\n  if (rects.reference[length] > rects.floating[length]) {\n    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);\n  }\n  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];\n}\nfunction getExpandedPlacements(placement) {\n  const oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];\n}\nfunction getOppositeAlignmentPlacement(placement) {\n  return placement.replace(/start|end/g, alignment => oppositeAlignmentMap[alignment]);\n}\nconst lrPlacement = ['left', 'right'];\nconst rlPlacement = ['right', 'left'];\nconst tbPlacement = ['top', 'bottom'];\nconst btPlacement = ['bottom', 'top'];\nfunction getSideList(side, isStart, rtl) {\n  switch (side) {\n    case 'top':\n    case 'bottom':\n      if (rtl) return isStart ? rlPlacement : lrPlacement;\n      return isStart ? lrPlacement : rlPlacement;\n    case 'left':\n    case 'right':\n      return isStart ? tbPlacement : btPlacement;\n    default:\n      return [];\n  }\n}\nfunction getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {\n  const alignment = getAlignment(placement);\n  let list = getSideList(getSide(placement), direction === 'start', rtl);\n  if (alignment) {\n    list = list.map(side => side + \"-\" + alignment);\n    if (flipAlignment) {\n      list = list.concat(list.map(getOppositeAlignmentPlacement));\n    }\n  }\n  return list;\n}\nfunction getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, side => oppositeSideMap[side]);\n}\nfunction expandPaddingObject(padding) {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n    ...padding\n  };\n}\nfunction getPaddingObject(padding) {\n  return typeof padding !== 'number' ? expandPaddingObject(padding) : {\n    top: padding,\n    right: padding,\n    bottom: padding,\n    left: padding\n  };\n}\nfunction rectToClientRect(rect) {\n  const {\n    x,\n    y,\n    width,\n    height\n  } = rect;\n  return {\n    width,\n    height,\n    top: y,\n    left: x,\n    right: x + width,\n    bottom: y + height,\n    x,\n    y\n  };\n}\n\nexport { alignments, clamp, createCoords, evaluate, expandPaddingObject, floor, getAlignment, getAlignmentAxis, getAlignmentSides, getAxisLength, getExpandedPlacements, getOppositeAlignmentPlacement, getOppositeAxis, getOppositeAxisPlacements, getOppositePlacement, getPaddingObject, getSide, getSideAxis, max, min, placements, rectToClientRect, round, sides };\n","function hasWindow() {\n  return typeof window !== 'undefined';\n}\nfunction getNodeName(node) {\n  if (isNode(node)) {\n    return (node.nodeName || '').toLowerCase();\n  }\n  // Mocked nodes in testing environments may not be instances of Node. By\n  // returning `#document` an infinite loop won't occur.\n  // https://github.com/floating-ui/floating-ui/issues/2317\n  return '#document';\n}\nfunction getWindow(node) {\n  var _node$ownerDocument;\n  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;\n}\nfunction getDocumentElement(node) {\n  var _ref;\n  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;\n}\nfunction isNode(value) {\n  if (!hasWindow()) {\n    return false;\n  }\n  return value instanceof Node || value instanceof getWindow(value).Node;\n}\nfunction isElement(value) {\n  if (!hasWindow()) {\n    return false;\n  }\n  return value instanceof Element || value instanceof getWindow(value).Element;\n}\nfunction isHTMLElement(value) {\n  if (!hasWindow()) {\n    return false;\n  }\n  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;\n}\nfunction isShadowRoot(value) {\n  if (!hasWindow() || typeof ShadowRoot === 'undefined') {\n    return false;\n  }\n  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;\n}\nconst invalidOverflowDisplayValues = /*#__PURE__*/new Set(['inline', 'contents']);\nfunction isOverflowElement(element) {\n  const {\n    overflow,\n    overflowX,\n    overflowY,\n    display\n  } = getComputedStyle(element);\n  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !invalidOverflowDisplayValues.has(display);\n}\nconst tableElements = /*#__PURE__*/new Set(['table', 'td', 'th']);\nfunction isTableElement(element) {\n  return tableElements.has(getNodeName(element));\n}\nconst topLayerSelectors = [':popover-open', ':modal'];\nfunction isTopLayer(element) {\n  return topLayerSelectors.some(selector => {\n    try {\n      return element.matches(selector);\n    } catch (_e) {\n      return false;\n    }\n  });\n}\nconst transformProperties = ['transform', 'translate', 'scale', 'rotate', 'perspective'];\nconst willChangeValues = ['transform', 'translate', 'scale', 'rotate', 'perspective', 'filter'];\nconst containValues = ['paint', 'layout', 'strict', 'content'];\nfunction isContainingBlock(elementOrCss) {\n  const webkit = isWebKit();\n  const css = isElement(elementOrCss) ? getComputedStyle(elementOrCss) : elementOrCss;\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  // https://drafts.csswg.org/css-transforms-2/#individual-transforms\n  return transformProperties.some(value => css[value] ? css[value] !== 'none' : false) || (css.containerType ? css.containerType !== 'normal' : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== 'none' : false) || !webkit && (css.filter ? css.filter !== 'none' : false) || willChangeValues.some(value => (css.willChange || '').includes(value)) || containValues.some(value => (css.contain || '').includes(value));\n}\nfunction getContainingBlock(element) {\n  let currentNode = getParentNode(element);\n  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    if (isContainingBlock(currentNode)) {\n      return currentNode;\n    } else if (isTopLayer(currentNode)) {\n      return null;\n    }\n    currentNode = getParentNode(currentNode);\n  }\n  return null;\n}\nfunction isWebKit() {\n  if (typeof CSS === 'undefined' || !CSS.supports) return false;\n  return CSS.supports('-webkit-backdrop-filter', 'none');\n}\nconst lastTraversableNodeNames = /*#__PURE__*/new Set(['html', 'body', '#document']);\nfunction isLastTraversableNode(node) {\n  return lastTraversableNodeNames.has(getNodeName(node));\n}\nfunction getComputedStyle(element) {\n  return getWindow(element).getComputedStyle(element);\n}\nfunction getNodeScroll(element) {\n  if (isElement(element)) {\n    return {\n      scrollLeft: element.scrollLeft,\n      scrollTop: element.scrollTop\n    };\n  }\n  return {\n    scrollLeft: element.scrollX,\n    scrollTop: element.scrollY\n  };\n}\nfunction getParentNode(node) {\n  if (getNodeName(node) === 'html') {\n    return node;\n  }\n  const result =\n  // Step into the shadow DOM of the parent of a slotted node.\n  node.assignedSlot ||\n  // DOM Element detected.\n  node.parentNode ||\n  // ShadowRoot detected.\n  isShadowRoot(node) && node.host ||\n  // Fallback.\n  getDocumentElement(node);\n  return isShadowRoot(result) ? result.host : result;\n}\nfunction getNearestOverflowAncestor(node) {\n  const parentNode = getParentNode(node);\n  if (isLastTraversableNode(parentNode)) {\n    return node.ownerDocument ? node.ownerDocument.body : node.body;\n  }\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n    return parentNode;\n  }\n  return getNearestOverflowAncestor(parentNode);\n}\nfunction getOverflowAncestors(node, list, traverseIframes) {\n  var _node$ownerDocument2;\n  if (list === void 0) {\n    list = [];\n  }\n  if (traverseIframes === void 0) {\n    traverseIframes = true;\n  }\n  const scrollableAncestor = getNearestOverflowAncestor(node);\n  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);\n  const win = getWindow(scrollableAncestor);\n  if (isBody) {\n    const frameElement = getFrameElement(win);\n    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);\n  }\n  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));\n}\nfunction getFrameElement(win) {\n  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;\n}\n\nexport { getComputedStyle, getContainingBlock, getDocumentElement, getFrameElement, getNearestOverflowAncestor, getNodeName, getNodeScroll, getOverflowAncestors, getParentNode, getWindow, isContainingBlock, isElement, isHTMLElement, isLastTraversableNode, isNode, isOverflowElement, isShadowRoot, isTableElement, isTopLayer, isWebKit };\n","\"use client\";\n\n// packages/react/popper/src/Popper.tsx\nimport * as React from \"react\";\nimport {\n  useFloating,\n  autoUpdate,\n  offset,\n  shift,\n  limitShift,\n  hide,\n  arrow as floatingUIarrow,\n  flip,\n  size\n} from \"@floating-ui/react-dom\";\nimport * as ArrowPrimitive from \"@radix-ui/react-arrow\";\nimport { useComposedRefs } from \"@radix-ui/react-compose-refs\";\nimport { createContextScope } from \"@radix-ui/react-context\";\nimport { Primitive } from \"@radix-ui/react-primitive\";\nimport { useCallbackRef } from \"@radix-ui/react-use-callback-ref\";\nimport { useLayoutEffect } from \"@radix-ui/react-use-layout-effect\";\nimport { useSize } from \"@radix-ui/react-use-size\";\nimport { jsx } from \"react/jsx-runtime\";\nvar SIDE_OPTIONS = [\"top\", \"right\", \"bottom\", \"left\"];\nvar ALIGN_OPTIONS = [\"start\", \"center\", \"end\"];\nvar POPPER_NAME = \"Popper\";\nvar [createPopperContext, createPopperScope] = createContextScope(POPPER_NAME);\nvar [PopperProvider, usePopperContext] = createPopperContext(POPPER_NAME);\nvar Popper = (props) => {\n  const { __scopePopper, children } = props;\n  const [anchor, setAnchor] = React.useState(null);\n  return /* @__PURE__ */ jsx(PopperProvider, { scope: __scopePopper, anchor, onAnchorChange: setAnchor, children });\n};\nPopper.displayName = POPPER_NAME;\nvar ANCHOR_NAME = \"PopperAnchor\";\nvar PopperAnchor = React.forwardRef(\n  (props, forwardedRef) => {\n    const { __scopePopper, virtualRef, ...anchorProps } = props;\n    const context = usePopperContext(ANCHOR_NAME, __scopePopper);\n    const ref = React.useRef(null);\n    const composedRefs = useComposedRefs(forwardedRef, ref);\n    React.useEffect(() => {\n      context.onAnchorChange(virtualRef?.current || ref.current);\n    });\n    return virtualRef ? null : /* @__PURE__ */ jsx(Primitive.div, { ...anchorProps, ref: composedRefs });\n  }\n);\nPopperAnchor.displayName = ANCHOR_NAME;\nvar CONTENT_NAME = \"PopperContent\";\nvar [PopperContentProvider, useContentContext] = createPopperContext(CONTENT_NAME);\nvar PopperContent = React.forwardRef(\n  (props, forwardedRef) => {\n    const {\n      __scopePopper,\n      side = \"bottom\",\n      sideOffset = 0,\n      align = \"center\",\n      alignOffset = 0,\n      arrowPadding = 0,\n      avoidCollisions = true,\n      collisionBoundary = [],\n      collisionPadding: collisionPaddingProp = 0,\n      sticky = \"partial\",\n      hideWhenDetached = false,\n      updatePositionStrategy = \"optimized\",\n      onPlaced,\n      ...contentProps\n    } = props;\n    const context = usePopperContext(CONTENT_NAME, __scopePopper);\n    const [content, setContent] = React.useState(null);\n    const composedRefs = useComposedRefs(forwardedRef, (node) => setContent(node));\n    const [arrow, setArrow] = React.useState(null);\n    const arrowSize = useSize(arrow);\n    const arrowWidth = arrowSize?.width ?? 0;\n    const arrowHeight = arrowSize?.height ?? 0;\n    const desiredPlacement = side + (align !== \"center\" ? \"-\" + align : \"\");\n    const collisionPadding = typeof collisionPaddingProp === \"number\" ? collisionPaddingProp : { top: 0, right: 0, bottom: 0, left: 0, ...collisionPaddingProp };\n    const boundary = Array.isArray(collisionBoundary) ? collisionBoundary : [collisionBoundary];\n    const hasExplicitBoundaries = boundary.length > 0;\n    const detectOverflowOptions = {\n      padding: collisionPadding,\n      boundary: boundary.filter(isNotNull),\n      // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries\n      altBoundary: hasExplicitBoundaries\n    };\n    const { refs, floatingStyles, placement, isPositioned, middlewareData } = useFloating({\n      // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues\n      strategy: \"fixed\",\n      placement: desiredPlacement,\n      whileElementsMounted: (...args) => {\n        const cleanup = autoUpdate(...args, {\n          animationFrame: updatePositionStrategy === \"always\"\n        });\n        return cleanup;\n      },\n      elements: {\n        reference: context.anchor\n      },\n      middleware: [\n        offset({ mainAxis: sideOffset + arrowHeight, alignmentAxis: alignOffset }),\n        avoidCollisions && shift({\n          mainAxis: true,\n          crossAxis: false,\n          limiter: sticky === \"partial\" ? limitShift() : void 0,\n          ...detectOverflowOptions\n        }),\n        avoidCollisions && flip({ ...detectOverflowOptions }),\n        size({\n          ...detectOverflowOptions,\n          apply: ({ elements, rects, availableWidth, availableHeight }) => {\n            const { width: anchorWidth, height: anchorHeight } = rects.reference;\n            const contentStyle = elements.floating.style;\n            contentStyle.setProperty(\"--radix-popper-available-width\", `${availableWidth}px`);\n            contentStyle.setProperty(\"--radix-popper-available-height\", `${availableHeight}px`);\n            contentStyle.setProperty(\"--radix-popper-anchor-width\", `${anchorWidth}px`);\n            contentStyle.setProperty(\"--radix-popper-anchor-height\", `${anchorHeight}px`);\n          }\n        }),\n        arrow && floatingUIarrow({ element: arrow, padding: arrowPadding }),\n        transformOrigin({ arrowWidth, arrowHeight }),\n        hideWhenDetached && hide({ strategy: \"referenceHidden\", ...detectOverflowOptions })\n      ]\n    });\n    const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);\n    const handlePlaced = useCallbackRef(onPlaced);\n    useLayoutEffect(() => {\n      if (isPositioned) {\n        handlePlaced?.();\n      }\n    }, [isPositioned, handlePlaced]);\n    const arrowX = middlewareData.arrow?.x;\n    const arrowY = middlewareData.arrow?.y;\n    const cannotCenterArrow = middlewareData.arrow?.centerOffset !== 0;\n    const [contentZIndex, setContentZIndex] = React.useState();\n    useLayoutEffect(() => {\n      if (content) setContentZIndex(window.getComputedStyle(content).zIndex);\n    }, [content]);\n    return /* @__PURE__ */ jsx(\n      \"div\",\n      {\n        ref: refs.setFloating,\n        \"data-radix-popper-content-wrapper\": \"\",\n        style: {\n          ...floatingStyles,\n          transform: isPositioned ? floatingStyles.transform : \"translate(0, -200%)\",\n          // keep off the page when measuring\n          minWidth: \"max-content\",\n          zIndex: contentZIndex,\n          [\"--radix-popper-transform-origin\"]: [\n            middlewareData.transformOrigin?.x,\n            middlewareData.transformOrigin?.y\n          ].join(\" \"),\n          // hide the content if using the hide middleware and should be hidden\n          // set visibility to hidden and disable pointer events so the UI behaves\n          // as if the PopperContent isn't there at all\n          ...middlewareData.hide?.referenceHidden && {\n            visibility: \"hidden\",\n            pointerEvents: \"none\"\n          }\n        },\n        dir: props.dir,\n        children: /* @__PURE__ */ jsx(\n          PopperContentProvider,\n          {\n            scope: __scopePopper,\n            placedSide,\n            onArrowChange: setArrow,\n            arrowX,\n            arrowY,\n            shouldHideArrow: cannotCenterArrow,\n            children: /* @__PURE__ */ jsx(\n              Primitive.div,\n              {\n                \"data-side\": placedSide,\n                \"data-align\": placedAlign,\n                ...contentProps,\n                ref: composedRefs,\n                style: {\n                  ...contentProps.style,\n                  // if the PopperContent hasn't been placed yet (not all measurements done)\n                  // we prevent animations so that users's animation don't kick in too early referring wrong sides\n                  animation: !isPositioned ? \"none\" : void 0\n                }\n              }\n            )\n          }\n        )\n      }\n    );\n  }\n);\nPopperContent.displayName = CONTENT_NAME;\nvar ARROW_NAME = \"PopperArrow\";\nvar OPPOSITE_SIDE = {\n  top: \"bottom\",\n  right: \"left\",\n  bottom: \"top\",\n  left: \"right\"\n};\nvar PopperArrow = React.forwardRef(function PopperArrow2(props, forwardedRef) {\n  const { __scopePopper, ...arrowProps } = props;\n  const contentContext = useContentContext(ARROW_NAME, __scopePopper);\n  const baseSide = OPPOSITE_SIDE[contentContext.placedSide];\n  return (\n    // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)\n    // doesn't report size as we'd expect on SVG elements.\n    // it reports their bounding box which is effectively the largest path inside the SVG.\n    /* @__PURE__ */ jsx(\n      \"span\",\n      {\n        ref: contentContext.onArrowChange,\n        style: {\n          position: \"absolute\",\n          left: contentContext.arrowX,\n          top: contentContext.arrowY,\n          [baseSide]: 0,\n          transformOrigin: {\n            top: \"\",\n            right: \"0 0\",\n            bottom: \"center 0\",\n            left: \"100% 0\"\n          }[contentContext.placedSide],\n          transform: {\n            top: \"translateY(100%)\",\n            right: \"translateY(50%) rotate(90deg) translateX(-50%)\",\n            bottom: `rotate(180deg)`,\n            left: \"translateY(50%) rotate(-90deg) translateX(50%)\"\n          }[contentContext.placedSide],\n          visibility: contentContext.shouldHideArrow ? \"hidden\" : void 0\n        },\n        children: /* @__PURE__ */ jsx(\n          ArrowPrimitive.Root,\n          {\n            ...arrowProps,\n            ref: forwardedRef,\n            style: {\n              ...arrowProps.style,\n              // ensures the element can be measured correctly (mostly for if SVG)\n              display: \"block\"\n            }\n          }\n        )\n      }\n    )\n  );\n});\nPopperArrow.displayName = ARROW_NAME;\nfunction isNotNull(value) {\n  return value !== null;\n}\nvar transformOrigin = (options) => ({\n  name: \"transformOrigin\",\n  options,\n  fn(data) {\n    const { placement, rects, middlewareData } = data;\n    const cannotCenterArrow = middlewareData.arrow?.centerOffset !== 0;\n    const isArrowHidden = cannotCenterArrow;\n    const arrowWidth = isArrowHidden ? 0 : options.arrowWidth;\n    const arrowHeight = isArrowHidden ? 0 : options.arrowHeight;\n    const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);\n    const noArrowAlign = { start: \"0%\", center: \"50%\", end: \"100%\" }[placedAlign];\n    const arrowXCenter = (middlewareData.arrow?.x ?? 0) + arrowWidth / 2;\n    const arrowYCenter = (middlewareData.arrow?.y ?? 0) + arrowHeight / 2;\n    let x = \"\";\n    let y = \"\";\n    if (placedSide === \"bottom\") {\n      x = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;\n      y = `${-arrowHeight}px`;\n    } else if (placedSide === \"top\") {\n      x = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;\n      y = `${rects.floating.height + arrowHeight}px`;\n    } else if (placedSide === \"right\") {\n      x = `${-arrowHeight}px`;\n      y = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;\n    } else if (placedSide === \"left\") {\n      x = `${rects.floating.width + arrowHeight}px`;\n      y = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;\n    }\n    return { data: { x, y } };\n  }\n});\nfunction getSideAndAlignFromPlacement(placement) {\n  const [side, align = \"center\"] = placement.split(\"-\");\n  return [side, align];\n}\nvar Root2 = Popper;\nvar Anchor = PopperAnchor;\nvar Content = PopperContent;\nvar Arrow = PopperArrow;\nexport {\n  ALIGN_OPTIONS,\n  Anchor,\n  Arrow,\n  Content,\n  Popper,\n  PopperAnchor,\n  PopperArrow,\n  PopperContent,\n  Root2 as Root,\n  SIDE_OPTIONS,\n  createPopperScope\n};\n//# sourceMappingURL=index.mjs.map\n","\"use client\";\n\n// packages/react/tooltip/src/Tooltip.tsx\nimport * as React from \"react\";\nimport { composeEventHandlers } from \"@radix-ui/primitive\";\nimport { useComposedRefs } from \"@radix-ui/react-compose-refs\";\nimport { createContextScope } from \"@radix-ui/react-context\";\nimport { DismissableLayer } from \"@radix-ui/react-dismissable-layer\";\nimport { useId } from \"@radix-ui/react-id\";\nimport * as PopperPrimitive from \"@radix-ui/react-popper\";\nimport { createPopperScope } from \"@radix-ui/react-popper\";\nimport { Portal as PortalPrimitive } from \"@radix-ui/react-portal\";\nimport { Presence } from \"@radix-ui/react-presence\";\nimport { Primitive } from \"@radix-ui/react-primitive\";\nimport { Slottable } from \"@radix-ui/react-slot\";\nimport { useControllableState } from \"@radix-ui/react-use-controllable-state\";\nimport * as VisuallyHiddenPrimitive from \"@radix-ui/react-visually-hidden\";\nimport { jsx, jsxs } from \"react/jsx-runtime\";\nvar [createTooltipContext, createTooltipScope] = createContextScope(\"Tooltip\", [\n  createPopperScope\n]);\nvar usePopperScope = createPopperScope();\nvar PROVIDER_NAME = \"TooltipProvider\";\nvar DEFAULT_DELAY_DURATION = 700;\nvar TOOLTIP_OPEN = \"tooltip.open\";\nvar [TooltipProviderContextProvider, useTooltipProviderContext] = createTooltipContext(PROVIDER_NAME);\nvar TooltipProvider = (props) => {\n  const {\n    __scopeTooltip,\n    delayDuration = DEFAULT_DELAY_DURATION,\n    skipDelayDuration = 300,\n    disableHoverableContent = false,\n    children\n  } = props;\n  const [isOpenDelayed, setIsOpenDelayed] = React.useState(true);\n  const isPointerInTransitRef = React.useRef(false);\n  const skipDelayTimerRef = React.useRef(0);\n  React.useEffect(() => {\n    const skipDelayTimer = skipDelayTimerRef.current;\n    return () => window.clearTimeout(skipDelayTimer);\n  }, []);\n  return /* @__PURE__ */ jsx(\n    TooltipProviderContextProvider,\n    {\n      scope: __scopeTooltip,\n      isOpenDelayed,\n      delayDuration,\n      onOpen: React.useCallback(() => {\n        window.clearTimeout(skipDelayTimerRef.current);\n        setIsOpenDelayed(false);\n      }, []),\n      onClose: React.useCallback(() => {\n        window.clearTimeout(skipDelayTimerRef.current);\n        skipDelayTimerRef.current = window.setTimeout(\n          () => setIsOpenDelayed(true),\n          skipDelayDuration\n        );\n      }, [skipDelayDuration]),\n      isPointerInTransitRef,\n      onPointerInTransitChange: React.useCallback((inTransit) => {\n        isPointerInTransitRef.current = inTransit;\n      }, []),\n      disableHoverableContent,\n      children\n    }\n  );\n};\nTooltipProvider.displayName = PROVIDER_NAME;\nvar TOOLTIP_NAME = \"Tooltip\";\nvar [TooltipContextProvider, useTooltipContext] = createTooltipContext(TOOLTIP_NAME);\nvar Tooltip = (props) => {\n  const {\n    __scopeTooltip,\n    children,\n    open: openProp,\n    defaultOpen = false,\n    onOpenChange,\n    disableHoverableContent: disableHoverableContentProp,\n    delayDuration: delayDurationProp\n  } = props;\n  const providerContext = useTooltipProviderContext(TOOLTIP_NAME, props.__scopeTooltip);\n  const popperScope = usePopperScope(__scopeTooltip);\n  const [trigger, setTrigger] = React.useState(null);\n  const contentId = useId();\n  const openTimerRef = React.useRef(0);\n  const disableHoverableContent = disableHoverableContentProp ?? providerContext.disableHoverableContent;\n  const delayDuration = delayDurationProp ?? providerContext.delayDuration;\n  const wasOpenDelayedRef = React.useRef(false);\n  const [open = false, setOpen] = useControllableState({\n    prop: openProp,\n    defaultProp: defaultOpen,\n    onChange: (open2) => {\n      if (open2) {\n        providerContext.onOpen();\n        document.dispatchEvent(new CustomEvent(TOOLTIP_OPEN));\n      } else {\n        providerContext.onClose();\n      }\n      onOpenChange?.(open2);\n    }\n  });\n  const stateAttribute = React.useMemo(() => {\n    return open ? wasOpenDelayedRef.current ? \"delayed-open\" : \"instant-open\" : \"closed\";\n  }, [open]);\n  const handleOpen = React.useCallback(() => {\n    window.clearTimeout(openTimerRef.current);\n    openTimerRef.current = 0;\n    wasOpenDelayedRef.current = false;\n    setOpen(true);\n  }, [setOpen]);\n  const handleClose = React.useCallback(() => {\n    window.clearTimeout(openTimerRef.current);\n    openTimerRef.current = 0;\n    setOpen(false);\n  }, [setOpen]);\n  const handleDelayedOpen = React.useCallback(() => {\n    window.clearTimeout(openTimerRef.current);\n    openTimerRef.current = window.setTimeout(() => {\n      wasOpenDelayedRef.current = true;\n      setOpen(true);\n      openTimerRef.current = 0;\n    }, delayDuration);\n  }, [delayDuration, setOpen]);\n  React.useEffect(() => {\n    return () => {\n      if (openTimerRef.current) {\n        window.clearTimeout(openTimerRef.current);\n        openTimerRef.current = 0;\n      }\n    };\n  }, []);\n  return /* @__PURE__ */ jsx(PopperPrimitive.Root, { ...popperScope, children: /* @__PURE__ */ jsx(\n    TooltipContextProvider,\n    {\n      scope: __scopeTooltip,\n      contentId,\n      open,\n      stateAttribute,\n      trigger,\n      onTriggerChange: setTrigger,\n      onTriggerEnter: React.useCallback(() => {\n        if (providerContext.isOpenDelayed) handleDelayedOpen();\n        else handleOpen();\n      }, [providerContext.isOpenDelayed, handleDelayedOpen, handleOpen]),\n      onTriggerLeave: React.useCallback(() => {\n        if (disableHoverableContent) {\n          handleClose();\n        } else {\n          window.clearTimeout(openTimerRef.current);\n          openTimerRef.current = 0;\n        }\n      }, [handleClose, disableHoverableContent]),\n      onOpen: handleOpen,\n      onClose: handleClose,\n      disableHoverableContent,\n      children\n    }\n  ) });\n};\nTooltip.displayName = TOOLTIP_NAME;\nvar TRIGGER_NAME = \"TooltipTrigger\";\nvar TooltipTrigger = React.forwardRef(\n  (props, forwardedRef) => {\n    const { __scopeTooltip, ...triggerProps } = props;\n    const context = useTooltipContext(TRIGGER_NAME, __scopeTooltip);\n    const providerContext = useTooltipProviderContext(TRIGGER_NAME, __scopeTooltip);\n    const popperScope = usePopperScope(__scopeTooltip);\n    const ref = React.useRef(null);\n    const composedRefs = useComposedRefs(forwardedRef, ref, context.onTriggerChange);\n    const isPointerDownRef = React.useRef(false);\n    const hasPointerMoveOpenedRef = React.useRef(false);\n    const handlePointerUp = React.useCallback(() => isPointerDownRef.current = false, []);\n    React.useEffect(() => {\n      return () => document.removeEventListener(\"pointerup\", handlePointerUp);\n    }, [handlePointerUp]);\n    return /* @__PURE__ */ jsx(PopperPrimitive.Anchor, { asChild: true, ...popperScope, children: /* @__PURE__ */ jsx(\n      Primitive.button,\n      {\n        \"aria-describedby\": context.open ? context.contentId : void 0,\n        \"data-state\": context.stateAttribute,\n        ...triggerProps,\n        ref: composedRefs,\n        onPointerMove: composeEventHandlers(props.onPointerMove, (event) => {\n          if (event.pointerType === \"touch\") return;\n          if (!hasPointerMoveOpenedRef.current && !providerContext.isPointerInTransitRef.current) {\n            context.onTriggerEnter();\n            hasPointerMoveOpenedRef.current = true;\n          }\n        }),\n        onPointerLeave: composeEventHandlers(props.onPointerLeave, () => {\n          context.onTriggerLeave();\n          hasPointerMoveOpenedRef.current = false;\n        }),\n        onPointerDown: composeEventHandlers(props.onPointerDown, () => {\n          isPointerDownRef.current = true;\n          document.addEventListener(\"pointerup\", handlePointerUp, { once: true });\n        }),\n        onFocus: composeEventHandlers(props.onFocus, () => {\n          if (!isPointerDownRef.current) context.onOpen();\n        }),\n        onBlur: composeEventHandlers(props.onBlur, context.onClose),\n        onClick: composeEventHandlers(props.onClick, context.onClose)\n      }\n    ) });\n  }\n);\nTooltipTrigger.displayName = TRIGGER_NAME;\nvar PORTAL_NAME = \"TooltipPortal\";\nvar [PortalProvider, usePortalContext] = createTooltipContext(PORTAL_NAME, {\n  forceMount: void 0\n});\nvar TooltipPortal = (props) => {\n  const { __scopeTooltip, forceMount, children, container } = props;\n  const context = useTooltipContext(PORTAL_NAME, __scopeTooltip);\n  return /* @__PURE__ */ jsx(PortalProvider, { scope: __scopeTooltip, forceMount, children: /* @__PURE__ */ jsx(Presence, { present: forceMount || context.open, children: /* @__PURE__ */ jsx(PortalPrimitive, { asChild: true, container, children }) }) });\n};\nTooltipPortal.displayName = PORTAL_NAME;\nvar CONTENT_NAME = \"TooltipContent\";\nvar TooltipContent = React.forwardRef(\n  (props, forwardedRef) => {\n    const portalContext = usePortalContext(CONTENT_NAME, props.__scopeTooltip);\n    const { forceMount = portalContext.forceMount, side = \"top\", ...contentProps } = props;\n    const context = useTooltipContext(CONTENT_NAME, props.__scopeTooltip);\n    return /* @__PURE__ */ jsx(Presence, { present: forceMount || context.open, children: context.disableHoverableContent ? /* @__PURE__ */ jsx(TooltipContentImpl, { side, ...contentProps, ref: forwardedRef }) : /* @__PURE__ */ jsx(TooltipContentHoverable, { side, ...contentProps, ref: forwardedRef }) });\n  }\n);\nvar TooltipContentHoverable = React.forwardRef((props, forwardedRef) => {\n  const context = useTooltipContext(CONTENT_NAME, props.__scopeTooltip);\n  const providerContext = useTooltipProviderContext(CONTENT_NAME, props.__scopeTooltip);\n  const ref = React.useRef(null);\n  const composedRefs = useComposedRefs(forwardedRef, ref);\n  const [pointerGraceArea, setPointerGraceArea] = React.useState(null);\n  const { trigger, onClose } = context;\n  const content = ref.current;\n  const { onPointerInTransitChange } = providerContext;\n  const handleRemoveGraceArea = React.useCallback(() => {\n    setPointerGraceArea(null);\n    onPointerInTransitChange(false);\n  }, [onPointerInTransitChange]);\n  const handleCreateGraceArea = React.useCallback(\n    (event, hoverTarget) => {\n      const currentTarget = event.currentTarget;\n      const exitPoint = { x: event.clientX, y: event.clientY };\n      const exitSide = getExitSideFromRect(exitPoint, currentTarget.getBoundingClientRect());\n      const paddedExitPoints = getPaddedExitPoints(exitPoint, exitSide);\n      const hoverTargetPoints = getPointsFromRect(hoverTarget.getBoundingClientRect());\n      const graceArea = getHull([...paddedExitPoints, ...hoverTargetPoints]);\n      setPointerGraceArea(graceArea);\n      onPointerInTransitChange(true);\n    },\n    [onPointerInTransitChange]\n  );\n  React.useEffect(() => {\n    return () => handleRemoveGraceArea();\n  }, [handleRemoveGraceArea]);\n  React.useEffect(() => {\n    if (trigger && content) {\n      const handleTriggerLeave = (event) => handleCreateGraceArea(event, content);\n      const handleContentLeave = (event) => handleCreateGraceArea(event, trigger);\n      trigger.addEventListener(\"pointerleave\", handleTriggerLeave);\n      content.addEventListener(\"pointerleave\", handleContentLeave);\n      return () => {\n        trigger.removeEventListener(\"pointerleave\", handleTriggerLeave);\n        content.removeEventListener(\"pointerleave\", handleContentLeave);\n      };\n    }\n  }, [trigger, content, handleCreateGraceArea, handleRemoveGraceArea]);\n  React.useEffect(() => {\n    if (pointerGraceArea) {\n      const handleTrackPointerGrace = (event) => {\n        const target = event.target;\n        const pointerPosition = { x: event.clientX, y: event.clientY };\n        const hasEnteredTarget = trigger?.contains(target) || content?.contains(target);\n        const isPointerOutsideGraceArea = !isPointInPolygon(pointerPosition, pointerGraceArea);\n        if (hasEnteredTarget) {\n          handleRemoveGraceArea();\n        } else if (isPointerOutsideGraceArea) {\n          handleRemoveGraceArea();\n          onClose();\n        }\n      };\n      document.addEventListener(\"pointermove\", handleTrackPointerGrace);\n      return () => document.removeEventListener(\"pointermove\", handleTrackPointerGrace);\n    }\n  }, [trigger, content, pointerGraceArea, onClose, handleRemoveGraceArea]);\n  return /* @__PURE__ */ jsx(TooltipContentImpl, { ...props, ref: composedRefs });\n});\nvar [VisuallyHiddenContentContextProvider, useVisuallyHiddenContentContext] = createTooltipContext(TOOLTIP_NAME, { isInside: false });\nvar TooltipContentImpl = React.forwardRef(\n  (props, forwardedRef) => {\n    const {\n      __scopeTooltip,\n      children,\n      \"aria-label\": ariaLabel,\n      onEscapeKeyDown,\n      onPointerDownOutside,\n      ...contentProps\n    } = props;\n    const context = useTooltipContext(CONTENT_NAME, __scopeTooltip);\n    const popperScope = usePopperScope(__scopeTooltip);\n    const { onClose } = context;\n    React.useEffect(() => {\n      document.addEventListener(TOOLTIP_OPEN, onClose);\n      return () => document.removeEventListener(TOOLTIP_OPEN, onClose);\n    }, [onClose]);\n    React.useEffect(() => {\n      if (context.trigger) {\n        const handleScroll = (event) => {\n          const target = event.target;\n          if (target?.contains(context.trigger)) onClose();\n        };\n        window.addEventListener(\"scroll\", handleScroll, { capture: true });\n        return () => window.removeEventListener(\"scroll\", handleScroll, { capture: true });\n      }\n    }, [context.trigger, onClose]);\n    return /* @__PURE__ */ jsx(\n      DismissableLayer,\n      {\n        asChild: true,\n        disableOutsidePointerEvents: false,\n        onEscapeKeyDown,\n        onPointerDownOutside,\n        onFocusOutside: (event) => event.preventDefault(),\n        onDismiss: onClose,\n        children: /* @__PURE__ */ jsxs(\n          PopperPrimitive.Content,\n          {\n            \"data-state\": context.stateAttribute,\n            ...popperScope,\n            ...contentProps,\n            ref: forwardedRef,\n            style: {\n              ...contentProps.style,\n              // re-namespace exposed content custom properties\n              ...{\n                \"--radix-tooltip-content-transform-origin\": \"var(--radix-popper-transform-origin)\",\n                \"--radix-tooltip-content-available-width\": \"var(--radix-popper-available-width)\",\n                \"--radix-tooltip-content-available-height\": \"var(--radix-popper-available-height)\",\n                \"--radix-tooltip-trigger-width\": \"var(--radix-popper-anchor-width)\",\n                \"--radix-tooltip-trigger-height\": \"var(--radix-popper-anchor-height)\"\n              }\n            },\n            children: [\n              /* @__PURE__ */ jsx(Slottable, { children }),\n              /* @__PURE__ */ jsx(VisuallyHiddenContentContextProvider, { scope: __scopeTooltip, isInside: true, children: /* @__PURE__ */ jsx(VisuallyHiddenPrimitive.Root, { id: context.contentId, role: \"tooltip\", children: ariaLabel || children }) })\n            ]\n          }\n        )\n      }\n    );\n  }\n);\nTooltipContent.displayName = CONTENT_NAME;\nvar ARROW_NAME = \"TooltipArrow\";\nvar TooltipArrow = React.forwardRef(\n  (props, forwardedRef) => {\n    const { __scopeTooltip, ...arrowProps } = props;\n    const popperScope = usePopperScope(__scopeTooltip);\n    const visuallyHiddenContentContext = useVisuallyHiddenContentContext(\n      ARROW_NAME,\n      __scopeTooltip\n    );\n    return visuallyHiddenContentContext.isInside ? null : /* @__PURE__ */ jsx(PopperPrimitive.Arrow, { ...popperScope, ...arrowProps, ref: forwardedRef });\n  }\n);\nTooltipArrow.displayName = ARROW_NAME;\nfunction getExitSideFromRect(point, rect) {\n  const top = Math.abs(rect.top - point.y);\n  const bottom = Math.abs(rect.bottom - point.y);\n  const right = Math.abs(rect.right - point.x);\n  const left = Math.abs(rect.left - point.x);\n  switch (Math.min(top, bottom, right, left)) {\n    case left:\n      return \"left\";\n    case right:\n      return \"right\";\n    case top:\n      return \"top\";\n    case bottom:\n      return \"bottom\";\n    default:\n      throw new Error(\"unreachable\");\n  }\n}\nfunction getPaddedExitPoints(exitPoint, exitSide, padding = 5) {\n  const paddedExitPoints = [];\n  switch (exitSide) {\n    case \"top\":\n      paddedExitPoints.push(\n        { x: exitPoint.x - padding, y: exitPoint.y + padding },\n        { x: exitPoint.x + padding, y: exitPoint.y + padding }\n      );\n      break;\n    case \"bottom\":\n      paddedExitPoints.push(\n        { x: exitPoint.x - padding, y: exitPoint.y - padding },\n        { x: exitPoint.x + padding, y: exitPoint.y - padding }\n      );\n      break;\n    case \"left\":\n      paddedExitPoints.push(\n        { x: exitPoint.x + padding, y: exitPoint.y - padding },\n        { x: exitPoint.x + padding, y: exitPoint.y + padding }\n      );\n      break;\n    case \"right\":\n      paddedExitPoints.push(\n        { x: exitPoint.x - padding, y: exitPoint.y - padding },\n        { x: exitPoint.x - padding, y: exitPoint.y + padding }\n      );\n      break;\n  }\n  return paddedExitPoints;\n}\nfunction getPointsFromRect(rect) {\n  const { top, right, bottom, left } = rect;\n  return [\n    { x: left, y: top },\n    { x: right, y: top },\n    { x: right, y: bottom },\n    { x: left, y: bottom }\n  ];\n}\nfunction isPointInPolygon(point, polygon) {\n  const { x, y } = point;\n  let inside = false;\n  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {\n    const xi = polygon[i].x;\n    const yi = polygon[i].y;\n    const xj = polygon[j].x;\n    const yj = polygon[j].y;\n    const intersect = yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi;\n    if (intersect) inside = !inside;\n  }\n  return inside;\n}\nfunction getHull(points) {\n  const newPoints = points.slice();\n  newPoints.sort((a, b) => {\n    if (a.x < b.x) return -1;\n    else if (a.x > b.x) return 1;\n    else if (a.y < b.y) return -1;\n    else if (a.y > b.y) return 1;\n    else return 0;\n  });\n  return getHullPresorted(newPoints);\n}\nfunction getHullPresorted(points) {\n  if (points.length <= 1) return points.slice();\n  const upperHull = [];\n  for (let i = 0; i < points.length; i++) {\n    const p = points[i];\n    while (upperHull.length >= 2) {\n      const q = upperHull[upperHull.length - 1];\n      const r = upperHull[upperHull.length - 2];\n      if ((q.x - r.x) * (p.y - r.y) >= (q.y - r.y) * (p.x - r.x)) upperHull.pop();\n      else break;\n    }\n    upperHull.push(p);\n  }\n  upperHull.pop();\n  const lowerHull = [];\n  for (let i = points.length - 1; i >= 0; i--) {\n    const p = points[i];\n    while (lowerHull.length >= 2) {\n      const q = lowerHull[lowerHull.length - 1];\n      const r = lowerHull[lowerHull.length - 2];\n      if ((q.x - r.x) * (p.y - r.y) >= (q.y - r.y) * (p.x - r.x)) lowerHull.pop();\n      else break;\n    }\n    lowerHull.push(p);\n  }\n  lowerHull.pop();\n  if (upperHull.length === 1 && lowerHull.length === 1 && upperHull[0].x === lowerHull[0].x && upperHull[0].y === lowerHull[0].y) {\n    return upperHull;\n  } else {\n    return upperHull.concat(lowerHull);\n  }\n}\nvar Provider = TooltipProvider;\nvar Root3 = Tooltip;\nvar Trigger = TooltipTrigger;\nvar Portal = TooltipPortal;\nvar Content2 = TooltipContent;\nvar Arrow2 = TooltipArrow;\nexport {\n  Arrow2 as Arrow,\n  Content2 as Content,\n  Portal,\n  Provider,\n  Root3 as Root,\n  Tooltip,\n  TooltipArrow,\n  TooltipContent,\n  TooltipPortal,\n  TooltipProvider,\n  TooltipTrigger,\n  Trigger,\n  createTooltipScope\n};\n//# sourceMappingURL=index.mjs.map\n","'use client'\n\nimport * as React from 'react'\nimport * as TooltipPrimitive from '@radix-ui/react-tooltip'\n\nimport { cn } from '@/lib/utils'\n\nfunction TooltipProvider({\n  delayDuration = 0,\n  ...props\n}: React.ComponentProps<typeof TooltipPrimitive.Provider>) {\n  return (\n    <TooltipPrimitive.Provider\n      data-slot=\"tooltip-provider\"\n      delayDuration={delayDuration}\n      {...props}\n    />\n  )\n}\n\nfunction Tooltip({\n  ...props\n}: React.ComponentProps<typeof TooltipPrimitive.Root>) {\n  return (\n    <TooltipProvider>\n      <TooltipPrimitive.Root data-slot=\"tooltip\" {...props} />\n    </TooltipProvider>\n  )\n}\n\nfunction TooltipTrigger({\n  ...props\n}: React.ComponentProps<typeof TooltipPrimitive.Trigger>) {\n  return <TooltipPrimitive.Trigger data-slot=\"tooltip-trigger\" {...props} />\n}\n\nfunction TooltipContent({\n  className,\n  sideOffset = 0,\n  children,\n  ...props\n}: React.ComponentProps<typeof TooltipPrimitive.Content>) {\n  return (\n    <TooltipPrimitive.Portal>\n      <TooltipPrimitive.Content\n        data-slot=\"tooltip-content\"\n        sideOffset={sideOffset}\n        className={cn(\n          'bg-foreground text-background animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-fit origin-(--radix-tooltip-content-transform-origin) rounded-md px-3 py-1.5 text-xs text-balance',\n          className,\n        )}\n        {...props}\n      >\n        {children}\n        <TooltipPrimitive.Arrow className=\"bg-foreground fill-foreground z-50 size-2.5 translate-y-[calc(-50%_-_2px)] rotate-45 rounded-[2px]\" />\n      </TooltipPrimitive.Content>\n    </TooltipPrimitive.Portal>\n  )\n}\n\nexport { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider }\n","'use client'\n\nimport * as React from 'react'\nimport { Slot } from '@radix-ui/react-slot'\nimport { cva, VariantProps } from 'class-variance-authority'\nimport { PanelLeftIcon } from 'lucide-react'\n\nimport { useIsMobile } from '@/hooks/use-mobile'\nimport { cn } from '@/lib/utils'\nimport { Button } from '@/components/ui/button'\nimport { Input } from '@/components/ui/input'\nimport { Separator } from '@/components/ui/separator'\nimport {\n  Sheet,\n  SheetContent,\n  SheetDescription,\n  SheetHeader,\n  SheetTitle,\n} from '@/components/ui/sheet'\nimport { Skeleton } from '@/components/ui/skeleton'\nimport {\n  Tooltip,\n  TooltipContent,\n  TooltipProvider,\n  TooltipTrigger,\n} from '@/components/ui/tooltip'\n\nconst SIDEBAR_COOKIE_NAME = 'sidebar_state'\nconst SIDEBAR_COOKIE_MAX_AGE = 60 * 60 * 24 * 7\nconst SIDEBAR_WIDTH = '16rem'\nconst SIDEBAR_WIDTH_MOBILE = '18rem'\nconst SIDEBAR_WIDTH_ICON = '3rem'\nconst SIDEBAR_KEYBOARD_SHORTCUT = 'b'\n\ntype SidebarContextProps = {\n  state: 'expanded' | 'collapsed'\n  open: boolean\n  setOpen: (open: boolean) => void\n  openMobile: boolean\n  setOpenMobile: (open: boolean) => void\n  isMobile: boolean\n  toggleSidebar: () => void\n}\n\nconst SidebarContext = React.createContext<SidebarContextProps | null>(null)\n\nfunction useSidebar() {\n  const context = React.useContext(SidebarContext)\n  if (!context) {\n    throw new Error('useSidebar must be used within a SidebarProvider.')\n  }\n\n  return context\n}\n\nfunction SidebarProvider({\n  defaultOpen = true,\n  open: openProp,\n  onOpenChange: setOpenProp,\n  className,\n  style,\n  children,\n  ...props\n}: React.ComponentProps<'div'> & {\n  defaultOpen?: boolean\n  open?: boolean\n  onOpenChange?: (open: boolean) => void\n}) {\n  const isMobile = useIsMobile()\n  const [openMobile, setOpenMobile] = React.useState(false)\n\n  // This is the internal state of the sidebar.\n  // We use openProp and setOpenProp for control from outside the component.\n  const [_open, _setOpen] = React.useState(defaultOpen)\n  const open = openProp ?? _open\n  const setOpen = React.useCallback(\n    (value: boolean | ((value: boolean) => boolean)) => {\n      const openState = typeof value === 'function' ? value(open) : value\n      if (setOpenProp) {\n        setOpenProp(openState)\n      } else {\n        _setOpen(openState)\n      }\n\n      // This sets the cookie to keep the sidebar state.\n      document.cookie = `${SIDEBAR_COOKIE_NAME}=${openState}; path=/; max-age=${SIDEBAR_COOKIE_MAX_AGE}`\n    },\n    [setOpenProp, open],\n  )\n\n  // Helper to toggle the sidebar.\n  const toggleSidebar = React.useCallback(() => {\n    return isMobile ? setOpenMobile((open) => !open) : setOpen((open) => !open)\n  }, [isMobile, setOpen, setOpenMobile])\n\n  // Adds a keyboard shortcut to toggle the sidebar.\n  React.useEffect(() => {\n    const handleKeyDown = (event: KeyboardEvent) => {\n      if (\n        event.key === SIDEBAR_KEYBOARD_SHORTCUT &&\n        (event.metaKey || event.ctrlKey)\n      ) {\n        event.preventDefault()\n        toggleSidebar()\n      }\n    }\n\n    window.addEventListener('keydown', handleKeyDown)\n    return () => window.removeEventListener('keydown', handleKeyDown)\n  }, [toggleSidebar])\n\n  // We add a state so that we can do data-state=\"expanded\" or \"collapsed\".\n  // This makes it easier to style the sidebar with Tailwind classes.\n  const state = open ? 'expanded' : 'collapsed'\n\n  const contextValue = React.useMemo<SidebarContextProps>(\n    () => ({\n      state,\n      open,\n      setOpen,\n      isMobile,\n      openMobile,\n      setOpenMobile,\n      toggleSidebar,\n    }),\n    [state, open, setOpen, isMobile, openMobile, setOpenMobile, toggleSidebar],\n  )\n\n  return (\n    <SidebarContext.Provider value={contextValue}>\n      <TooltipProvider delayDuration={0}>\n        <div\n          data-slot=\"sidebar-wrapper\"\n          style={\n            {\n              '--sidebar-width': SIDEBAR_WIDTH,\n              '--sidebar-width-icon': SIDEBAR_WIDTH_ICON,\n              ...style,\n            } as React.CSSProperties\n          }\n          className={cn(\n            'group/sidebar-wrapper has-data-[variant=inset]:bg-sidebar flex min-h-svh w-full',\n            className,\n          )}\n          {...props}\n        >\n          {children}\n        </div>\n      </TooltipProvider>\n    </SidebarContext.Provider>\n  )\n}\n\nfunction Sidebar({\n  side = 'left',\n  variant = 'sidebar',\n  collapsible = 'offcanvas',\n  className,\n  children,\n  ...props\n}: React.ComponentProps<'div'> & {\n  side?: 'left' | 'right'\n  variant?: 'sidebar' | 'floating' | 'inset'\n  collapsible?: 'offcanvas' | 'icon' | 'none'\n}) {\n  const { isMobile, state, openMobile, setOpenMobile } = useSidebar()\n\n  if (collapsible === 'none') {\n    return (\n      <div\n        data-slot=\"sidebar\"\n        className={cn(\n          'bg-sidebar text-sidebar-foreground flex h-full w-(--sidebar-width) flex-col',\n          className,\n        )}\n        {...props}\n      >\n        {children}\n      </div>\n    )\n  }\n\n  if (isMobile) {\n    return (\n      <Sheet open={openMobile} onOpenChange={setOpenMobile} {...props}>\n        <SheetContent\n          data-sidebar=\"sidebar\"\n          data-slot=\"sidebar\"\n          data-mobile=\"true\"\n          className=\"bg-sidebar text-sidebar-foreground w-(--sidebar-width) p-0 [&>button]:hidden\"\n          style={\n            {\n              '--sidebar-width': SIDEBAR_WIDTH_MOBILE,\n            } as React.CSSProperties\n          }\n          side={side}\n        >\n          <SheetHeader className=\"sr-only\">\n            <SheetTitle>Sidebar</SheetTitle>\n            <SheetDescription>Displays the mobile sidebar.</SheetDescription>\n          </SheetHeader>\n          <div className=\"flex h-full w-full flex-col\">{children}</div>\n        </SheetContent>\n      </Sheet>\n    )\n  }\n\n  return (\n    <div\n      className=\"group peer text-sidebar-foreground hidden md:block\"\n      data-state={state}\n      data-collapsible={state === 'collapsed' ? collapsible : ''}\n      data-variant={variant}\n      data-side={side}\n      data-slot=\"sidebar\"\n    >\n      {/* This is what handles the sidebar gap on desktop */}\n      <div\n        data-slot=\"sidebar-gap\"\n        className={cn(\n          'relative w-(--sidebar-width) bg-transparent transition-[width] duration-200 ease-linear',\n          'group-data-[collapsible=offcanvas]:w-0',\n          'group-data-[side=right]:rotate-180',\n          variant === 'floating' || variant === 'inset'\n            ? 'group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)+(--spacing(4)))]'\n            : 'group-data-[collapsible=icon]:w-(--sidebar-width-icon)',\n        )}\n      />\n      <div\n        data-slot=\"sidebar-container\"\n        className={cn(\n          'fixed inset-y-0 z-10 hidden h-svh w-(--sidebar-width) transition-[left,right,width] duration-200 ease-linear md:flex',\n          side === 'left'\n            ? 'left-0 group-data-[collapsible=offcanvas]:left-[calc(var(--sidebar-width)*-1)]'\n            : 'right-0 group-data-[collapsible=offcanvas]:right-[calc(var(--sidebar-width)*-1)]',\n          // Adjust the padding for floating and inset variants.\n          variant === 'floating' || variant === 'inset'\n            ? 'p-2 group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)+(--spacing(4))+2px)]'\n            : 'group-data-[collapsible=icon]:w-(--sidebar-width-icon) group-data-[side=left]:border-r group-data-[side=right]:border-l',\n          className,\n        )}\n        {...props}\n      >\n        <div\n          data-sidebar=\"sidebar\"\n          data-slot=\"sidebar-inner\"\n          className=\"bg-sidebar group-data-[variant=floating]:border-sidebar-border flex h-full w-full flex-col group-data-[variant=floating]:rounded-lg group-data-[variant=floating]:border group-data-[variant=floating]:shadow-sm\"\n        >\n          {children}\n        </div>\n      </div>\n    </div>\n  )\n}\n\nfunction SidebarTrigger({\n  className,\n  onClick,\n  ...props\n}: React.ComponentProps<typeof Button>) {\n  const { toggleSidebar } = useSidebar()\n\n  return (\n    <Button\n      data-sidebar=\"trigger\"\n      data-slot=\"sidebar-trigger\"\n      variant=\"ghost\"\n      size=\"icon\"\n      className={cn('size-7', className)}\n      onClick={(event) => {\n        onClick?.(event)\n        toggleSidebar()\n      }}\n      {...props}\n    >\n      <PanelLeftIcon />\n      <span className=\"sr-only\">Toggle Sidebar</span>\n    </Button>\n  )\n}\n\nfunction SidebarRail({ className, ...props }: React.ComponentProps<'button'>) {\n  const { toggleSidebar } = useSidebar()\n\n  return (\n    <button\n      data-sidebar=\"rail\"\n      data-slot=\"sidebar-rail\"\n      aria-label=\"Toggle Sidebar\"\n      tabIndex={-1}\n      onClick={toggleSidebar}\n      title=\"Toggle Sidebar\"\n      className={cn(\n        'hover:after:bg-sidebar-border absolute inset-y-0 z-20 hidden w-4 -translate-x-1/2 transition-all ease-linear group-data-[side=left]:-right-4 group-data-[side=right]:left-0 after:absolute after:inset-y-0 after:left-1/2 after:w-[2px] sm:flex',\n        'in-data-[side=left]:cursor-w-resize in-data-[side=right]:cursor-e-resize',\n        '[[data-side=left][data-state=collapsed]_&]:cursor-e-resize [[data-side=right][data-state=collapsed]_&]:cursor-w-resize',\n        'hover:group-data-[collapsible=offcanvas]:bg-sidebar group-data-[collapsible=offcanvas]:translate-x-0 group-data-[collapsible=offcanvas]:after:left-full',\n        '[[data-side=left][data-collapsible=offcanvas]_&]:-right-2',\n        '[[data-side=right][data-collapsible=offcanvas]_&]:-left-2',\n        className,\n      )}\n      {...props}\n    />\n  )\n}\n\nfunction SidebarInset({ className, ...props }: React.ComponentProps<'main'>) {\n  return (\n    <main\n      data-slot=\"sidebar-inset\"\n      className={cn(\n        'bg-background relative flex w-full flex-1 flex-col',\n        'md:peer-data-[variant=inset]:m-2 md:peer-data-[variant=inset]:ml-0 md:peer-data-[variant=inset]:rounded-xl md:peer-data-[variant=inset]:shadow-sm md:peer-data-[variant=inset]:peer-data-[state=collapsed]:ml-2',\n        className,\n      )}\n      {...props}\n    />\n  )\n}\n\nfunction SidebarInput({\n  className,\n  ...props\n}: React.ComponentProps<typeof Input>) {\n  return (\n    <Input\n      data-slot=\"sidebar-input\"\n      data-sidebar=\"input\"\n      className={cn('bg-background h-8 w-full shadow-none', className)}\n      {...props}\n    />\n  )\n}\n\nfunction SidebarHeader({ className, ...props }: React.ComponentProps<'div'>) {\n  return (\n    <div\n      data-slot=\"sidebar-header\"\n      data-sidebar=\"header\"\n      className={cn('flex flex-col gap-2 p-2', className)}\n      {...props}\n    />\n  )\n}\n\nfunction SidebarFooter({ className, ...props }: React.ComponentProps<'div'>) {\n  return (\n    <div\n      data-slot=\"sidebar-footer\"\n      data-sidebar=\"footer\"\n      className={cn('flex flex-col gap-2 p-2', className)}\n      {...props}\n    />\n  )\n}\n\nfunction SidebarSeparator({\n  className,\n  ...props\n}: React.ComponentProps<typeof Separator>) {\n  return (\n    <Separator\n      data-slot=\"sidebar-separator\"\n      data-sidebar=\"separator\"\n      className={cn('bg-sidebar-border mx-2 w-auto', className)}\n      {...props}\n    />\n  )\n}\n\nfunction SidebarContent({ className, ...props }: React.ComponentProps<'div'>) {\n  return (\n    <div\n      data-slot=\"sidebar-content\"\n      data-sidebar=\"content\"\n      className={cn(\n        'flex min-h-0 flex-1 flex-col gap-2 overflow-auto group-data-[collapsible=icon]:overflow-hidden',\n        className,\n      )}\n      {...props}\n    />\n  )\n}\n\nfunction SidebarGroup({ className, ...props }: React.ComponentProps<'div'>) {\n  return (\n    <div\n      data-slot=\"sidebar-group\"\n      data-sidebar=\"group\"\n      className={cn('relative flex w-full min-w-0 flex-col p-2', className)}\n      {...props}\n    />\n  )\n}\n\nfunction SidebarGroupLabel({\n  className,\n  asChild = false,\n  ...props\n}: React.ComponentProps<'div'> & { asChild?: boolean }) {\n  const Comp = asChild ? Slot : 'div'\n\n  return (\n    <Comp\n      data-slot=\"sidebar-group-label\"\n      data-sidebar=\"group-label\"\n      className={cn(\n        'text-sidebar-foreground/70 ring-sidebar-ring flex h-8 shrink-0 items-center rounded-md px-2 text-xs font-medium outline-hidden transition-[margin,opacity] duration-200 ease-linear focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0',\n        'group-data-[collapsible=icon]:-mt-8 group-data-[collapsible=icon]:opacity-0',\n        className,\n      )}\n      {...props}\n    />\n  )\n}\n\nfunction SidebarGroupAction({\n  className,\n  asChild = false,\n  ...props\n}: React.ComponentProps<'button'> & { asChild?: boolean }) {\n  const Comp = asChild ? Slot : 'button'\n\n  return (\n    <Comp\n      data-slot=\"sidebar-group-action\"\n      data-sidebar=\"group-action\"\n      className={cn(\n        'text-sidebar-foreground ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground absolute top-3.5 right-3 flex aspect-square w-5 items-center justify-center rounded-md p-0 outline-hidden transition-transform focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0',\n        // Increases the hit area of the button on mobile.\n        'after:absolute after:-inset-2 md:after:hidden',\n        'group-data-[collapsible=icon]:hidden',\n        className,\n      )}\n      {...props}\n    />\n  )\n}\n\nfunction SidebarGroupContent({\n  className,\n  ...props\n}: React.ComponentProps<'div'>) {\n  return (\n    <div\n      data-slot=\"sidebar-group-content\"\n      data-sidebar=\"group-content\"\n      className={cn('w-full text-sm', className)}\n      {...props}\n    />\n  )\n}\n\nfunction SidebarMenu({ className, ...props }: React.ComponentProps<'ul'>) {\n  return (\n    <ul\n      data-slot=\"sidebar-menu\"\n      data-sidebar=\"menu\"\n      className={cn('flex w-full min-w-0 flex-col gap-1', className)}\n      {...props}\n    />\n  )\n}\n\nfunction SidebarMenuItem({ className, ...props }: React.ComponentProps<'li'>) {\n  return (\n    <li\n      data-slot=\"sidebar-menu-item\"\n      data-sidebar=\"menu-item\"\n      className={cn('group/menu-item relative', className)}\n      {...props}\n    />\n  )\n}\n\nconst sidebarMenuButtonVariants = cva(\n  'peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left text-sm outline-hidden ring-sidebar-ring transition-[width,height,padding] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-data-[sidebar=menu-action]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:size-8! group-data-[collapsible=icon]:p-2! [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0',\n  {\n    variants: {\n      variant: {\n        default: 'hover:bg-sidebar-accent hover:text-sidebar-accent-foreground',\n        outline:\n          'bg-background shadow-[0_0_0_1px_hsl(var(--sidebar-border))] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground hover:shadow-[0_0_0_1px_hsl(var(--sidebar-accent))]',\n      },\n      size: {\n        default: 'h-8 text-sm',\n        sm: 'h-7 text-xs',\n        lg: 'h-12 text-sm group-data-[collapsible=icon]:p-0!',\n      },\n    },\n    defaultVariants: {\n      variant: 'default',\n      size: 'default',\n    },\n  },\n)\n\nfunction SidebarMenuButton({\n  asChild = false,\n  isActive = false,\n  variant = 'default',\n  size = 'default',\n  tooltip,\n  className,\n  ...props\n}: React.ComponentProps<'button'> & {\n  asChild?: boolean\n  isActive?: boolean\n  tooltip?: string | React.ComponentProps<typeof TooltipContent>\n} & VariantProps<typeof sidebarMenuButtonVariants>) {\n  const Comp = asChild ? Slot : 'button'\n  const { isMobile, state } = useSidebar()\n\n  const button = (\n    <Comp\n      data-slot=\"sidebar-menu-button\"\n      data-sidebar=\"menu-button\"\n      data-size={size}\n      data-active={isActive}\n      className={cn(sidebarMenuButtonVariants({ variant, size }), className)}\n      {...props}\n    />\n  )\n\n  if (!tooltip) {\n    return button\n  }\n\n  if (typeof tooltip === 'string') {\n    tooltip = {\n      children: tooltip,\n    }\n  }\n\n  return (\n    <Tooltip>\n      <TooltipTrigger asChild>{button}</TooltipTrigger>\n      <TooltipContent\n        side=\"right\"\n        align=\"center\"\n        hidden={state !== 'collapsed' || isMobile}\n        {...tooltip}\n      />\n    </Tooltip>\n  )\n}\n\nfunction SidebarMenuAction({\n  className,\n  asChild = false,\n  showOnHover = false,\n  ...props\n}: React.ComponentProps<'button'> & {\n  asChild?: boolean\n  showOnHover?: boolean\n}) {\n  const Comp = asChild ? Slot : 'button'\n\n  return (\n    <Comp\n      data-slot=\"sidebar-menu-action\"\n      data-sidebar=\"menu-action\"\n      className={cn(\n        'text-sidebar-foreground ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground peer-hover/menu-button:text-sidebar-accent-foreground absolute top-1.5 right-1 flex aspect-square w-5 items-center justify-center rounded-md p-0 outline-hidden transition-transform focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0',\n        // Increases the hit area of the button on mobile.\n        'after:absolute after:-inset-2 md:after:hidden',\n        'peer-data-[size=sm]/menu-button:top-1',\n        'peer-data-[size=default]/menu-button:top-1.5',\n        'peer-data-[size=lg]/menu-button:top-2.5',\n        'group-data-[collapsible=icon]:hidden',\n        showOnHover &&\n          'peer-data-[active=true]/menu-button:text-sidebar-accent-foreground group-focus-within/menu-item:opacity-100 group-hover/menu-item:opacity-100 data-[state=open]:opacity-100 md:opacity-0',\n        className,\n      )}\n      {...props}\n    />\n  )\n}\n\nfunction SidebarMenuBadge({\n  className,\n  ...props\n}: React.ComponentProps<'div'>) {\n  return (\n    <div\n      data-slot=\"sidebar-menu-badge\"\n      data-sidebar=\"menu-badge\"\n      className={cn(\n        'text-sidebar-foreground pointer-events-none absolute right-1 flex h-5 min-w-5 items-center justify-center rounded-md px-1 text-xs font-medium tabular-nums select-none',\n        'peer-hover/menu-button:text-sidebar-accent-foreground peer-data-[active=true]/menu-button:text-sidebar-accent-foreground',\n        'peer-data-[size=sm]/menu-button:top-1',\n        'peer-data-[size=default]/menu-button:top-1.5',\n        'peer-data-[size=lg]/menu-button:top-2.5',\n        'group-data-[collapsible=icon]:hidden',\n        className,\n      )}\n      {...props}\n    />\n  )\n}\n\nfunction SidebarMenuSkeleton({\n  className,\n  showIcon = false,\n  ...props\n}: React.ComponentProps<'div'> & {\n  showIcon?: boolean\n}) {\n  // Random width between 50 to 90%.\n  const width = React.useMemo(() => {\n    return `${Math.floor(Math.random() * 40) + 50}%`\n  }, [])\n\n  return (\n    <div\n      data-slot=\"sidebar-menu-skeleton\"\n      data-sidebar=\"menu-skeleton\"\n      className={cn('flex h-8 items-center gap-2 rounded-md px-2', className)}\n      {...props}\n    >\n      {showIcon && (\n        <Skeleton\n          className=\"size-4 rounded-md\"\n          data-sidebar=\"menu-skeleton-icon\"\n        />\n      )}\n      <Skeleton\n        className=\"h-4 max-w-(--skeleton-width) flex-1\"\n        data-sidebar=\"menu-skeleton-text\"\n        style={\n          {\n            '--skeleton-width': width,\n          } as React.CSSProperties\n        }\n      />\n    </div>\n  )\n}\n\nfunction SidebarMenuSub({ className, ...props }: React.ComponentProps<'ul'>) {\n  return (\n    <ul\n      data-slot=\"sidebar-menu-sub\"\n      data-sidebar=\"menu-sub\"\n      className={cn(\n        'border-sidebar-border mx-3.5 flex min-w-0 translate-x-px flex-col gap-1 border-l px-2.5 py-0.5',\n        'group-data-[collapsible=icon]:hidden',\n        className,\n      )}\n      {...props}\n    />\n  )\n}\n\nfunction SidebarMenuSubItem({\n  className,\n  ...props\n}: React.ComponentProps<'li'>) {\n  return (\n    <li\n      data-slot=\"sidebar-menu-sub-item\"\n      data-sidebar=\"menu-sub-item\"\n      className={cn('group/menu-sub-item relative', className)}\n      {...props}\n    />\n  )\n}\n\nfunction SidebarMenuSubButton({\n  asChild = false,\n  size = 'md',\n  isActive = false,\n  className,\n  ...props\n}: React.ComponentProps<'a'> & {\n  asChild?: boolean\n  size?: 'sm' | 'md'\n  isActive?: boolean\n}) {\n  const Comp = asChild ? Slot : 'a'\n\n  return (\n    <Comp\n      data-slot=\"sidebar-menu-sub-button\"\n      data-sidebar=\"menu-sub-button\"\n      data-size={size}\n      data-active={isActive}\n      className={cn(\n        'text-sidebar-foreground ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground active:bg-sidebar-accent active:text-sidebar-accent-foreground [&>svg]:text-sidebar-accent-foreground flex h-7 min-w-0 -translate-x-px items-center gap-2 overflow-hidden rounded-md px-2 outline-hidden focus-visible:ring-2 disabled:pointer-events-none disabled:opacity-50 aria-disabled:pointer-events-none aria-disabled:opacity-50 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0',\n        'data-[active=true]:bg-sidebar-accent data-[active=true]:text-sidebar-accent-foreground',\n        size === 'sm' && 'text-xs',\n        size === 'md' && 'text-sm',\n        'group-data-[collapsible=icon]:hidden',\n        className,\n      )}\n      {...props}\n    />\n  )\n}\n\nexport {\n  Sidebar,\n  SidebarContent,\n  SidebarFooter,\n  SidebarGroup,\n  SidebarGroupAction,\n  SidebarGroupContent,\n  SidebarGroupLabel,\n  SidebarHeader,\n  SidebarInput,\n  SidebarInset,\n  SidebarMenu,\n  SidebarMenuAction,\n  SidebarMenuBadge,\n  SidebarMenuButton,\n  SidebarMenuItem,\n  SidebarMenuSkeleton,\n  SidebarMenuSub,\n  SidebarMenuSubButton,\n  SidebarMenuSubItem,\n  SidebarProvider,\n  SidebarRail,\n  SidebarSeparator,\n  SidebarTrigger,\n  useSidebar,\n}\n","\"use client\"\r\nimport Image from \"next/image\"\r\n\r\nexport function DashboardNavbar() {\r\n  return (\r\n    <nav className=\"fixed top-0 left-0 right-0 z-50 bg-white border-b border-gray-200 shadow-sm h-20 flex items-center\">\r\n      <div className=\"px-4 w-full flex items-center justify-between\">\r\n        {/* Left: Banner + separator + GITAM logo */}\r\n        <div className=\"flex items-center gap-2\">\r\n          <Image\r\n            src=\"/sih_banner.png\"\r\n            alt=\"Smart India Hackathon 2025 Banner\"\r\n            width={320}\r\n            height={70}\r\n            className=\"h-14 w-auto object-contain\"\r\n            priority\r\n          />\r\n          <span className=\"h-10 w-px bg-gray-300\" />\r\n          <Image\r\n            src=\"/gitam_logo.png\"\r\n            alt=\"GITAM Logo\"\r\n            width={130}\r\n            height={70}\r\n            className=\"h-14 w-auto object-contain\"\r\n            priority\r\n          />\r\n        </div>\r\n        {/* Right: Title cluster */}\r\n        <div className=\"flex flex-col text-right\">\r\n          <h1 className=\"text-lg font-extrabold tracking-tight text-[#002449] leading-5\">\r\n            SIH <span className=\"text-[#f75700]\">2025</span> Grand Final\r\n          </h1>\r\n          <div className=\"mt-1 flex items-center justify-center gap-2\">\r\n            <span className=\"h-px w-6 bg-[#f75700]\" />\r\n            <span className=\"text-[14px] font-medium text-gray-500 uppercase tracking-wider\">GITAM</span>\r\n            <span className=\"h-px w-6 bg-[#078e31]\" />\r\n          </div>\r\n        </div>\r\n      </div>\r\n    </nav>\r\n  )\r\n}\r\n","\"use client\"\r\n\r\nimport React, { useMemo, useCallback } from \"react\"\r\nimport Link from \"next/link\"\r\nimport { usePathname, useRouter } from \"next/navigation\"\r\nimport { authService } from \"@/lib/auth-service\"\r\nimport {\r\n  SidebarProvider,\r\n  Sidebar,\r\n  SidebarHeader,\r\n  SidebarContent,\r\n  SidebarFooter,\r\n  SidebarInset,\r\n  SidebarMenu,\r\n  SidebarMenuItem,\r\n  SidebarMenuButton,\r\n  SidebarMenuBadge,\r\n  SidebarSeparator,\r\n  SidebarTrigger,\r\n} from \"@/components/ui/sidebar\"\r\nimport { DashboardNavbar } from \"@/components/navigation/dashboard-navbar\"\r\nimport { Users, FileText, PlusCircle, LayoutDashboard, ListTodo, Layers, LogOut, Boxes, Network } from \"lucide-react\"\r\n\r\ninterface DashboardShellProps {\r\n  children: React.ReactNode\r\n}\r\n\r\nexport function DashboardShell({ children }: DashboardShellProps) {\r\n  // Retrieve current user client-side; returns null on server.\r\n  const user = authService.getCurrentUser()\r\n  const pathname = usePathname()\r\n  const router = useRouter()\r\n\r\n  const role: \"leader\" | \"poc\" | \"admin\" | null = user?.is_admin\r\n    ? \"admin\"\r\n    : user?.is_poc\r\n      ? \"poc\"\r\n      : user\r\n        ? \"leader\"\r\n        : null\r\n\r\n  const navItems = useMemo(() => {\r\n    if (role === \"admin\") {\r\n      return [\r\n        { href: \"/dashboard\", label: \"Admin Dashboard\", icon: <LayoutDashboard /> },\r\n        { href: \"/queue\", label: \"Global Queue\", icon: <Network /> },\r\n        { href: \"/requests\", label: \"All Requests\", icon: <Boxes /> },\r\n      ]\r\n    }\r\n    if (role === \"poc\") {\r\n      return [\r\n        { href: \"/dashboard\", label: \"POC Dashboard\", icon: <LayoutDashboard /> },\r\n        { href: \"/queue\", label: \"Virtual Queue\", icon: <ListTodo /> },\r\n      ]\r\n    }\r\n    // leader default\r\n    return [\r\n      { href: \"/dashboard\", label: \"Dashboard\", icon: <LayoutDashboard /> },\r\n      { href: \"/requests\", label: \"My Requests\", icon: <FileText /> },\r\n      { href: \"/requests/new\", label: \"New Request\", icon: <PlusCircle /> },\r\n    ]\r\n  }, [role])\r\n\r\n  const isActive = useCallback(\r\n    (href: string) => {\r\n      if (href === \"/\") return pathname === href\r\n      if (href === \"/requests\") return pathname === \"/requests\"\r\n      return pathname.startsWith(href)\r\n    },\r\n    [pathname],\r\n  )\r\n\r\n  const handleLogout = async () => {\r\n    await authService.logout()\r\n    router.push(\"/login\")\r\n  }\r\n\r\n  return (\r\n    <SidebarProvider className=\"bg-white\">\r\n      <DashboardNavbar />\r\n      <Sidebar collapsible=\"offcanvas\" className=\"border-r border-gray-200 mt-20\">\r\n        <SidebarHeader>\r\n          <div className=\"px-3 py-3\">\r\n            <h1 className=\"text-base font-bold tracking-tight\" style={{ color: \"#002449\" }}>\r\n              SIH Portal\r\n            </h1>\r\n            <p className=\"text-[11px] font-medium\" style={{ color: \"#007367\" }} suppressHydrationWarning>\r\n              {role === \"admin\"\r\n                ? \"Administrator\"\r\n                : role === \"poc\"\r\n                  ? \"POC\"\r\n                  : role === \"leader\"\r\n                    ? \"Team Leader\"\r\n                    : \"Guest\"}\r\n            </p>\r\n            <p className=\"text-[11px] mt-1 text-muted-foreground\" suppressHydrationWarning>\r\n              {user?.email || \"guest@example.com\"}\r\n            </p>\r\n          </div>\r\n        </SidebarHeader>\r\n        <SidebarContent>\r\n          <SidebarMenu>\r\n            {navItems.map((item) => (\r\n              <SidebarMenuItem key={item.href}>\r\n                <Link href={item.href}>\r\n                  <SidebarMenuButton asChild isActive={isActive(item.href)}>\r\n                    <span className=\"flex items-center gap-2\">\r\n                      {item.icon}\r\n                      <span>{item.label}</span>\r\n                    </span>\r\n                  </SidebarMenuButton>\r\n                </Link>\r\n                {item.href === \"/queue\" && role !== \"leader\" && <SidebarMenuBadge>Live</SidebarMenuBadge>}\r\n              </SidebarMenuItem>\r\n            ))}\r\n            {/* Inline Logout for visibility (remove nested button) */}\r\n            <SidebarMenuItem>\r\n              <SidebarMenuButton\r\n                isActive={false}\r\n                className=\"justify-between\"\r\n                aria-label=\"Logout\"\r\n                onClick={handleLogout}\r\n              >\r\n                <span className=\"flex items-center gap-2\">\r\n                  <LogOut className=\"text-[#002449]\" />\r\n                  <span className=\"font-semibold text-[#002449]\">Logout</span>\r\n                </span>\r\n              </SidebarMenuButton>\r\n            </SidebarMenuItem>\r\n          </SidebarMenu>\r\n          <SidebarSeparator />\r\n          <SidebarMenu>\r\n            {role === \"leader\" && (\r\n              <SidebarMenuItem>\r\n                <Link href=\"/dashboard\">\r\n                  <SidebarMenuButton asChild isActive={isActive(\"/dashboard\")}>Team Overview</SidebarMenuButton>\r\n                </Link>\r\n              </SidebarMenuItem>\r\n            )}\r\n            {role === \"poc\" && (\r\n              <SidebarMenuItem>\r\n                <Link href=\"/dashboard\">\r\n                  <SidebarMenuButton asChild isActive={isActive(\"/dashboard\")}>Assigned Teams</SidebarMenuButton>\r\n                </Link>\r\n              </SidebarMenuItem>\r\n            )}\r\n          </SidebarMenu>\r\n        </SidebarContent>\r\n        <SidebarFooter>\r\n          <SidebarMenu>\r\n            <SidebarMenuItem>\r\n              <SidebarMenuButton\r\n                isActive={false}\r\n                aria-label=\"Logout\"\r\n                onClick={handleLogout}\r\n              >\r\n                <span className=\"flex items-center gap-2\">\r\n                  <LogOut /> <span>Logout</span>\r\n                </span>\r\n              </SidebarMenuButton>\r\n            </SidebarMenuItem>\r\n          </SidebarMenu>\r\n        </SidebarFooter>\r\n      </Sidebar>\r\n      <SidebarInset className=\"mt-20\">\r\n        <div className=\"flex items-center gap-4 p-2 bg-white\">\r\n          <SidebarTrigger />\r\n          <h2 className=\"text-xs font-semibold whitespace-nowrap\" style={{ color: \"#002449\" }} suppressHydrationWarning>\r\n            {role === \"leader\" && \"Team\"}\r\n            {role === \"poc\" && \"POC\"}\r\n            {role === \"admin\" && \"Admin\"}\r\n            {!role && \"Guest\"}\r\n            &nbsp;Dashboard\r\n          </h2>\r\n          <div className=\"ml-auto flex items-center gap-3 pr-2\">\r\n            {user?.email && (\r\n              <span className=\"text-xs text-gray-500 truncate max-w-[160px]\" title={user.email}>\r\n                {user.email}\r\n              </span>\r\n            )}\r\n          </div>\r\n        </div>\r\n        <div className=\"p-4 md:p-8\">{children}</div>\r\n      </SidebarInset>\r\n    </SidebarProvider>\r\n  )\r\n}\r\n","// packages/react/separator/src/Separator.tsx\nimport * as React from \"react\";\nimport { Primitive } from \"@radix-ui/react-primitive\";\nimport { jsx } from \"react/jsx-runtime\";\nvar NAME = \"Separator\";\nvar DEFAULT_ORIENTATION = \"horizontal\";\nvar ORIENTATIONS = [\"horizontal\", \"vertical\"];\nvar Separator = React.forwardRef((props, forwardedRef) => {\n  const { decorative, orientation: orientationProp = DEFAULT_ORIENTATION, ...domProps } = props;\n  const orientation = isValidOrientation(orientationProp) ? orientationProp : DEFAULT_ORIENTATION;\n  const ariaOrientation = orientation === \"vertical\" ? orientation : void 0;\n  const semanticProps = decorative ? { role: \"none\" } : { \"aria-orientation\": ariaOrientation, role: \"separator\" };\n  return /* @__PURE__ */ jsx(\n    Primitive.div,\n    {\n      \"data-orientation\": orientation,\n      ...semanticProps,\n      ...domProps,\n      ref: forwardedRef\n    }\n  );\n});\nSeparator.displayName = NAME;\nfunction isValidOrientation(orientation) {\n  return ORIENTATIONS.includes(orientation);\n}\nvar Root = Separator;\nexport {\n  Root,\n  Separator\n};\n//# sourceMappingURL=index.mjs.map\n","import { cn } from '@/lib/utils'\n\nfunction Skeleton({ className, ...props }: React.ComponentProps<'div'>) {\n  return (\n    <div\n      data-slot=\"skeleton\"\n      className={cn('bg-accent animate-pulse rounded-md', className)}\n      {...props}\n    />\n  )\n}\n\nexport { Skeleton }\n","import * as React from 'react'\n\nconst MOBILE_BREAKPOINT = 768\n\nexport function useIsMobile() {\n  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(undefined)\n\n  React.useEffect(() => {\n    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`)\n    const onChange = () => {\n      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)\n    }\n    mql.addEventListener('change', onChange)\n    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)\n    return () => mql.removeEventListener('change', onChange)\n  }, [])\n\n  return !!isMobile\n}\n","import { getSideAxis, getAlignmentAxis, getAxisLength, getSide, getAlignment, evaluate, getPaddingObject, rectToClientRect, min, clamp, placements, getAlignmentSides, getOppositeAlignmentPlacement, getOppositePlacement, getExpandedPlacements, getOppositeAxisPlacements, sides, max, getOppositeAxis } from '@floating-ui/utils';\nexport { rectToClientRect } from '@floating-ui/utils';\n\nfunction computeCoordsFromPlacement(_ref, placement, rtl) {\n  let {\n    reference,\n    floating\n  } = _ref;\n  const sideAxis = getSideAxis(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const alignLength = getAxisLength(alignmentAxis);\n  const side = getSide(placement);\n  const isVertical = sideAxis === 'y';\n  const commonX = reference.x + reference.width / 2 - floating.width / 2;\n  const commonY = reference.y + reference.height / 2 - floating.height / 2;\n  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;\n  let coords;\n  switch (side) {\n    case 'top':\n      coords = {\n        x: commonX,\n        y: reference.y - floating.height\n      };\n      break;\n    case 'bottom':\n      coords = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n    case 'right':\n      coords = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n    case 'left':\n      coords = {\n        x: reference.x - floating.width,\n        y: commonY\n      };\n      break;\n    default:\n      coords = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n  switch (getAlignment(placement)) {\n    case 'start':\n      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n    case 'end':\n      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n  }\n  return coords;\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a given reference element.\n *\n * This export does not have any `platform` interface logic. You will need to\n * write one for the platform you are using Floating UI with.\n */\nconst computePosition = async (reference, floating, config) => {\n  const {\n    placement = 'bottom',\n    strategy = 'absolute',\n    middleware = [],\n    platform\n  } = config;\n  const validMiddleware = middleware.filter(Boolean);\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));\n  let rects = await platform.getElementRects({\n    reference,\n    floating,\n    strategy\n  });\n  let {\n    x,\n    y\n  } = computeCoordsFromPlacement(rects, placement, rtl);\n  let statefulPlacement = placement;\n  let middlewareData = {};\n  let resetCount = 0;\n  for (let i = 0; i < validMiddleware.length; i++) {\n    const {\n      name,\n      fn\n    } = validMiddleware[i];\n    const {\n      x: nextX,\n      y: nextY,\n      data,\n      reset\n    } = await fn({\n      x,\n      y,\n      initialPlacement: placement,\n      placement: statefulPlacement,\n      strategy,\n      middlewareData,\n      rects,\n      platform,\n      elements: {\n        reference,\n        floating\n      }\n    });\n    x = nextX != null ? nextX : x;\n    y = nextY != null ? nextY : y;\n    middlewareData = {\n      ...middlewareData,\n      [name]: {\n        ...middlewareData[name],\n        ...data\n      }\n    };\n    if (reset && resetCount <= 50) {\n      resetCount++;\n      if (typeof reset === 'object') {\n        if (reset.placement) {\n          statefulPlacement = reset.placement;\n        }\n        if (reset.rects) {\n          rects = reset.rects === true ? await platform.getElementRects({\n            reference,\n            floating,\n            strategy\n          }) : reset.rects;\n        }\n        ({\n          x,\n          y\n        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));\n      }\n      i = -1;\n    }\n  }\n  return {\n    x,\n    y,\n    placement: statefulPlacement,\n    strategy,\n    middlewareData\n  };\n};\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary on each side.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\nasync function detectOverflow(state, options) {\n  var _await$platform$isEle;\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    x,\n    y,\n    platform,\n    rects,\n    elements,\n    strategy\n  } = state;\n  const {\n    boundary = 'clippingAncestors',\n    rootBoundary = 'viewport',\n    elementContext = 'floating',\n    altBoundary = false,\n    padding = 0\n  } = evaluate(options, state);\n  const paddingObject = getPaddingObject(padding);\n  const altContext = elementContext === 'floating' ? 'reference' : 'floating';\n  const element = elements[altBoundary ? altContext : elementContext];\n  const clippingClientRect = rectToClientRect(await platform.getClippingRect({\n    element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || (await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating))),\n    boundary,\n    rootBoundary,\n    strategy\n  }));\n  const rect = elementContext === 'floating' ? {\n    x,\n    y,\n    width: rects.floating.width,\n    height: rects.floating.height\n  } : rects.reference;\n  const offsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating));\n  const offsetScale = (await (platform.isElement == null ? void 0 : platform.isElement(offsetParent))) ? (await (platform.getScale == null ? void 0 : platform.getScale(offsetParent))) || {\n    x: 1,\n    y: 1\n  } : {\n    x: 1,\n    y: 1\n  };\n  const elementClientRect = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n    elements,\n    rect,\n    offsetParent,\n    strategy\n  }) : rect);\n  return {\n    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,\n    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,\n    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,\n    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x\n  };\n}\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = options => ({\n  name: 'arrow',\n  options,\n  async fn(state) {\n    const {\n      x,\n      y,\n      placement,\n      rects,\n      platform,\n      elements,\n      middlewareData\n    } = state;\n    // Since `element` is required, we don't Partial<> the type.\n    const {\n      element,\n      padding = 0\n    } = evaluate(options, state) || {};\n    if (element == null) {\n      return {};\n    }\n    const paddingObject = getPaddingObject(padding);\n    const coords = {\n      x,\n      y\n    };\n    const axis = getAlignmentAxis(placement);\n    const length = getAxisLength(axis);\n    const arrowDimensions = await platform.getDimensions(element);\n    const isYAxis = axis === 'y';\n    const minProp = isYAxis ? 'top' : 'left';\n    const maxProp = isYAxis ? 'bottom' : 'right';\n    const clientProp = isYAxis ? 'clientHeight' : 'clientWidth';\n    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];\n    const startDiff = coords[axis] - rects.reference[axis];\n    const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));\n    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;\n\n    // DOM platform can return `window` as the `offsetParent`.\n    if (!clientSize || !(await (platform.isElement == null ? void 0 : platform.isElement(arrowOffsetParent)))) {\n      clientSize = elements.floating[clientProp] || rects.floating[length];\n    }\n    const centerToReference = endDiff / 2 - startDiff / 2;\n\n    // If the padding is large enough that it causes the arrow to no longer be\n    // centered, modify the padding so that it is centered.\n    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;\n    const minPadding = min(paddingObject[minProp], largestPossiblePadding);\n    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);\n\n    // Make sure the arrow doesn't overflow the floating element if the center\n    // point is outside the floating element's bounds.\n    const min$1 = minPadding;\n    const max = clientSize - arrowDimensions[length] - maxPadding;\n    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;\n    const offset = clamp(min$1, center, max);\n\n    // If the reference is small enough that the arrow's padding causes it to\n    // to point to nothing for an aligned placement, adjust the offset of the\n    // floating element itself. To ensure `shift()` continues to take action,\n    // a single reset is performed when this is true.\n    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;\n    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max : 0;\n    return {\n      [axis]: coords[axis] + alignmentOffset,\n      data: {\n        [axis]: offset,\n        centerOffset: center - offset - alignmentOffset,\n        ...(shouldAddOffset && {\n          alignmentOffset\n        })\n      },\n      reset: shouldAddOffset\n    };\n  }\n});\n\nfunction getPlacementList(alignment, autoAlignment, allowedPlacements) {\n  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter(placement => getAlignment(placement) === alignment), ...allowedPlacements.filter(placement => getAlignment(placement) !== alignment)] : allowedPlacements.filter(placement => getSide(placement) === placement);\n  return allowedPlacementsSortedByAlignment.filter(placement => {\n    if (alignment) {\n      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);\n    }\n    return true;\n  });\n}\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'autoPlacement',\n    options,\n    async fn(state) {\n      var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;\n      const {\n        rects,\n        middlewareData,\n        placement,\n        platform,\n        elements\n      } = state;\n      const {\n        crossAxis = false,\n        alignment,\n        allowedPlacements = placements,\n        autoAlignment = true,\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const placements$1 = alignment !== undefined || allowedPlacements === placements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;\n      const currentPlacement = placements$1[currentIndex];\n      if (currentPlacement == null) {\n        return {};\n      }\n      const alignmentSides = getAlignmentSides(currentPlacement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));\n\n      // Make `computeCoords` start from the right place.\n      if (placement !== currentPlacement) {\n        return {\n          reset: {\n            placement: placements$1[0]\n          }\n        };\n      }\n      const currentOverflows = [overflow[getSide(currentPlacement)], overflow[alignmentSides[0]], overflow[alignmentSides[1]]];\n      const allOverflows = [...(((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || []), {\n        placement: currentPlacement,\n        overflows: currentOverflows\n      }];\n      const nextPlacement = placements$1[currentIndex + 1];\n\n      // There are more placements to check.\n      if (nextPlacement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: nextPlacement\n          }\n        };\n      }\n      const placementsSortedByMostSpace = allOverflows.map(d => {\n        const alignment = getAlignment(d.placement);\n        return [d.placement, alignment && crossAxis ?\n        // Check along the mainAxis and main crossAxis side.\n        d.overflows.slice(0, 2).reduce((acc, v) => acc + v, 0) :\n        // Check only the mainAxis.\n        d.overflows[0], d.overflows];\n      }).sort((a, b) => a[1] - b[1]);\n      const placementsThatFitOnEachSide = placementsSortedByMostSpace.filter(d => d[2].slice(0,\n      // Aligned placements should not check their opposite crossAxis\n      // side.\n      getAlignment(d[0]) ? 2 : 3).every(v => v <= 0));\n      const resetPlacement = ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];\n      if (resetPlacement !== placement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: resetPlacement\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'flip',\n    options,\n    async fn(state) {\n      var _middlewareData$arrow, _middlewareData$flip;\n      const {\n        placement,\n        middlewareData,\n        rects,\n        initialPlacement,\n        platform,\n        elements\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true,\n        fallbackPlacements: specifiedFallbackPlacements,\n        fallbackStrategy = 'bestFit',\n        fallbackAxisSideDirection = 'none',\n        flipAlignment = true,\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n\n      // If a reset by the arrow was caused due to an alignment offset being\n      // added, we should skip any logic now since `flip()` has already done its\n      // work.\n      // https://github.com/floating-ui/floating-ui/issues/2549#issuecomment-1719601643\n      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n        return {};\n      }\n      const side = getSide(placement);\n      const initialSideAxis = getSideAxis(initialPlacement);\n      const isBasePlacement = getSide(initialPlacement) === initialPlacement;\n      const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));\n      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== 'none';\n      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {\n        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));\n      }\n      const placements = [initialPlacement, ...fallbackPlacements];\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const overflows = [];\n      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];\n      if (checkMainAxis) {\n        overflows.push(overflow[side]);\n      }\n      if (checkCrossAxis) {\n        const sides = getAlignmentSides(placement, rects, rtl);\n        overflows.push(overflow[sides[0]], overflow[sides[1]]);\n      }\n      overflowsData = [...overflowsData, {\n        placement,\n        overflows\n      }];\n\n      // One or more sides is overflowing.\n      if (!overflows.every(side => side <= 0)) {\n        var _middlewareData$flip2, _overflowsData$filter;\n        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;\n        const nextPlacement = placements[nextIndex];\n        if (nextPlacement) {\n          const ignoreCrossAxisOverflow = checkCrossAxis === 'alignment' ? initialSideAxis !== getSideAxis(nextPlacement) : false;\n          if (!ignoreCrossAxisOverflow ||\n          // We leave the current main axis only if every placement on that axis\n          // overflows the main axis.\n          overflowsData.every(d => getSideAxis(d.placement) === initialSideAxis ? d.overflows[0] > 0 : true)) {\n            // Try next placement and re-run the lifecycle.\n            return {\n              data: {\n                index: nextIndex,\n                overflows: overflowsData\n              },\n              reset: {\n                placement: nextPlacement\n              }\n            };\n          }\n        }\n\n        // First, find the candidates that fit on the mainAxis side of overflow,\n        // then find the placement that fits the best on the main crossAxis side.\n        let resetPlacement = (_overflowsData$filter = overflowsData.filter(d => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;\n\n        // Otherwise fallback.\n        if (!resetPlacement) {\n          switch (fallbackStrategy) {\n            case 'bestFit':\n              {\n                var _overflowsData$filter2;\n                const placement = (_overflowsData$filter2 = overflowsData.filter(d => {\n                  if (hasFallbackAxisSideDirection) {\n                    const currentSideAxis = getSideAxis(d.placement);\n                    return currentSideAxis === initialSideAxis ||\n                    // Create a bias to the `y` side axis due to horizontal\n                    // reading directions favoring greater width.\n                    currentSideAxis === 'y';\n                  }\n                  return true;\n                }).map(d => [d.placement, d.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];\n                if (placement) {\n                  resetPlacement = placement;\n                }\n                break;\n              }\n            case 'initialPlacement':\n              resetPlacement = initialPlacement;\n              break;\n          }\n        }\n        if (placement !== resetPlacement) {\n          return {\n            reset: {\n              placement: resetPlacement\n            }\n          };\n        }\n      }\n      return {};\n    }\n  };\n};\n\nfunction getSideOffsets(overflow, rect) {\n  return {\n    top: overflow.top - rect.height,\n    right: overflow.right - rect.width,\n    bottom: overflow.bottom - rect.height,\n    left: overflow.left - rect.width\n  };\n}\nfunction isAnySideFullyClipped(overflow) {\n  return sides.some(side => overflow[side] >= 0);\n}\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'hide',\n    options,\n    async fn(state) {\n      const {\n        rects\n      } = state;\n      const {\n        strategy = 'referenceHidden',\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      switch (strategy) {\n        case 'referenceHidden':\n          {\n            const overflow = await detectOverflow(state, {\n              ...detectOverflowOptions,\n              elementContext: 'reference'\n            });\n            const offsets = getSideOffsets(overflow, rects.reference);\n            return {\n              data: {\n                referenceHiddenOffsets: offsets,\n                referenceHidden: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        case 'escaped':\n          {\n            const overflow = await detectOverflow(state, {\n              ...detectOverflowOptions,\n              altBoundary: true\n            });\n            const offsets = getSideOffsets(overflow, rects.floating);\n            return {\n              data: {\n                escapedOffsets: offsets,\n                escaped: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        default:\n          {\n            return {};\n          }\n      }\n    }\n  };\n};\n\nfunction getBoundingRect(rects) {\n  const minX = min(...rects.map(rect => rect.left));\n  const minY = min(...rects.map(rect => rect.top));\n  const maxX = max(...rects.map(rect => rect.right));\n  const maxY = max(...rects.map(rect => rect.bottom));\n  return {\n    x: minX,\n    y: minY,\n    width: maxX - minX,\n    height: maxY - minY\n  };\n}\nfunction getRectsByLine(rects) {\n  const sortedRects = rects.slice().sort((a, b) => a.y - b.y);\n  const groups = [];\n  let prevRect = null;\n  for (let i = 0; i < sortedRects.length; i++) {\n    const rect = sortedRects[i];\n    if (!prevRect || rect.y - prevRect.y > prevRect.height / 2) {\n      groups.push([rect]);\n    } else {\n      groups[groups.length - 1].push(rect);\n    }\n    prevRect = rect;\n  }\n  return groups.map(rect => rectToClientRect(getBoundingRect(rect)));\n}\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'inline',\n    options,\n    async fn(state) {\n      const {\n        placement,\n        elements,\n        rects,\n        platform,\n        strategy\n      } = state;\n      // A MouseEvent's client{X,Y} coords can be up to 2 pixels off a\n      // ClientRect's bounds, despite the event listener being triggered. A\n      // padding of 2 seems to handle this issue.\n      const {\n        padding = 2,\n        x,\n        y\n      } = evaluate(options, state);\n      const nativeClientRects = Array.from((await (platform.getClientRects == null ? void 0 : platform.getClientRects(elements.reference))) || []);\n      const clientRects = getRectsByLine(nativeClientRects);\n      const fallback = rectToClientRect(getBoundingRect(nativeClientRects));\n      const paddingObject = getPaddingObject(padding);\n      function getBoundingClientRect() {\n        // There are two rects and they are disjoined.\n        if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) {\n          // Find the first rect in which the point is fully inside.\n          return clientRects.find(rect => x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom) || fallback;\n        }\n\n        // There are 2 or more connected rects.\n        if (clientRects.length >= 2) {\n          if (getSideAxis(placement) === 'y') {\n            const firstRect = clientRects[0];\n            const lastRect = clientRects[clientRects.length - 1];\n            const isTop = getSide(placement) === 'top';\n            const top = firstRect.top;\n            const bottom = lastRect.bottom;\n            const left = isTop ? firstRect.left : lastRect.left;\n            const right = isTop ? firstRect.right : lastRect.right;\n            const width = right - left;\n            const height = bottom - top;\n            return {\n              top,\n              bottom,\n              left,\n              right,\n              width,\n              height,\n              x: left,\n              y: top\n            };\n          }\n          const isLeftSide = getSide(placement) === 'left';\n          const maxRight = max(...clientRects.map(rect => rect.right));\n          const minLeft = min(...clientRects.map(rect => rect.left));\n          const measureRects = clientRects.filter(rect => isLeftSide ? rect.left === minLeft : rect.right === maxRight);\n          const top = measureRects[0].top;\n          const bottom = measureRects[measureRects.length - 1].bottom;\n          const left = minLeft;\n          const right = maxRight;\n          const width = right - left;\n          const height = bottom - top;\n          return {\n            top,\n            bottom,\n            left,\n            right,\n            width,\n            height,\n            x: left,\n            y: top\n          };\n        }\n        return fallback;\n      }\n      const resetRects = await platform.getElementRects({\n        reference: {\n          getBoundingClientRect\n        },\n        floating: elements.floating,\n        strategy\n      });\n      if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {\n        return {\n          reset: {\n            rects: resetRects\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\nconst originSides = /*#__PURE__*/new Set(['left', 'top']);\n\n// For type backwards-compatibility, the `OffsetOptions` type was also\n// Derivable.\n\nasync function convertValueToCoords(state, options) {\n  const {\n    placement,\n    platform,\n    elements\n  } = state;\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n  const side = getSide(placement);\n  const alignment = getAlignment(placement);\n  const isVertical = getSideAxis(placement) === 'y';\n  const mainAxisMulti = originSides.has(side) ? -1 : 1;\n  const crossAxisMulti = rtl && isVertical ? -1 : 1;\n  const rawValue = evaluate(options, state);\n\n  // eslint-disable-next-line prefer-const\n  let {\n    mainAxis,\n    crossAxis,\n    alignmentAxis\n  } = typeof rawValue === 'number' ? {\n    mainAxis: rawValue,\n    crossAxis: 0,\n    alignmentAxis: null\n  } : {\n    mainAxis: rawValue.mainAxis || 0,\n    crossAxis: rawValue.crossAxis || 0,\n    alignmentAxis: rawValue.alignmentAxis\n  };\n  if (alignment && typeof alignmentAxis === 'number') {\n    crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;\n  }\n  return isVertical ? {\n    x: crossAxis * crossAxisMulti,\n    y: mainAxis * mainAxisMulti\n  } : {\n    x: mainAxis * mainAxisMulti,\n    y: crossAxis * crossAxisMulti\n  };\n}\n\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */\nconst offset = function (options) {\n  if (options === void 0) {\n    options = 0;\n  }\n  return {\n    name: 'offset',\n    options,\n    async fn(state) {\n      var _middlewareData$offse, _middlewareData$arrow;\n      const {\n        x,\n        y,\n        placement,\n        middlewareData\n      } = state;\n      const diffCoords = await convertValueToCoords(state, options);\n\n      // If the placement is the same and the arrow caused an alignment offset\n      // then we don't need to change the positioning coordinates.\n      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n        return {};\n      }\n      return {\n        x: x + diffCoords.x,\n        y: y + diffCoords.y,\n        data: {\n          ...diffCoords,\n          placement\n        }\n      };\n    }\n  };\n};\n\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'shift',\n    options,\n    async fn(state) {\n      const {\n        x,\n        y,\n        placement\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = false,\n        limiter = {\n          fn: _ref => {\n            let {\n              x,\n              y\n            } = _ref;\n            return {\n              x,\n              y\n            };\n          }\n        },\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const coords = {\n        x,\n        y\n      };\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const crossAxis = getSideAxis(getSide(placement));\n      const mainAxis = getOppositeAxis(crossAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      if (checkMainAxis) {\n        const minSide = mainAxis === 'y' ? 'top' : 'left';\n        const maxSide = mainAxis === 'y' ? 'bottom' : 'right';\n        const min = mainAxisCoord + overflow[minSide];\n        const max = mainAxisCoord - overflow[maxSide];\n        mainAxisCoord = clamp(min, mainAxisCoord, max);\n      }\n      if (checkCrossAxis) {\n        const minSide = crossAxis === 'y' ? 'top' : 'left';\n        const maxSide = crossAxis === 'y' ? 'bottom' : 'right';\n        const min = crossAxisCoord + overflow[minSide];\n        const max = crossAxisCoord - overflow[maxSide];\n        crossAxisCoord = clamp(min, crossAxisCoord, max);\n      }\n      const limitedCoords = limiter.fn({\n        ...state,\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      });\n      return {\n        ...limitedCoords,\n        data: {\n          x: limitedCoords.x - x,\n          y: limitedCoords.y - y,\n          enabled: {\n            [mainAxis]: checkMainAxis,\n            [crossAxis]: checkCrossAxis\n          }\n        }\n      };\n    }\n  };\n};\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    options,\n    fn(state) {\n      const {\n        x,\n        y,\n        placement,\n        rects,\n        middlewareData\n      } = state;\n      const {\n        offset = 0,\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true\n      } = evaluate(options, state);\n      const coords = {\n        x,\n        y\n      };\n      const crossAxis = getSideAxis(placement);\n      const mainAxis = getOppositeAxis(crossAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      const rawOffset = evaluate(offset, state);\n      const computedOffset = typeof rawOffset === 'number' ? {\n        mainAxis: rawOffset,\n        crossAxis: 0\n      } : {\n        mainAxis: 0,\n        crossAxis: 0,\n        ...rawOffset\n      };\n      if (checkMainAxis) {\n        const len = mainAxis === 'y' ? 'height' : 'width';\n        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;\n        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;\n        if (mainAxisCoord < limitMin) {\n          mainAxisCoord = limitMin;\n        } else if (mainAxisCoord > limitMax) {\n          mainAxisCoord = limitMax;\n        }\n      }\n      if (checkCrossAxis) {\n        var _middlewareData$offse, _middlewareData$offse2;\n        const len = mainAxis === 'y' ? 'width' : 'height';\n        const isOriginSide = originSides.has(getSide(placement));\n        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);\n        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);\n        if (crossAxisCoord < limitMin) {\n          crossAxisCoord = limitMin;\n        } else if (crossAxisCoord > limitMax) {\n          crossAxisCoord = limitMax;\n        }\n      }\n      return {\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      };\n    }\n  };\n};\n\n/**\n * Provides data that allows you to change the size of the floating element —\n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'size',\n    options,\n    async fn(state) {\n      var _state$middlewareData, _state$middlewareData2;\n      const {\n        placement,\n        rects,\n        platform,\n        elements\n      } = state;\n      const {\n        apply = () => {},\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const side = getSide(placement);\n      const alignment = getAlignment(placement);\n      const isYAxis = getSideAxis(placement) === 'y';\n      const {\n        width,\n        height\n      } = rects.floating;\n      let heightSide;\n      let widthSide;\n      if (side === 'top' || side === 'bottom') {\n        heightSide = side;\n        widthSide = alignment === ((await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))) ? 'start' : 'end') ? 'left' : 'right';\n      } else {\n        widthSide = side;\n        heightSide = alignment === 'end' ? 'top' : 'bottom';\n      }\n      const maximumClippingHeight = height - overflow.top - overflow.bottom;\n      const maximumClippingWidth = width - overflow.left - overflow.right;\n      const overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight);\n      const overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth);\n      const noShift = !state.middlewareData.shift;\n      let availableHeight = overflowAvailableHeight;\n      let availableWidth = overflowAvailableWidth;\n      if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) {\n        availableWidth = maximumClippingWidth;\n      }\n      if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {\n        availableHeight = maximumClippingHeight;\n      }\n      if (noShift && !alignment) {\n        const xMin = max(overflow.left, 0);\n        const xMax = max(overflow.right, 0);\n        const yMin = max(overflow.top, 0);\n        const yMax = max(overflow.bottom, 0);\n        if (isYAxis) {\n          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));\n        } else {\n          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));\n        }\n      }\n      await apply({\n        ...state,\n        availableWidth,\n        availableHeight\n      });\n      const nextDimensions = await platform.getDimensions(elements.floating);\n      if (width !== nextDimensions.width || height !== nextDimensions.height) {\n        return {\n          reset: {\n            rects: true\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\nexport { arrow, autoPlacement, computePosition, detectOverflow, flip, hide, inline, limitShift, offset, shift, size };\n","// packages/react/use-size/src/useSize.tsx\nimport * as React from \"react\";\nimport { useLayoutEffect } from \"@radix-ui/react-use-layout-effect\";\nfunction useSize(element) {\n  const [size, setSize] = React.useState(void 0);\n  useLayoutEffect(() => {\n    if (element) {\n      setSize({ width: element.offsetWidth, height: element.offsetHeight });\n      const resizeObserver = new ResizeObserver((entries) => {\n        if (!Array.isArray(entries)) {\n          return;\n        }\n        if (!entries.length) {\n          return;\n        }\n        const entry = entries[0];\n        let width;\n        let height;\n        if (\"borderBoxSize\" in entry) {\n          const borderSizeEntry = entry[\"borderBoxSize\"];\n          const borderSize = Array.isArray(borderSizeEntry) ? borderSizeEntry[0] : borderSizeEntry;\n          width = borderSize[\"inlineSize\"];\n          height = borderSize[\"blockSize\"];\n        } else {\n          width = element.offsetWidth;\n          height = element.offsetHeight;\n        }\n        setSize({ width, height });\n      });\n      resizeObserver.observe(element, { box: \"border-box\" });\n      return () => resizeObserver.unobserve(element);\n    } else {\n      setSize(void 0);\n    }\n  }, [element]);\n  return size;\n}\nexport {\n  useSize\n};\n//# sourceMappingURL=index.mjs.map\n","import { computePosition, arrow as arrow$2, autoPlacement as autoPlacement$1, flip as flip$1, hide as hide$1, inline as inline$1, limitShift as limitShift$1, offset as offset$1, shift as shift$1, size as size$1 } from '@floating-ui/dom';\nexport { autoUpdate, computePosition, detectOverflow, getOverflowAncestors, platform } from '@floating-ui/dom';\nimport * as React from 'react';\nimport { useLayoutEffect } from 'react';\nimport * as ReactDOM from 'react-dom';\n\nvar isClient = typeof document !== 'undefined';\n\nvar noop = function noop() {};\nvar index = isClient ? useLayoutEffect : noop;\n\n// Fork of `fast-deep-equal` that only does the comparisons we need and compares\n// functions\nfunction deepEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n  if (typeof a !== typeof b) {\n    return false;\n  }\n  if (typeof a === 'function' && a.toString() === b.toString()) {\n    return true;\n  }\n  let length;\n  let i;\n  let keys;\n  if (a && b && typeof a === 'object') {\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length !== b.length) return false;\n      for (i = length; i-- !== 0;) {\n        if (!deepEqual(a[i], b[i])) {\n          return false;\n        }\n      }\n      return true;\n    }\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) {\n      return false;\n    }\n    for (i = length; i-- !== 0;) {\n      if (!{}.hasOwnProperty.call(b, keys[i])) {\n        return false;\n      }\n    }\n    for (i = length; i-- !== 0;) {\n      const key = keys[i];\n      if (key === '_owner' && a.$$typeof) {\n        continue;\n      }\n      if (!deepEqual(a[key], b[key])) {\n        return false;\n      }\n    }\n    return true;\n  }\n  return a !== a && b !== b;\n}\n\nfunction getDPR(element) {\n  if (typeof window === 'undefined') {\n    return 1;\n  }\n  const win = element.ownerDocument.defaultView || window;\n  return win.devicePixelRatio || 1;\n}\n\nfunction roundByDPR(element, value) {\n  const dpr = getDPR(element);\n  return Math.round(value * dpr) / dpr;\n}\n\nfunction useLatestRef(value) {\n  const ref = React.useRef(value);\n  index(() => {\n    ref.current = value;\n  });\n  return ref;\n}\n\n/**\n * Provides data to position a floating element.\n * @see https://floating-ui.com/docs/useFloating\n */\nfunction useFloating(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    placement = 'bottom',\n    strategy = 'absolute',\n    middleware = [],\n    platform,\n    elements: {\n      reference: externalReference,\n      floating: externalFloating\n    } = {},\n    transform = true,\n    whileElementsMounted,\n    open\n  } = options;\n  const [data, setData] = React.useState({\n    x: 0,\n    y: 0,\n    strategy,\n    placement,\n    middlewareData: {},\n    isPositioned: false\n  });\n  const [latestMiddleware, setLatestMiddleware] = React.useState(middleware);\n  if (!deepEqual(latestMiddleware, middleware)) {\n    setLatestMiddleware(middleware);\n  }\n  const [_reference, _setReference] = React.useState(null);\n  const [_floating, _setFloating] = React.useState(null);\n  const setReference = React.useCallback(node => {\n    if (node !== referenceRef.current) {\n      referenceRef.current = node;\n      _setReference(node);\n    }\n  }, []);\n  const setFloating = React.useCallback(node => {\n    if (node !== floatingRef.current) {\n      floatingRef.current = node;\n      _setFloating(node);\n    }\n  }, []);\n  const referenceEl = externalReference || _reference;\n  const floatingEl = externalFloating || _floating;\n  const referenceRef = React.useRef(null);\n  const floatingRef = React.useRef(null);\n  const dataRef = React.useRef(data);\n  const hasWhileElementsMounted = whileElementsMounted != null;\n  const whileElementsMountedRef = useLatestRef(whileElementsMounted);\n  const platformRef = useLatestRef(platform);\n  const openRef = useLatestRef(open);\n  const update = React.useCallback(() => {\n    if (!referenceRef.current || !floatingRef.current) {\n      return;\n    }\n    const config = {\n      placement,\n      strategy,\n      middleware: latestMiddleware\n    };\n    if (platformRef.current) {\n      config.platform = platformRef.current;\n    }\n    computePosition(referenceRef.current, floatingRef.current, config).then(data => {\n      const fullData = {\n        ...data,\n        // The floating element's position may be recomputed while it's closed\n        // but still mounted (such as when transitioning out). To ensure\n        // `isPositioned` will be `false` initially on the next open, avoid\n        // setting it to `true` when `open === false` (must be specified).\n        isPositioned: openRef.current !== false\n      };\n      if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {\n        dataRef.current = fullData;\n        ReactDOM.flushSync(() => {\n          setData(fullData);\n        });\n      }\n    });\n  }, [latestMiddleware, placement, strategy, platformRef, openRef]);\n  index(() => {\n    if (open === false && dataRef.current.isPositioned) {\n      dataRef.current.isPositioned = false;\n      setData(data => ({\n        ...data,\n        isPositioned: false\n      }));\n    }\n  }, [open]);\n  const isMountedRef = React.useRef(false);\n  index(() => {\n    isMountedRef.current = true;\n    return () => {\n      isMountedRef.current = false;\n    };\n  }, []);\n  index(() => {\n    if (referenceEl) referenceRef.current = referenceEl;\n    if (floatingEl) floatingRef.current = floatingEl;\n    if (referenceEl && floatingEl) {\n      if (whileElementsMountedRef.current) {\n        return whileElementsMountedRef.current(referenceEl, floatingEl, update);\n      }\n      update();\n    }\n  }, [referenceEl, floatingEl, update, whileElementsMountedRef, hasWhileElementsMounted]);\n  const refs = React.useMemo(() => ({\n    reference: referenceRef,\n    floating: floatingRef,\n    setReference,\n    setFloating\n  }), [setReference, setFloating]);\n  const elements = React.useMemo(() => ({\n    reference: referenceEl,\n    floating: floatingEl\n  }), [referenceEl, floatingEl]);\n  const floatingStyles = React.useMemo(() => {\n    const initialStyles = {\n      position: strategy,\n      left: 0,\n      top: 0\n    };\n    if (!elements.floating) {\n      return initialStyles;\n    }\n    const x = roundByDPR(elements.floating, data.x);\n    const y = roundByDPR(elements.floating, data.y);\n    if (transform) {\n      return {\n        ...initialStyles,\n        transform: \"translate(\" + x + \"px, \" + y + \"px)\",\n        ...(getDPR(elements.floating) >= 1.5 && {\n          willChange: 'transform'\n        })\n      };\n    }\n    return {\n      position: strategy,\n      left: x,\n      top: y\n    };\n  }, [strategy, transform, elements.floating, data.x, data.y]);\n  return React.useMemo(() => ({\n    ...data,\n    update,\n    refs,\n    elements,\n    floatingStyles\n  }), [data, update, refs, elements, floatingStyles]);\n}\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * This wraps the core `arrow` middleware to allow React refs as the element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow$1 = options => {\n  function isRef(value) {\n    return {}.hasOwnProperty.call(value, 'current');\n  }\n  return {\n    name: 'arrow',\n    options,\n    fn(state) {\n      const {\n        element,\n        padding\n      } = typeof options === 'function' ? options(state) : options;\n      if (element && isRef(element)) {\n        if (element.current != null) {\n          return arrow$2({\n            element: element.current,\n            padding\n          }).fn(state);\n        }\n        return {};\n      }\n      if (element) {\n        return arrow$2({\n          element,\n          padding\n        }).fn(state);\n      }\n      return {};\n    }\n  };\n};\n\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */\nconst offset = (options, deps) => ({\n  ...offset$1(options),\n  options: [options, deps]\n});\n\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = (options, deps) => ({\n  ...shift$1(options),\n  options: [options, deps]\n});\n\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = (options, deps) => ({\n  ...limitShift$1(options),\n  options: [options, deps]\n});\n\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = (options, deps) => ({\n  ...flip$1(options),\n  options: [options, deps]\n});\n\n/**\n * Provides data that allows you to change the size of the floating element —\n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = (options, deps) => ({\n  ...size$1(options),\n  options: [options, deps]\n});\n\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = (options, deps) => ({\n  ...autoPlacement$1(options),\n  options: [options, deps]\n});\n\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = (options, deps) => ({\n  ...hide$1(options),\n  options: [options, deps]\n});\n\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = (options, deps) => ({\n  ...inline$1(options),\n  options: [options, deps]\n});\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * This wraps the core `arrow` middleware to allow React refs as the element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = (options, deps) => ({\n  ...arrow$1(options),\n  options: [options, deps]\n});\n\nexport { arrow, autoPlacement, flip, hide, inline, limitShift, offset, shift, size, useFloating };\n","// packages/react/arrow/src/Arrow.tsx\nimport * as React from \"react\";\nimport { Primitive } from \"@radix-ui/react-primitive\";\nimport { jsx } from \"react/jsx-runtime\";\nvar NAME = \"Arrow\";\nvar Arrow = React.forwardRef((props, forwardedRef) => {\n  const { children, width = 10, height = 5, ...arrowProps } = props;\n  return /* @__PURE__ */ jsx(\n    Primitive.svg,\n    {\n      ...arrowProps,\n      ref: forwardedRef,\n      width,\n      height,\n      viewBox: \"0 0 30 10\",\n      preserveAspectRatio: \"none\",\n      children: props.asChild ? children : /* @__PURE__ */ jsx(\"polygon\", { points: \"0,0 30,0 15,10\" })\n    }\n  );\n});\nArrow.displayName = NAME;\nvar Root = Arrow;\nexport {\n  Arrow,\n  Root\n};\n//# sourceMappingURL=index.mjs.map\n","// packages/react/visually-hidden/src/VisuallyHidden.tsx\nimport * as React from \"react\";\nimport { Primitive } from \"@radix-ui/react-primitive\";\nimport { jsx } from \"react/jsx-runtime\";\nvar NAME = \"VisuallyHidden\";\nvar VisuallyHidden = React.forwardRef(\n  (props, forwardedRef) => {\n    return /* @__PURE__ */ jsx(\n      Primitive.span,\n      {\n        ...props,\n        ref: forwardedRef,\n        style: {\n          // See: https://github.com/twbs/bootstrap/blob/main/scss/mixins/_visually-hidden.scss\n          position: \"absolute\",\n          border: 0,\n          width: 1,\n          height: 1,\n          padding: 0,\n          margin: -1,\n          overflow: \"hidden\",\n          clip: \"rect(0, 0, 0, 0)\",\n          whiteSpace: \"nowrap\",\n          wordWrap: \"normal\",\n          ...props.style\n        }\n      }\n    );\n  }\n);\nVisuallyHidden.displayName = NAME;\nvar Root = VisuallyHidden;\nexport {\n  Root,\n  VisuallyHidden\n};\n//# sourceMappingURL=index.mjs.map\n","import { rectToClientRect, arrow as arrow$1, autoPlacement as autoPlacement$1, detectOverflow as detectOverflow$1, flip as flip$1, hide as hide$1, inline as inline$1, limitShift as limitShift$1, offset as offset$1, shift as shift$1, size as size$1, computePosition as computePosition$1 } from '@floating-ui/core';\nimport { round, createCoords, max, min, floor } from '@floating-ui/utils';\nimport { getComputedStyle as getComputedStyle$1, isHTMLElement, isElement, getWindow, isWebKit, getFrameElement, getNodeScroll, getDocumentElement, isTopLayer, getNodeName, isOverflowElement, getOverflowAncestors, getParentNode, isLastTraversableNode, isContainingBlock, isTableElement, getContainingBlock } from '@floating-ui/utils/dom';\nexport { getOverflowAncestors } from '@floating-ui/utils/dom';\n\nfunction getCssDimensions(element) {\n  const css = getComputedStyle$1(element);\n  // In testing environments, the `width` and `height` properties are empty\n  // strings for SVG elements, returning NaN. Fallback to `0` in this case.\n  let width = parseFloat(css.width) || 0;\n  let height = parseFloat(css.height) || 0;\n  const hasOffset = isHTMLElement(element);\n  const offsetWidth = hasOffset ? element.offsetWidth : width;\n  const offsetHeight = hasOffset ? element.offsetHeight : height;\n  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;\n  if (shouldFallback) {\n    width = offsetWidth;\n    height = offsetHeight;\n  }\n  return {\n    width,\n    height,\n    $: shouldFallback\n  };\n}\n\nfunction unwrapElement(element) {\n  return !isElement(element) ? element.contextElement : element;\n}\n\nfunction getScale(element) {\n  const domElement = unwrapElement(element);\n  if (!isHTMLElement(domElement)) {\n    return createCoords(1);\n  }\n  const rect = domElement.getBoundingClientRect();\n  const {\n    width,\n    height,\n    $\n  } = getCssDimensions(domElement);\n  let x = ($ ? round(rect.width) : rect.width) / width;\n  let y = ($ ? round(rect.height) : rect.height) / height;\n\n  // 0, NaN, or Infinity should always fallback to 1.\n\n  if (!x || !Number.isFinite(x)) {\n    x = 1;\n  }\n  if (!y || !Number.isFinite(y)) {\n    y = 1;\n  }\n  return {\n    x,\n    y\n  };\n}\n\nconst noOffsets = /*#__PURE__*/createCoords(0);\nfunction getVisualOffsets(element) {\n  const win = getWindow(element);\n  if (!isWebKit() || !win.visualViewport) {\n    return noOffsets;\n  }\n  return {\n    x: win.visualViewport.offsetLeft,\n    y: win.visualViewport.offsetTop\n  };\n}\nfunction shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {\n  if (isFixed === void 0) {\n    isFixed = false;\n  }\n  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {\n    return false;\n  }\n  return isFixed;\n}\n\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n  if (isFixedStrategy === void 0) {\n    isFixedStrategy = false;\n  }\n  const clientRect = element.getBoundingClientRect();\n  const domElement = unwrapElement(element);\n  let scale = createCoords(1);\n  if (includeScale) {\n    if (offsetParent) {\n      if (isElement(offsetParent)) {\n        scale = getScale(offsetParent);\n      }\n    } else {\n      scale = getScale(element);\n    }\n  }\n  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);\n  let x = (clientRect.left + visualOffsets.x) / scale.x;\n  let y = (clientRect.top + visualOffsets.y) / scale.y;\n  let width = clientRect.width / scale.x;\n  let height = clientRect.height / scale.y;\n  if (domElement) {\n    const win = getWindow(domElement);\n    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;\n    let currentWin = win;\n    let currentIFrame = getFrameElement(currentWin);\n    while (currentIFrame && offsetParent && offsetWin !== currentWin) {\n      const iframeScale = getScale(currentIFrame);\n      const iframeRect = currentIFrame.getBoundingClientRect();\n      const css = getComputedStyle$1(currentIFrame);\n      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;\n      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;\n      x *= iframeScale.x;\n      y *= iframeScale.y;\n      width *= iframeScale.x;\n      height *= iframeScale.y;\n      x += left;\n      y += top;\n      currentWin = getWindow(currentIFrame);\n      currentIFrame = getFrameElement(currentWin);\n    }\n  }\n  return rectToClientRect({\n    width,\n    height,\n    x,\n    y\n  });\n}\n\n// If <html> has a CSS width greater than the viewport, then this will be\n// incorrect for RTL.\nfunction getWindowScrollBarX(element, rect) {\n  const leftScroll = getNodeScroll(element).scrollLeft;\n  if (!rect) {\n    return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;\n  }\n  return rect.left + leftScroll;\n}\n\nfunction getHTMLOffset(documentElement, scroll) {\n  const htmlRect = documentElement.getBoundingClientRect();\n  const x = htmlRect.left + scroll.scrollLeft - getWindowScrollBarX(documentElement, htmlRect);\n  const y = htmlRect.top + scroll.scrollTop;\n  return {\n    x,\n    y\n  };\n}\n\nfunction convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n  let {\n    elements,\n    rect,\n    offsetParent,\n    strategy\n  } = _ref;\n  const isFixed = strategy === 'fixed';\n  const documentElement = getDocumentElement(offsetParent);\n  const topLayer = elements ? isTopLayer(elements.floating) : false;\n  if (offsetParent === documentElement || topLayer && isFixed) {\n    return rect;\n  }\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  let scale = createCoords(1);\n  const offsets = createCoords(0);\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent);\n      scale = getScale(offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    }\n  }\n  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);\n  return {\n    width: rect.width * scale.x,\n    height: rect.height * scale.y,\n    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,\n    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y\n  };\n}\n\nfunction getClientRects(element) {\n  return Array.from(element.getClientRects());\n}\n\n// Gets the entire size of the scrollable document area, even extending outside\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable.\nfunction getDocumentRect(element) {\n  const html = getDocumentElement(element);\n  const scroll = getNodeScroll(element);\n  const body = element.ownerDocument.body;\n  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);\n  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);\n  let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n  const y = -scroll.scrollTop;\n  if (getComputedStyle$1(body).direction === 'rtl') {\n    x += max(html.clientWidth, body.clientWidth) - width;\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\n// Safety check: ensure the scrollbar space is reasonable in case this\n// calculation is affected by unusual styles.\n// Most scrollbars leave 15-18px of space.\nconst SCROLLBAR_MAX = 25;\nfunction getViewportRect(element, strategy) {\n  const win = getWindow(element);\n  const html = getDocumentElement(element);\n  const visualViewport = win.visualViewport;\n  let width = html.clientWidth;\n  let height = html.clientHeight;\n  let x = 0;\n  let y = 0;\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n    const visualViewportBased = isWebKit();\n    if (!visualViewportBased || visualViewportBased && strategy === 'fixed') {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n  const windowScrollbarX = getWindowScrollBarX(html);\n  // <html> `overflow: hidden` + `scrollbar-gutter: stable` reduces the\n  // visual width of the <html> but this is not considered in the size\n  // of `html.clientWidth`.\n  if (windowScrollbarX <= 0) {\n    const doc = html.ownerDocument;\n    const body = doc.body;\n    const bodyStyles = getComputedStyle(body);\n    const bodyMarginInline = doc.compatMode === 'CSS1Compat' ? parseFloat(bodyStyles.marginLeft) + parseFloat(bodyStyles.marginRight) || 0 : 0;\n    const clippingStableScrollbarWidth = Math.abs(html.clientWidth - body.clientWidth - bodyMarginInline);\n    if (clippingStableScrollbarWidth <= SCROLLBAR_MAX) {\n      width -= clippingStableScrollbarWidth;\n    }\n  } else if (windowScrollbarX <= SCROLLBAR_MAX) {\n    // If the <body> scrollbar is on the left, the width needs to be extended\n    // by the scrollbar amount so there isn't extra space on the right.\n    width += windowScrollbarX;\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\nconst absoluteOrFixed = /*#__PURE__*/new Set(['absolute', 'fixed']);\n// Returns the inner client rect, subtracting scrollbars if present.\nfunction getInnerBoundingClientRect(element, strategy) {\n  const clientRect = getBoundingClientRect(element, true, strategy === 'fixed');\n  const top = clientRect.top + element.clientTop;\n  const left = clientRect.left + element.clientLeft;\n  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);\n  const width = element.clientWidth * scale.x;\n  const height = element.clientHeight * scale.y;\n  const x = left * scale.x;\n  const y = top * scale.y;\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\nfunction getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {\n  let rect;\n  if (clippingAncestor === 'viewport') {\n    rect = getViewportRect(element, strategy);\n  } else if (clippingAncestor === 'document') {\n    rect = getDocumentRect(getDocumentElement(element));\n  } else if (isElement(clippingAncestor)) {\n    rect = getInnerBoundingClientRect(clippingAncestor, strategy);\n  } else {\n    const visualOffsets = getVisualOffsets(element);\n    rect = {\n      x: clippingAncestor.x - visualOffsets.x,\n      y: clippingAncestor.y - visualOffsets.y,\n      width: clippingAncestor.width,\n      height: clippingAncestor.height\n    };\n  }\n  return rectToClientRect(rect);\n}\nfunction hasFixedPositionAncestor(element, stopNode) {\n  const parentNode = getParentNode(element);\n  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {\n    return false;\n  }\n  return getComputedStyle$1(parentNode).position === 'fixed' || hasFixedPositionAncestor(parentNode, stopNode);\n}\n\n// A \"clipping ancestor\" is an `overflow` element with the characteristic of\n// clipping (or hiding) child elements. This returns all clipping ancestors\n// of the given element up the tree.\nfunction getClippingElementAncestors(element, cache) {\n  const cachedResult = cache.get(element);\n  if (cachedResult) {\n    return cachedResult;\n  }\n  let result = getOverflowAncestors(element, [], false).filter(el => isElement(el) && getNodeName(el) !== 'body');\n  let currentContainingBlockComputedStyle = null;\n  const elementIsFixed = getComputedStyle$1(element).position === 'fixed';\n  let currentNode = elementIsFixed ? getParentNode(element) : element;\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    const computedStyle = getComputedStyle$1(currentNode);\n    const currentNodeIsContaining = isContainingBlock(currentNode);\n    if (!currentNodeIsContaining && computedStyle.position === 'fixed') {\n      currentContainingBlockComputedStyle = null;\n    }\n    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === 'static' && !!currentContainingBlockComputedStyle && absoluteOrFixed.has(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);\n    if (shouldDropCurrentNode) {\n      // Drop non-containing blocks.\n      result = result.filter(ancestor => ancestor !== currentNode);\n    } else {\n      // Record last containing block for next iteration.\n      currentContainingBlockComputedStyle = computedStyle;\n    }\n    currentNode = getParentNode(currentNode);\n  }\n  cache.set(element, result);\n  return result;\n}\n\n// Gets the maximum area that the element is visible in due to any number of\n// clipping ancestors.\nfunction getClippingRect(_ref) {\n  let {\n    element,\n    boundary,\n    rootBoundary,\n    strategy\n  } = _ref;\n  const elementClippingAncestors = boundary === 'clippingAncestors' ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);\n  const clippingAncestors = [...elementClippingAncestors, rootBoundary];\n  const firstClippingAncestor = clippingAncestors[0];\n  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {\n    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n    accRect.top = max(rect.top, accRect.top);\n    accRect.right = min(rect.right, accRect.right);\n    accRect.bottom = min(rect.bottom, accRect.bottom);\n    accRect.left = max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n  return {\n    width: clippingRect.right - clippingRect.left,\n    height: clippingRect.bottom - clippingRect.top,\n    x: clippingRect.left,\n    y: clippingRect.top\n  };\n}\n\nfunction getDimensions(element) {\n  const {\n    width,\n    height\n  } = getCssDimensions(element);\n  return {\n    width,\n    height\n  };\n}\n\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  const isFixed = strategy === 'fixed';\n  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = createCoords(0);\n\n  // If the <body> scrollbar appears on the left (e.g. RTL systems). Use\n  // Firefox with layout.scrollbar.side = 3 in about:config to test this.\n  function setLeftRTLScrollbarOffset() {\n    offsets.x = getWindowScrollBarX(documentElement);\n  }\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isOffsetParentAnElement) {\n      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } else if (documentElement) {\n      setLeftRTLScrollbarOffset();\n    }\n  }\n  if (isFixed && !isOffsetParentAnElement && documentElement) {\n    setLeftRTLScrollbarOffset();\n  }\n  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);\n  const x = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;\n  const y = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;\n  return {\n    x,\n    y,\n    width: rect.width,\n    height: rect.height\n  };\n}\n\nfunction isStaticPositioned(element) {\n  return getComputedStyle$1(element).position === 'static';\n}\n\nfunction getTrueOffsetParent(element, polyfill) {\n  if (!isHTMLElement(element) || getComputedStyle$1(element).position === 'fixed') {\n    return null;\n  }\n  if (polyfill) {\n    return polyfill(element);\n  }\n  let rawOffsetParent = element.offsetParent;\n\n  // Firefox returns the <html> element as the offsetParent if it's non-static,\n  // while Chrome and Safari return the <body> element. The <body> element must\n  // be used to perform the correct calculations even if the <html> element is\n  // non-static.\n  if (getDocumentElement(element) === rawOffsetParent) {\n    rawOffsetParent = rawOffsetParent.ownerDocument.body;\n  }\n  return rawOffsetParent;\n}\n\n// Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\nfunction getOffsetParent(element, polyfill) {\n  const win = getWindow(element);\n  if (isTopLayer(element)) {\n    return win;\n  }\n  if (!isHTMLElement(element)) {\n    let svgOffsetParent = getParentNode(element);\n    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {\n      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {\n        return svgOffsetParent;\n      }\n      svgOffsetParent = getParentNode(svgOffsetParent);\n    }\n    return win;\n  }\n  let offsetParent = getTrueOffsetParent(element, polyfill);\n  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {\n    offsetParent = getTrueOffsetParent(offsetParent, polyfill);\n  }\n  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {\n    return win;\n  }\n  return offsetParent || getContainingBlock(element) || win;\n}\n\nconst getElementRects = async function (data) {\n  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;\n  const getDimensionsFn = this.getDimensions;\n  const floatingDimensions = await getDimensionsFn(data.floating);\n  return {\n    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),\n    floating: {\n      x: 0,\n      y: 0,\n      width: floatingDimensions.width,\n      height: floatingDimensions.height\n    }\n  };\n};\n\nfunction isRTL(element) {\n  return getComputedStyle$1(element).direction === 'rtl';\n}\n\nconst platform = {\n  convertOffsetParentRelativeRectToViewportRelativeRect,\n  getDocumentElement,\n  getClippingRect,\n  getOffsetParent,\n  getElementRects,\n  getClientRects,\n  getDimensions,\n  getScale,\n  isElement,\n  isRTL\n};\n\nfunction rectsAreEqual(a, b) {\n  return a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height;\n}\n\n// https://samthor.au/2021/observing-dom/\nfunction observeMove(element, onMove) {\n  let io = null;\n  let timeoutId;\n  const root = getDocumentElement(element);\n  function cleanup() {\n    var _io;\n    clearTimeout(timeoutId);\n    (_io = io) == null || _io.disconnect();\n    io = null;\n  }\n  function refresh(skip, threshold) {\n    if (skip === void 0) {\n      skip = false;\n    }\n    if (threshold === void 0) {\n      threshold = 1;\n    }\n    cleanup();\n    const elementRectForRootMargin = element.getBoundingClientRect();\n    const {\n      left,\n      top,\n      width,\n      height\n    } = elementRectForRootMargin;\n    if (!skip) {\n      onMove();\n    }\n    if (!width || !height) {\n      return;\n    }\n    const insetTop = floor(top);\n    const insetRight = floor(root.clientWidth - (left + width));\n    const insetBottom = floor(root.clientHeight - (top + height));\n    const insetLeft = floor(left);\n    const rootMargin = -insetTop + \"px \" + -insetRight + \"px \" + -insetBottom + \"px \" + -insetLeft + \"px\";\n    const options = {\n      rootMargin,\n      threshold: max(0, min(1, threshold)) || 1\n    };\n    let isFirstUpdate = true;\n    function handleObserve(entries) {\n      const ratio = entries[0].intersectionRatio;\n      if (ratio !== threshold) {\n        if (!isFirstUpdate) {\n          return refresh();\n        }\n        if (!ratio) {\n          // If the reference is clipped, the ratio is 0. Throttle the refresh\n          // to prevent an infinite loop of updates.\n          timeoutId = setTimeout(() => {\n            refresh(false, 1e-7);\n          }, 1000);\n        } else {\n          refresh(false, ratio);\n        }\n      }\n      if (ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())) {\n        // It's possible that even though the ratio is reported as 1, the\n        // element is not actually fully within the IntersectionObserver's root\n        // area anymore. This can happen under performance constraints. This may\n        // be a bug in the browser's IntersectionObserver implementation. To\n        // work around this, we compare the element's bounding rect now with\n        // what it was at the time we created the IntersectionObserver. If they\n        // are not equal then the element moved, so we refresh.\n        refresh();\n      }\n      isFirstUpdate = false;\n    }\n\n    // Older browsers don't support a `document` as the root and will throw an\n    // error.\n    try {\n      io = new IntersectionObserver(handleObserve, {\n        ...options,\n        // Handle <iframe>s\n        root: root.ownerDocument\n      });\n    } catch (_e) {\n      io = new IntersectionObserver(handleObserve, options);\n    }\n    io.observe(element);\n  }\n  refresh(true);\n  return cleanup;\n}\n\n/**\n * Automatically updates the position of the floating element when necessary.\n * Should only be called when the floating element is mounted on the DOM or\n * visible on the screen.\n * @returns cleanup function that should be invoked when the floating element is\n * removed from the DOM or hidden from the screen.\n * @see https://floating-ui.com/docs/autoUpdate\n */\nfunction autoUpdate(reference, floating, update, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    ancestorScroll = true,\n    ancestorResize = true,\n    elementResize = typeof ResizeObserver === 'function',\n    layoutShift = typeof IntersectionObserver === 'function',\n    animationFrame = false\n  } = options;\n  const referenceEl = unwrapElement(reference);\n  const ancestors = ancestorScroll || ancestorResize ? [...(referenceEl ? getOverflowAncestors(referenceEl) : []), ...getOverflowAncestors(floating)] : [];\n  ancestors.forEach(ancestor => {\n    ancestorScroll && ancestor.addEventListener('scroll', update, {\n      passive: true\n    });\n    ancestorResize && ancestor.addEventListener('resize', update);\n  });\n  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;\n  let reobserveFrame = -1;\n  let resizeObserver = null;\n  if (elementResize) {\n    resizeObserver = new ResizeObserver(_ref => {\n      let [firstEntry] = _ref;\n      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {\n        // Prevent update loops when using the `size` middleware.\n        // https://github.com/floating-ui/floating-ui/issues/1740\n        resizeObserver.unobserve(floating);\n        cancelAnimationFrame(reobserveFrame);\n        reobserveFrame = requestAnimationFrame(() => {\n          var _resizeObserver;\n          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);\n        });\n      }\n      update();\n    });\n    if (referenceEl && !animationFrame) {\n      resizeObserver.observe(referenceEl);\n    }\n    resizeObserver.observe(floating);\n  }\n  let frameId;\n  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;\n  if (animationFrame) {\n    frameLoop();\n  }\n  function frameLoop() {\n    const nextRefRect = getBoundingClientRect(reference);\n    if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {\n      update();\n    }\n    prevRefRect = nextRefRect;\n    frameId = requestAnimationFrame(frameLoop);\n  }\n  update();\n  return () => {\n    var _resizeObserver2;\n    ancestors.forEach(ancestor => {\n      ancestorScroll && ancestor.removeEventListener('scroll', update);\n      ancestorResize && ancestor.removeEventListener('resize', update);\n    });\n    cleanupIo == null || cleanupIo();\n    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();\n    resizeObserver = null;\n    if (animationFrame) {\n      cancelAnimationFrame(frameId);\n    }\n  };\n}\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary on each side.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\nconst detectOverflow = detectOverflow$1;\n\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */\nconst offset = offset$1;\n\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = autoPlacement$1;\n\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = shift$1;\n\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = flip$1;\n\n/**\n * Provides data that allows you to change the size of the floating element —\n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = size$1;\n\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = hide$1;\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = arrow$1;\n\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = inline$1;\n\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = limitShift$1;\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a given reference element.\n */\nconst computePosition = (reference, floating, options) => {\n  // This caches the expensive `getClippingElementAncestors` function so that\n  // multiple lifecycle resets re-use the same result. It only lives for a\n  // single call. If other functions become expensive, we can add them as well.\n  const cache = new Map();\n  const mergedOptions = {\n    platform,\n    ...options\n  };\n  const platformWithCache = {\n    ...mergedOptions.platform,\n    _c: cache\n  };\n  return computePosition$1(reference, floating, {\n    ...mergedOptions,\n    platform: platformWithCache\n  });\n};\n\nexport { arrow, autoPlacement, autoUpdate, computePosition, detectOverflow, flip, hide, inline, limitShift, offset, platform, shift, size };\n","import createLucideIcon from '../createLucideIcon';\n\n/**\n * @component @name Network\n * @description Lucide SVG icon component, renders SVG Element with children.\n *\n * @preview ![img](data:image/svg+xml;base64,PHN2ZyAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogIHdpZHRoPSIyNCIKICBoZWlnaHQ9IjI0IgogIHZpZXdCb3g9IjAgMCAyNCAyNCIKICBmaWxsPSJub25lIgogIHN0cm9rZT0iIzAwMCIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6ICNmZmY7IGJvcmRlci1yYWRpdXM6IDJweCIKICBzdHJva2Utd2lkdGg9IjIiCiAgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIgogIHN0cm9rZS1saW5lam9pbj0icm91bmQiCj4KICA8cmVjdCB4PSIxNiIgeT0iMTYiIHdpZHRoPSI2IiBoZWlnaHQ9IjYiIHJ4PSIxIiAvPgogIDxyZWN0IHg9IjIiIHk9IjE2IiB3aWR0aD0iNiIgaGVpZ2h0PSI2IiByeD0iMSIgLz4KICA8cmVjdCB4PSI5IiB5PSIyIiB3aWR0aD0iNiIgaGVpZ2h0PSI2IiByeD0iMSIgLz4KICA8cGF0aCBkPSJNNSAxNnYtM2ExIDEgMCAwIDEgMS0xaDEyYTEgMSAwIDAgMSAxIDF2MyIgLz4KICA8cGF0aCBkPSJNMTIgMTJWOCIgLz4KPC9zdmc+Cg==) - https://lucide.dev/icons/network\n * @see https://lucide.dev/guide/packages/lucide-react - Documentation\n *\n * @param {Object} props - Lucide icons props and any valid SVG attribute\n * @returns {JSX.Element} JSX Element\n *\n */\nconst Network = createLucideIcon('Network', [\n  ['rect', { x: '16', y: '16', width: '6', height: '6', rx: '1', key: '4q2zg0' }],\n  ['rect', { x: '2', y: '16', width: '6', height: '6', rx: '1', key: '8cvhb9' }],\n  ['rect', { x: '9', y: '2', width: '6', height: '6', rx: '1', key: '1egb70' }],\n  ['path', { d: 'M5 16v-3a1 1 0 0 1 1-1h12a1 1 0 0 1 1 1v3', key: '1jsf9p' }],\n  ['path', { d: 'M12 12V8', key: '2874zd' }],\n]);\n\nexport default Network;\n","import createLucideIcon from '../createLucideIcon';\n\n/**\n * @component @name ListTodo\n * @description Lucide SVG icon component, renders SVG Element with children.\n *\n * @preview ![img](data:image/svg+xml;base64,PHN2ZyAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogIHdpZHRoPSIyNCIKICBoZWlnaHQ9IjI0IgogIHZpZXdCb3g9IjAgMCAyNCAyNCIKICBmaWxsPSJub25lIgogIHN0cm9rZT0iIzAwMCIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6ICNmZmY7IGJvcmRlci1yYWRpdXM6IDJweCIKICBzdHJva2Utd2lkdGg9IjIiCiAgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIgogIHN0cm9rZS1saW5lam9pbj0icm91bmQiCj4KICA8cmVjdCB4PSIzIiB5PSI1IiB3aWR0aD0iNiIgaGVpZ2h0PSI2IiByeD0iMSIgLz4KICA8cGF0aCBkPSJtMyAxNyAyIDIgNC00IiAvPgogIDxwYXRoIGQ9Ik0xMyA2aDgiIC8+CiAgPHBhdGggZD0iTTEzIDEyaDgiIC8+CiAgPHBhdGggZD0iTTEzIDE4aDgiIC8+Cjwvc3ZnPgo=) - https://lucide.dev/icons/list-todo\n * @see https://lucide.dev/guide/packages/lucide-react - Documentation\n *\n * @param {Object} props - Lucide icons props and any valid SVG attribute\n * @returns {JSX.Element} JSX Element\n *\n */\nconst ListTodo = createLucideIcon('ListTodo', [\n  ['rect', { x: '3', y: '5', width: '6', height: '6', rx: '1', key: '1defrl' }],\n  ['path', { d: 'm3 17 2 2 4-4', key: '1jhpwq' }],\n  ['path', { d: 'M13 6h8', key: '15sg57' }],\n  ['path', { d: 'M13 12h8', key: 'h98zly' }],\n  ['path', { d: 'M13 18h8', key: 'oe0vm4' }],\n]);\n\nexport default ListTodo;\n","import createLucideIcon from '../createLucideIcon';\n\n/**\n * @component @name LayoutDashboard\n * @description Lucide SVG icon component, renders SVG Element with children.\n *\n * @preview ![img](data:image/svg+xml;base64,PHN2ZyAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogIHdpZHRoPSIyNCIKICBoZWlnaHQ9IjI0IgogIHZpZXdCb3g9IjAgMCAyNCAyNCIKICBmaWxsPSJub25lIgogIHN0cm9rZT0iIzAwMCIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6ICNmZmY7IGJvcmRlci1yYWRpdXM6IDJweCIKICBzdHJva2Utd2lkdGg9IjIiCiAgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIgogIHN0cm9rZS1saW5lam9pbj0icm91bmQiCj4KICA8cmVjdCB3aWR0aD0iNyIgaGVpZ2h0PSI5IiB4PSIzIiB5PSIzIiByeD0iMSIgLz4KICA8cmVjdCB3aWR0aD0iNyIgaGVpZ2h0PSI1IiB4PSIxNCIgeT0iMyIgcng9IjEiIC8+CiAgPHJlY3Qgd2lkdGg9IjciIGhlaWdodD0iOSIgeD0iMTQiIHk9IjEyIiByeD0iMSIgLz4KICA8cmVjdCB3aWR0aD0iNyIgaGVpZ2h0PSI1IiB4PSIzIiB5PSIxNiIgcng9IjEiIC8+Cjwvc3ZnPgo=) - https://lucide.dev/icons/layout-dashboard\n * @see https://lucide.dev/guide/packages/lucide-react - Documentation\n *\n * @param {Object} props - Lucide icons props and any valid SVG attribute\n * @returns {JSX.Element} JSX Element\n *\n */\nconst LayoutDashboard = createLucideIcon('LayoutDashboard', [\n  ['rect', { width: '7', height: '9', x: '3', y: '3', rx: '1', key: '10lvy0' }],\n  ['rect', { width: '7', height: '5', x: '14', y: '3', rx: '1', key: '16une8' }],\n  ['rect', { width: '7', height: '9', x: '14', y: '12', rx: '1', key: '1hutg5' }],\n  ['rect', { width: '7', height: '5', x: '3', y: '16', rx: '1', key: 'ldoo1y' }],\n]);\n\nexport default LayoutDashboard;\n","import createLucideIcon from '../createLucideIcon';\n\n/**\n * @component @name Boxes\n * @description Lucide SVG icon component, renders SVG Element with children.\n *\n * @preview ![img](data:image/svg+xml;base64,PHN2ZyAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogIHdpZHRoPSIyNCIKICBoZWlnaHQ9IjI0IgogIHZpZXdCb3g9IjAgMCAyNCAyNCIKICBmaWxsPSJub25lIgogIHN0cm9rZT0iIzAwMCIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6ICNmZmY7IGJvcmRlci1yYWRpdXM6IDJweCIKICBzdHJva2Utd2lkdGg9IjIiCiAgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIgogIHN0cm9rZS1saW5lam9pbj0icm91bmQiCj4KICA8cGF0aCBkPSJNMi45NyAxMi45MkEyIDIgMCAwIDAgMiAxNC42M3YzLjI0YTIgMiAwIDAgMCAuOTcgMS43MWwzIDEuOGEyIDIgMCAwIDAgMi4wNiAwTDEyIDE5di01LjVsLTUtMy00LjAzIDIuNDJaIiAvPgogIDxwYXRoIGQ9Im03IDE2LjUtNC43NC0yLjg1IiAvPgogIDxwYXRoIGQ9Im03IDE2LjUgNS0zIiAvPgogIDxwYXRoIGQ9Ik03IDE2LjV2NS4xNyIgLz4KICA8cGF0aCBkPSJNMTIgMTMuNVYxOWwzLjk3IDIuMzhhMiAyIDAgMCAwIDIuMDYgMGwzLTEuOGEyIDIgMCAwIDAgLjk3LTEuNzF2LTMuMjRhMiAyIDAgMCAwLS45Ny0xLjcxTDE3IDEwLjVsLTUgM1oiIC8+CiAgPHBhdGggZD0ibTE3IDE2LjUtNS0zIiAvPgogIDxwYXRoIGQ9Im0xNyAxNi41IDQuNzQtMi44NSIgLz4KICA8cGF0aCBkPSJNMTcgMTYuNXY1LjE3IiAvPgogIDxwYXRoIGQ9Ik03Ljk3IDQuNDJBMiAyIDAgMCAwIDcgNi4xM3Y0LjM3bDUgMyA1LTNWNi4xM2EyIDIgMCAwIDAtLjk3LTEuNzFsLTMtMS44YTIgMiAwIDAgMC0yLjA2IDBsLTMgMS44WiIgLz4KICA8cGF0aCBkPSJNMTIgOCA3LjI2IDUuMTUiIC8+CiAgPHBhdGggZD0ibTEyIDggNC43NC0yLjg1IiAvPgogIDxwYXRoIGQ9Ik0xMiAxMy41VjgiIC8+Cjwvc3ZnPgo=) - https://lucide.dev/icons/boxes\n * @see https://lucide.dev/guide/packages/lucide-react - Documentation\n *\n * @param {Object} props - Lucide icons props and any valid SVG attribute\n * @returns {JSX.Element} JSX Element\n *\n */\nconst Boxes = createLucideIcon('Boxes', [\n  [\n    'path',\n    {\n      d: 'M2.97 12.92A2 2 0 0 0 2 14.63v3.24a2 2 0 0 0 .97 1.71l3 1.8a2 2 0 0 0 2.06 0L12 19v-5.5l-5-3-4.03 2.42Z',\n      key: 'lc1i9w',\n    },\n  ],\n  ['path', { d: 'm7 16.5-4.74-2.85', key: '1o9zyk' }],\n  ['path', { d: 'm7 16.5 5-3', key: 'va8pkn' }],\n  ['path', { d: 'M7 16.5v5.17', key: 'jnp8gn' }],\n  [\n    'path',\n    {\n      d: 'M12 13.5V19l3.97 2.38a2 2 0 0 0 2.06 0l3-1.8a2 2 0 0 0 .97-1.71v-3.24a2 2 0 0 0-.97-1.71L17 10.5l-5 3Z',\n      key: '8zsnat',\n    },\n  ],\n  ['path', { d: 'm17 16.5-5-3', key: '8arw3v' }],\n  ['path', { d: 'm17 16.5 4.74-2.85', key: '8rfmw' }],\n  ['path', { d: 'M17 16.5v5.17', key: 'k6z78m' }],\n  [\n    'path',\n    {\n      d: 'M7.97 4.42A2 2 0 0 0 7 6.13v4.37l5 3 5-3V6.13a2 2 0 0 0-.97-1.71l-3-1.8a2 2 0 0 0-2.06 0l-3 1.8Z',\n      key: '1xygjf',\n    },\n  ],\n  ['path', { d: 'M12 8 7.26 5.15', key: '1vbdud' }],\n  ['path', { d: 'm12 8 4.74-2.85', key: '3rx089' }],\n  ['path', { d: 'M12 13.5V8', key: '1io7kd' }],\n]);\n\nexport default Boxes;\n","import createLucideIcon from '../createLucideIcon';\n\n/**\n * @component @name PanelLeft\n * @description Lucide SVG icon component, renders SVG Element with children.\n *\n * @preview ![img](data:image/svg+xml;base64,PHN2ZyAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogIHdpZHRoPSIyNCIKICBoZWlnaHQ9IjI0IgogIHZpZXdCb3g9IjAgMCAyNCAyNCIKICBmaWxsPSJub25lIgogIHN0cm9rZT0iIzAwMCIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6ICNmZmY7IGJvcmRlci1yYWRpdXM6IDJweCIKICBzdHJva2Utd2lkdGg9IjIiCiAgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIgogIHN0cm9rZS1saW5lam9pbj0icm91bmQiCj4KICA8cmVjdCB3aWR0aD0iMTgiIGhlaWdodD0iMTgiIHg9IjMiIHk9IjMiIHJ4PSIyIiAvPgogIDxwYXRoIGQ9Ik05IDN2MTgiIC8+Cjwvc3ZnPgo=) - https://lucide.dev/icons/panel-left\n * @see https://lucide.dev/guide/packages/lucide-react - Documentation\n *\n * @param {Object} props - Lucide icons props and any valid SVG attribute\n * @returns {JSX.Element} JSX Element\n *\n */\nconst PanelLeft = createLucideIcon('PanelLeft', [\n  ['rect', { width: '18', height: '18', x: '3', y: '3', rx: '2', key: 'afitv7' }],\n  ['path', { d: 'M9 3v18', key: 'fh3hqa' }],\n]);\n\nexport default PanelLeft;\n","import createLucideIcon from '../createLucideIcon';\n\n/**\n * @component @name CirclePlus\n * @description Lucide SVG icon component, renders SVG Element with children.\n *\n * @preview ![img](data:image/svg+xml;base64,PHN2ZyAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogIHdpZHRoPSIyNCIKICBoZWlnaHQ9IjI0IgogIHZpZXdCb3g9IjAgMCAyNCAyNCIKICBmaWxsPSJub25lIgogIHN0cm9rZT0iIzAwMCIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6ICNmZmY7IGJvcmRlci1yYWRpdXM6IDJweCIKICBzdHJva2Utd2lkdGg9IjIiCiAgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIgogIHN0cm9rZS1saW5lam9pbj0icm91bmQiCj4KICA8Y2lyY2xlIGN4PSIxMiIgY3k9IjEyIiByPSIxMCIgLz4KICA8cGF0aCBkPSJNOCAxMmg4IiAvPgogIDxwYXRoIGQ9Ik0xMiA4djgiIC8+Cjwvc3ZnPgo=) - https://lucide.dev/icons/circle-plus\n * @see https://lucide.dev/guide/packages/lucide-react - Documentation\n *\n * @param {Object} props - Lucide icons props and any valid SVG attribute\n * @returns {JSX.Element} JSX Element\n *\n */\nconst CirclePlus = createLucideIcon('CirclePlus', [\n  ['circle', { cx: '12', cy: '12', r: '10', key: '1mglay' }],\n  ['path', { d: 'M8 12h8', key: '1wcyev' }],\n  ['path', { d: 'M12 8v8', key: 'napkw2' }],\n]);\n\nexport default CirclePlus;\n","import createLucideIcon from '../createLucideIcon';\n\n/**\n * @component @name FileText\n * @description Lucide SVG icon component, renders SVG Element with children.\n *\n * @preview ![img](data:image/svg+xml;base64,PHN2ZyAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogIHdpZHRoPSIyNCIKICBoZWlnaHQ9IjI0IgogIHZpZXdCb3g9IjAgMCAyNCAyNCIKICBmaWxsPSJub25lIgogIHN0cm9rZT0iIzAwMCIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6ICNmZmY7IGJvcmRlci1yYWRpdXM6IDJweCIKICBzdHJva2Utd2lkdGg9IjIiCiAgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIgogIHN0cm9rZS1saW5lam9pbj0icm91bmQiCj4KICA8cGF0aCBkPSJNMTUgMkg2YTIgMiAwIDAgMC0yIDJ2MTZhMiAyIDAgMCAwIDIgMmgxMmEyIDIgMCAwIDAgMi0yVjdaIiAvPgogIDxwYXRoIGQ9Ik0xNCAydjRhMiAyIDAgMCAwIDIgMmg0IiAvPgogIDxwYXRoIGQ9Ik0xMCA5SDgiIC8+CiAgPHBhdGggZD0iTTE2IDEzSDgiIC8+CiAgPHBhdGggZD0iTTE2IDE3SDgiIC8+Cjwvc3ZnPgo=) - https://lucide.dev/icons/file-text\n * @see https://lucide.dev/guide/packages/lucide-react - Documentation\n *\n * @param {Object} props - Lucide icons props and any valid SVG attribute\n * @returns {JSX.Element} JSX Element\n *\n */\nconst FileText = createLucideIcon('FileText', [\n  ['path', { d: 'M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z', key: '1rqfz7' }],\n  ['path', { d: 'M14 2v4a2 2 0 0 0 2 2h4', key: 'tnqrlb' }],\n  ['path', { d: 'M10 9H8', key: 'b1mrlr' }],\n  ['path', { d: 'M16 13H8', key: 't4e002' }],\n  ['path', { d: 'M16 17H8', key: 'z1uh3a' }],\n]);\n\nexport default FileText;\n","import createLucideIcon from '../createLucideIcon';\n\n/**\n * @component @name LogOut\n * @description Lucide SVG icon component, renders SVG Element with children.\n *\n * @preview ![img](data:image/svg+xml;base64,PHN2ZyAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogIHdpZHRoPSIyNCIKICBoZWlnaHQ9IjI0IgogIHZpZXdCb3g9IjAgMCAyNCAyNCIKICBmaWxsPSJub25lIgogIHN0cm9rZT0iIzAwMCIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6ICNmZmY7IGJvcmRlci1yYWRpdXM6IDJweCIKICBzdHJva2Utd2lkdGg9IjIiCiAgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIgogIHN0cm9rZS1saW5lam9pbj0icm91bmQiCj4KICA8cGF0aCBkPSJNOSAyMUg1YTIgMiAwIDAgMS0yLTJWNWEyIDIgMCAwIDEgMi0yaDQiIC8+CiAgPHBvbHlsaW5lIHBvaW50cz0iMTYgMTcgMjEgMTIgMTYgNyIgLz4KICA8bGluZSB4MT0iMjEiIHgyPSI5IiB5MT0iMTIiIHkyPSIxMiIgLz4KPC9zdmc+Cg==) - https://lucide.dev/icons/log-out\n * @see https://lucide.dev/guide/packages/lucide-react - Documentation\n *\n * @param {Object} props - Lucide icons props and any valid SVG attribute\n * @returns {JSX.Element} JSX Element\n *\n */\nconst LogOut = createLucideIcon('LogOut', [\n  ['path', { d: 'M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4', key: '1uf3rs' }],\n  ['polyline', { points: '16 17 21 12 16 7', key: '1gabdz' }],\n  ['line', { x1: '21', x2: '9', y1: '12', y2: '12', key: '1uyos4' }],\n]);\n\nexport default LogOut;\n","/// <reference types=\"resize-observer-browser\" />\n\nimport * as React from 'react';\nimport { useLayoutEffect } from '@radix-ui/react-use-layout-effect';\n\nfunction useSize(element: HTMLElement | null) {\n  const [size, setSize] = React.useState<{ width: number; height: number } | undefined>(undefined);\n\n  useLayoutEffect(() => {\n    if (element) {\n      // provide size as early as possible\n      setSize({ width: element.offsetWidth, height: element.offsetHeight });\n\n      const resizeObserver = new ResizeObserver((entries) => {\n        if (!Array.isArray(entries)) {\n          return;\n        }\n\n        // Since we only observe the one element, we don't need to loop over the\n        // array\n        if (!entries.length) {\n          return;\n        }\n\n        const entry = entries[0];\n        let width: number;\n        let height: number;\n\n        if ('borderBoxSize' in entry) {\n          const borderSizeEntry = entry['borderBoxSize'];\n          // iron out differences between browsers\n          const borderSize = Array.isArray(borderSizeEntry) ? borderSizeEntry[0] : borderSizeEntry;\n          width = borderSize['inlineSize'];\n          height = borderSize['blockSize'];\n        } else {\n          // for browsers that don't support `borderBoxSize`\n          // we calculate it ourselves to get the correct border box.\n          width = element.offsetWidth;\n          height = element.offsetHeight;\n        }\n\n        setSize({ width, height });\n      });\n\n      resizeObserver.observe(element, { box: 'border-box' });\n\n      return () => resizeObserver.unobserve(element);\n    } else {\n      // We only want to reset to `undefined` when the element becomes `null`,\n      // not if it changes to another element.\n      setSize(undefined);\n    }\n  }, [element]);\n\n  return size;\n}\n\nexport { useSize };\n","import * as React from 'react';\nimport {\n  useFloating,\n  autoUpdate,\n  offset,\n  shift,\n  limitShift,\n  hide,\n  arrow as floatingUIarrow,\n  flip,\n  size,\n} from '@floating-ui/react-dom';\nimport * as ArrowPrimitive from '@radix-ui/react-arrow';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { createContextScope } from '@radix-ui/react-context';\nimport { Primitive } from '@radix-ui/react-primitive';\nimport { useCallbackRef } from '@radix-ui/react-use-callback-ref';\nimport { useLayoutEffect } from '@radix-ui/react-use-layout-effect';\nimport { useSize } from '@radix-ui/react-use-size';\n\nimport type { Placement, Middleware } from '@floating-ui/react-dom';\nimport type { Scope } from '@radix-ui/react-context';\nimport type { Measurable } from '@radix-ui/rect';\n\nconst SIDE_OPTIONS = ['top', 'right', 'bottom', 'left'] as const;\nconst ALIGN_OPTIONS = ['start', 'center', 'end'] as const;\n\ntype Side = (typeof SIDE_OPTIONS)[number];\ntype Align = (typeof ALIGN_OPTIONS)[number];\n\n/* -------------------------------------------------------------------------------------------------\n * Popper\n * -----------------------------------------------------------------------------------------------*/\n\nconst POPPER_NAME = 'Popper';\n\ntype ScopedProps<P> = P & { __scopePopper?: Scope };\nconst [createPopperContext, createPopperScope] = createContextScope(POPPER_NAME);\n\ntype PopperContextValue = {\n  anchor: Measurable | null;\n  onAnchorChange(anchor: Measurable | null): void;\n};\nconst [PopperProvider, usePopperContext] = createPopperContext<PopperContextValue>(POPPER_NAME);\n\ninterface PopperProps {\n  children?: React.ReactNode;\n}\nconst Popper: React.FC<PopperProps> = (props: ScopedProps<PopperProps>) => {\n  const { __scopePopper, children } = props;\n  const [anchor, setAnchor] = React.useState<Measurable | null>(null);\n  return (\n    <PopperProvider scope={__scopePopper} anchor={anchor} onAnchorChange={setAnchor}>\n      {children}\n    </PopperProvider>\n  );\n};\n\nPopper.displayName = POPPER_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * PopperAnchor\n * -----------------------------------------------------------------------------------------------*/\n\nconst ANCHOR_NAME = 'PopperAnchor';\n\ntype PopperAnchorElement = React.ElementRef<typeof Primitive.div>;\ntype PrimitiveDivProps = React.ComponentPropsWithoutRef<typeof Primitive.div>;\ninterface PopperAnchorProps extends PrimitiveDivProps {\n  virtualRef?: React.RefObject<Measurable>;\n}\n\nconst PopperAnchor = React.forwardRef<PopperAnchorElement, PopperAnchorProps>(\n  (props: ScopedProps<PopperAnchorProps>, forwardedRef) => {\n    const { __scopePopper, virtualRef, ...anchorProps } = props;\n    const context = usePopperContext(ANCHOR_NAME, __scopePopper);\n    const ref = React.useRef<PopperAnchorElement>(null);\n    const composedRefs = useComposedRefs(forwardedRef, ref);\n\n    React.useEffect(() => {\n      // Consumer can anchor the popper to something that isn't\n      // a DOM node e.g. pointer position, so we override the\n      // `anchorRef` with their virtual ref in this case.\n      context.onAnchorChange(virtualRef?.current || ref.current);\n    });\n\n    return virtualRef ? null : <Primitive.div {...anchorProps} ref={composedRefs} />;\n  }\n);\n\nPopperAnchor.displayName = ANCHOR_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * PopperContent\n * -----------------------------------------------------------------------------------------------*/\n\nconst CONTENT_NAME = 'PopperContent';\n\ntype PopperContentContextValue = {\n  placedSide: Side;\n  onArrowChange(arrow: HTMLSpanElement | null): void;\n  arrowX?: number;\n  arrowY?: number;\n  shouldHideArrow: boolean;\n};\n\nconst [PopperContentProvider, useContentContext] =\n  createPopperContext<PopperContentContextValue>(CONTENT_NAME);\n\ntype Boundary = Element | null;\n\ntype PopperContentElement = React.ElementRef<typeof Primitive.div>;\ninterface PopperContentProps extends PrimitiveDivProps {\n  side?: Side;\n  sideOffset?: number;\n  align?: Align;\n  alignOffset?: number;\n  arrowPadding?: number;\n  avoidCollisions?: boolean;\n  collisionBoundary?: Boundary | Boundary[];\n  collisionPadding?: number | Partial<Record<Side, number>>;\n  sticky?: 'partial' | 'always';\n  hideWhenDetached?: boolean;\n  updatePositionStrategy?: 'optimized' | 'always';\n  onPlaced?: () => void;\n}\n\nconst PopperContent = React.forwardRef<PopperContentElement, PopperContentProps>(\n  (props: ScopedProps<PopperContentProps>, forwardedRef) => {\n    const {\n      __scopePopper,\n      side = 'bottom',\n      sideOffset = 0,\n      align = 'center',\n      alignOffset = 0,\n      arrowPadding = 0,\n      avoidCollisions = true,\n      collisionBoundary = [],\n      collisionPadding: collisionPaddingProp = 0,\n      sticky = 'partial',\n      hideWhenDetached = false,\n      updatePositionStrategy = 'optimized',\n      onPlaced,\n      ...contentProps\n    } = props;\n\n    const context = usePopperContext(CONTENT_NAME, __scopePopper);\n\n    const [content, setContent] = React.useState<HTMLDivElement | null>(null);\n    const composedRefs = useComposedRefs(forwardedRef, (node) => setContent(node));\n\n    const [arrow, setArrow] = React.useState<HTMLSpanElement | null>(null);\n    const arrowSize = useSize(arrow);\n    const arrowWidth = arrowSize?.width ?? 0;\n    const arrowHeight = arrowSize?.height ?? 0;\n\n    const desiredPlacement = (side + (align !== 'center' ? '-' + align : '')) as Placement;\n\n    const collisionPadding =\n      typeof collisionPaddingProp === 'number'\n        ? collisionPaddingProp\n        : { top: 0, right: 0, bottom: 0, left: 0, ...collisionPaddingProp };\n\n    const boundary = Array.isArray(collisionBoundary) ? collisionBoundary : [collisionBoundary];\n    const hasExplicitBoundaries = boundary.length > 0;\n\n    const detectOverflowOptions = {\n      padding: collisionPadding,\n      boundary: boundary.filter(isNotNull),\n      // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries\n      altBoundary: hasExplicitBoundaries,\n    };\n\n    const { refs, floatingStyles, placement, isPositioned, middlewareData } = useFloating({\n      // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues\n      strategy: 'fixed',\n      placement: desiredPlacement,\n      whileElementsMounted: (...args) => {\n        const cleanup = autoUpdate(...args, {\n          animationFrame: updatePositionStrategy === 'always',\n        });\n        return cleanup;\n      },\n      elements: {\n        reference: context.anchor,\n      },\n      middleware: [\n        offset({ mainAxis: sideOffset + arrowHeight, alignmentAxis: alignOffset }),\n        avoidCollisions &&\n          shift({\n            mainAxis: true,\n            crossAxis: false,\n            limiter: sticky === 'partial' ? limitShift() : undefined,\n            ...detectOverflowOptions,\n          }),\n        avoidCollisions && flip({ ...detectOverflowOptions }),\n        size({\n          ...detectOverflowOptions,\n          apply: ({ elements, rects, availableWidth, availableHeight }) => {\n            const { width: anchorWidth, height: anchorHeight } = rects.reference;\n            const contentStyle = elements.floating.style;\n            contentStyle.setProperty('--radix-popper-available-width', `${availableWidth}px`);\n            contentStyle.setProperty('--radix-popper-available-height', `${availableHeight}px`);\n            contentStyle.setProperty('--radix-popper-anchor-width', `${anchorWidth}px`);\n            contentStyle.setProperty('--radix-popper-anchor-height', `${anchorHeight}px`);\n          },\n        }),\n        arrow && floatingUIarrow({ element: arrow, padding: arrowPadding }),\n        transformOrigin({ arrowWidth, arrowHeight }),\n        hideWhenDetached && hide({ strategy: 'referenceHidden', ...detectOverflowOptions }),\n      ],\n    });\n\n    const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);\n\n    const handlePlaced = useCallbackRef(onPlaced);\n    useLayoutEffect(() => {\n      if (isPositioned) {\n        handlePlaced?.();\n      }\n    }, [isPositioned, handlePlaced]);\n\n    const arrowX = middlewareData.arrow?.x;\n    const arrowY = middlewareData.arrow?.y;\n    const cannotCenterArrow = middlewareData.arrow?.centerOffset !== 0;\n\n    const [contentZIndex, setContentZIndex] = React.useState<string>();\n    useLayoutEffect(() => {\n      if (content) setContentZIndex(window.getComputedStyle(content).zIndex);\n    }, [content]);\n\n    return (\n      <div\n        ref={refs.setFloating}\n        data-radix-popper-content-wrapper=\"\"\n        style={{\n          ...floatingStyles,\n          transform: isPositioned ? floatingStyles.transform : 'translate(0, -200%)', // keep off the page when measuring\n          minWidth: 'max-content',\n          zIndex: contentZIndex,\n          ['--radix-popper-transform-origin' as any]: [\n            middlewareData.transformOrigin?.x,\n            middlewareData.transformOrigin?.y,\n          ].join(' '),\n\n          // hide the content if using the hide middleware and should be hidden\n          // set visibility to hidden and disable pointer events so the UI behaves\n          // as if the PopperContent isn't there at all\n          ...(middlewareData.hide?.referenceHidden && {\n            visibility: 'hidden',\n            pointerEvents: 'none',\n          }),\n        }}\n        // Floating UI interally calculates logical alignment based the `dir` attribute on\n        // the reference/floating node, we must add this attribute here to ensure\n        // this is calculated when portalled as well as inline.\n        dir={props.dir}\n      >\n        <PopperContentProvider\n          scope={__scopePopper}\n          placedSide={placedSide}\n          onArrowChange={setArrow}\n          arrowX={arrowX}\n          arrowY={arrowY}\n          shouldHideArrow={cannotCenterArrow}\n        >\n          <Primitive.div\n            data-side={placedSide}\n            data-align={placedAlign}\n            {...contentProps}\n            ref={composedRefs}\n            style={{\n              ...contentProps.style,\n              // if the PopperContent hasn't been placed yet (not all measurements done)\n              // we prevent animations so that users's animation don't kick in too early referring wrong sides\n              animation: !isPositioned ? 'none' : undefined,\n            }}\n          />\n        </PopperContentProvider>\n      </div>\n    );\n  }\n);\n\nPopperContent.displayName = CONTENT_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * PopperArrow\n * -----------------------------------------------------------------------------------------------*/\n\nconst ARROW_NAME = 'PopperArrow';\n\nconst OPPOSITE_SIDE: Record<Side, Side> = {\n  top: 'bottom',\n  right: 'left',\n  bottom: 'top',\n  left: 'right',\n};\n\ntype PopperArrowElement = React.ElementRef<typeof ArrowPrimitive.Root>;\ntype ArrowProps = React.ComponentPropsWithoutRef<typeof ArrowPrimitive.Root>;\ninterface PopperArrowProps extends ArrowProps {}\n\nconst PopperArrow = React.forwardRef<PopperArrowElement, PopperArrowProps>(function PopperArrow(\n  props: ScopedProps<PopperArrowProps>,\n  forwardedRef\n) {\n  const { __scopePopper, ...arrowProps } = props;\n  const contentContext = useContentContext(ARROW_NAME, __scopePopper);\n  const baseSide = OPPOSITE_SIDE[contentContext.placedSide];\n\n  return (\n    // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)\n    // doesn't report size as we'd expect on SVG elements.\n    // it reports their bounding box which is effectively the largest path inside the SVG.\n    <span\n      ref={contentContext.onArrowChange}\n      style={{\n        position: 'absolute',\n        left: contentContext.arrowX,\n        top: contentContext.arrowY,\n        [baseSide]: 0,\n        transformOrigin: {\n          top: '',\n          right: '0 0',\n          bottom: 'center 0',\n          left: '100% 0',\n        }[contentContext.placedSide],\n        transform: {\n          top: 'translateY(100%)',\n          right: 'translateY(50%) rotate(90deg) translateX(-50%)',\n          bottom: `rotate(180deg)`,\n          left: 'translateY(50%) rotate(-90deg) translateX(50%)',\n        }[contentContext.placedSide],\n        visibility: contentContext.shouldHideArrow ? 'hidden' : undefined,\n      }}\n    >\n      <ArrowPrimitive.Root\n        {...arrowProps}\n        ref={forwardedRef}\n        style={{\n          ...arrowProps.style,\n          // ensures the element can be measured correctly (mostly for if SVG)\n          display: 'block',\n        }}\n      />\n    </span>\n  );\n});\n\nPopperArrow.displayName = ARROW_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\nfunction isNotNull<T>(value: T | null): value is T {\n  return value !== null;\n}\n\nconst transformOrigin = (options: { arrowWidth: number; arrowHeight: number }): Middleware => ({\n  name: 'transformOrigin',\n  options,\n  fn(data) {\n    const { placement, rects, middlewareData } = data;\n\n    const cannotCenterArrow = middlewareData.arrow?.centerOffset !== 0;\n    const isArrowHidden = cannotCenterArrow;\n    const arrowWidth = isArrowHidden ? 0 : options.arrowWidth;\n    const arrowHeight = isArrowHidden ? 0 : options.arrowHeight;\n\n    const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);\n    const noArrowAlign = { start: '0%', center: '50%', end: '100%' }[placedAlign];\n\n    const arrowXCenter = (middlewareData.arrow?.x ?? 0) + arrowWidth / 2;\n    const arrowYCenter = (middlewareData.arrow?.y ?? 0) + arrowHeight / 2;\n\n    let x = '';\n    let y = '';\n\n    if (placedSide === 'bottom') {\n      x = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;\n      y = `${-arrowHeight}px`;\n    } else if (placedSide === 'top') {\n      x = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;\n      y = `${rects.floating.height + arrowHeight}px`;\n    } else if (placedSide === 'right') {\n      x = `${-arrowHeight}px`;\n      y = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;\n    } else if (placedSide === 'left') {\n      x = `${rects.floating.width + arrowHeight}px`;\n      y = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;\n    }\n    return { data: { x, y } };\n  },\n});\n\nfunction getSideAndAlignFromPlacement(placement: Placement) {\n  const [side, align = 'center'] = placement.split('-');\n  return [side as Side, align as Align] as const;\n}\n\nconst Root = Popper;\nconst Anchor = PopperAnchor;\nconst Content = PopperContent;\nconst Arrow = PopperArrow;\n\nexport {\n  createPopperScope,\n  //\n  Popper,\n  PopperAnchor,\n  PopperContent,\n  PopperArrow,\n  //\n  Root,\n  Anchor,\n  Content,\n  Arrow,\n  //\n  SIDE_OPTIONS,\n  ALIGN_OPTIONS,\n};\nexport type { PopperProps, PopperAnchorProps, PopperContentProps, PopperArrowProps };\n","import * as React from 'react';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { createContextScope } from '@radix-ui/react-context';\nimport { DismissableLayer } from '@radix-ui/react-dismissable-layer';\nimport { useId } from '@radix-ui/react-id';\nimport * as PopperPrimitive from '@radix-ui/react-popper';\nimport { createPopperScope } from '@radix-ui/react-popper';\nimport { Portal as PortalPrimitive } from '@radix-ui/react-portal';\nimport { Presence } from '@radix-ui/react-presence';\nimport { Primitive } from '@radix-ui/react-primitive';\nimport { Slottable } from '@radix-ui/react-slot';\nimport { useControllableState } from '@radix-ui/react-use-controllable-state';\nimport * as VisuallyHiddenPrimitive from '@radix-ui/react-visually-hidden';\n\nimport type { Scope } from '@radix-ui/react-context';\n\ntype ScopedProps<P = {}> = P & { __scopeTooltip?: Scope };\nconst [createTooltipContext, createTooltipScope] = createContextScope('Tooltip', [\n  createPopperScope,\n]);\nconst usePopperScope = createPopperScope();\n\n/* -------------------------------------------------------------------------------------------------\n * TooltipProvider\n * -----------------------------------------------------------------------------------------------*/\n\nconst PROVIDER_NAME = 'TooltipProvider';\nconst DEFAULT_DELAY_DURATION = 700;\nconst TOOLTIP_OPEN = 'tooltip.open';\n\ntype TooltipProviderContextValue = {\n  isOpenDelayed: boolean;\n  delayDuration: number;\n  onOpen(): void;\n  onClose(): void;\n  onPointerInTransitChange(inTransit: boolean): void;\n  isPointerInTransitRef: React.MutableRefObject<boolean>;\n  disableHoverableContent: boolean;\n};\n\nconst [TooltipProviderContextProvider, useTooltipProviderContext] =\n  createTooltipContext<TooltipProviderContextValue>(PROVIDER_NAME);\n\ninterface TooltipProviderProps {\n  children: React.ReactNode;\n  /**\n   * The duration from when the pointer enters the trigger until the tooltip gets opened.\n   * @defaultValue 700\n   */\n  delayDuration?: number;\n  /**\n   * How much time a user has to enter another trigger without incurring a delay again.\n   * @defaultValue 300\n   */\n  skipDelayDuration?: number;\n  /**\n   * When `true`, trying to hover the content will result in the tooltip closing as the pointer leaves the trigger.\n   * @defaultValue false\n   */\n  disableHoverableContent?: boolean;\n}\n\nconst TooltipProvider: React.FC<TooltipProviderProps> = (\n  props: ScopedProps<TooltipProviderProps>\n) => {\n  const {\n    __scopeTooltip,\n    delayDuration = DEFAULT_DELAY_DURATION,\n    skipDelayDuration = 300,\n    disableHoverableContent = false,\n    children,\n  } = props;\n  const [isOpenDelayed, setIsOpenDelayed] = React.useState(true);\n  const isPointerInTransitRef = React.useRef(false);\n  const skipDelayTimerRef = React.useRef(0);\n\n  React.useEffect(() => {\n    const skipDelayTimer = skipDelayTimerRef.current;\n    return () => window.clearTimeout(skipDelayTimer);\n  }, []);\n\n  return (\n    <TooltipProviderContextProvider\n      scope={__scopeTooltip}\n      isOpenDelayed={isOpenDelayed}\n      delayDuration={delayDuration}\n      onOpen={React.useCallback(() => {\n        window.clearTimeout(skipDelayTimerRef.current);\n        setIsOpenDelayed(false);\n      }, [])}\n      onClose={React.useCallback(() => {\n        window.clearTimeout(skipDelayTimerRef.current);\n        skipDelayTimerRef.current = window.setTimeout(\n          () => setIsOpenDelayed(true),\n          skipDelayDuration\n        );\n      }, [skipDelayDuration])}\n      isPointerInTransitRef={isPointerInTransitRef}\n      onPointerInTransitChange={React.useCallback((inTransit: boolean) => {\n        isPointerInTransitRef.current = inTransit;\n      }, [])}\n      disableHoverableContent={disableHoverableContent}\n    >\n      {children}\n    </TooltipProviderContextProvider>\n  );\n};\n\nTooltipProvider.displayName = PROVIDER_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * Tooltip\n * -----------------------------------------------------------------------------------------------*/\n\nconst TOOLTIP_NAME = 'Tooltip';\n\ntype TooltipContextValue = {\n  contentId: string;\n  open: boolean;\n  stateAttribute: 'closed' | 'delayed-open' | 'instant-open';\n  trigger: TooltipTriggerElement | null;\n  onTriggerChange(trigger: TooltipTriggerElement | null): void;\n  onTriggerEnter(): void;\n  onTriggerLeave(): void;\n  onOpen(): void;\n  onClose(): void;\n  disableHoverableContent: boolean;\n};\n\nconst [TooltipContextProvider, useTooltipContext] =\n  createTooltipContext<TooltipContextValue>(TOOLTIP_NAME);\n\ninterface TooltipProps {\n  children?: React.ReactNode;\n  open?: boolean;\n  defaultOpen?: boolean;\n  onOpenChange?: (open: boolean) => void;\n  /**\n   * The duration from when the pointer enters the trigger until the tooltip gets opened. This will\n   * override the prop with the same name passed to Provider.\n   * @defaultValue 700\n   */\n  delayDuration?: number;\n  /**\n   * When `true`, trying to hover the content will result in the tooltip closing as the pointer leaves the trigger.\n   * @defaultValue false\n   */\n  disableHoverableContent?: boolean;\n}\n\nconst Tooltip: React.FC<TooltipProps> = (props: ScopedProps<TooltipProps>) => {\n  const {\n    __scopeTooltip,\n    children,\n    open: openProp,\n    defaultOpen = false,\n    onOpenChange,\n    disableHoverableContent: disableHoverableContentProp,\n    delayDuration: delayDurationProp,\n  } = props;\n  const providerContext = useTooltipProviderContext(TOOLTIP_NAME, props.__scopeTooltip);\n  const popperScope = usePopperScope(__scopeTooltip);\n  const [trigger, setTrigger] = React.useState<HTMLButtonElement | null>(null);\n  const contentId = useId();\n  const openTimerRef = React.useRef(0);\n  const disableHoverableContent =\n    disableHoverableContentProp ?? providerContext.disableHoverableContent;\n  const delayDuration = delayDurationProp ?? providerContext.delayDuration;\n  const wasOpenDelayedRef = React.useRef(false);\n  const [open = false, setOpen] = useControllableState({\n    prop: openProp,\n    defaultProp: defaultOpen,\n    onChange: (open) => {\n      if (open) {\n        providerContext.onOpen();\n\n        // as `onChange` is called within a lifecycle method we\n        // avoid dispatching via `dispatchDiscreteCustomEvent`.\n        document.dispatchEvent(new CustomEvent(TOOLTIP_OPEN));\n      } else {\n        providerContext.onClose();\n      }\n      onOpenChange?.(open);\n    },\n  });\n  const stateAttribute = React.useMemo(() => {\n    return open ? (wasOpenDelayedRef.current ? 'delayed-open' : 'instant-open') : 'closed';\n  }, [open]);\n\n  const handleOpen = React.useCallback(() => {\n    window.clearTimeout(openTimerRef.current);\n    openTimerRef.current = 0;\n    wasOpenDelayedRef.current = false;\n    setOpen(true);\n  }, [setOpen]);\n\n  const handleClose = React.useCallback(() => {\n    window.clearTimeout(openTimerRef.current);\n    openTimerRef.current = 0;\n    setOpen(false);\n  }, [setOpen]);\n\n  const handleDelayedOpen = React.useCallback(() => {\n    window.clearTimeout(openTimerRef.current);\n    openTimerRef.current = window.setTimeout(() => {\n      wasOpenDelayedRef.current = true;\n      setOpen(true);\n      openTimerRef.current = 0;\n    }, delayDuration);\n  }, [delayDuration, setOpen]);\n\n  React.useEffect(() => {\n    return () => {\n      if (openTimerRef.current) {\n        window.clearTimeout(openTimerRef.current);\n        openTimerRef.current = 0;\n      }\n    };\n  }, []);\n\n  return (\n    <PopperPrimitive.Root {...popperScope}>\n      <TooltipContextProvider\n        scope={__scopeTooltip}\n        contentId={contentId}\n        open={open}\n        stateAttribute={stateAttribute}\n        trigger={trigger}\n        onTriggerChange={setTrigger}\n        onTriggerEnter={React.useCallback(() => {\n          if (providerContext.isOpenDelayed) handleDelayedOpen();\n          else handleOpen();\n        }, [providerContext.isOpenDelayed, handleDelayedOpen, handleOpen])}\n        onTriggerLeave={React.useCallback(() => {\n          if (disableHoverableContent) {\n            handleClose();\n          } else {\n            // Clear the timer in case the pointer leaves the trigger before the tooltip is opened.\n            window.clearTimeout(openTimerRef.current);\n            openTimerRef.current = 0;\n          }\n        }, [handleClose, disableHoverableContent])}\n        onOpen={handleOpen}\n        onClose={handleClose}\n        disableHoverableContent={disableHoverableContent}\n      >\n        {children}\n      </TooltipContextProvider>\n    </PopperPrimitive.Root>\n  );\n};\n\nTooltip.displayName = TOOLTIP_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * TooltipTrigger\n * -----------------------------------------------------------------------------------------------*/\n\nconst TRIGGER_NAME = 'TooltipTrigger';\n\ntype TooltipTriggerElement = React.ElementRef<typeof Primitive.button>;\ntype PrimitiveButtonProps = React.ComponentPropsWithoutRef<typeof Primitive.button>;\ninterface TooltipTriggerProps extends PrimitiveButtonProps {}\n\nconst TooltipTrigger = React.forwardRef<TooltipTriggerElement, TooltipTriggerProps>(\n  (props: ScopedProps<TooltipTriggerProps>, forwardedRef) => {\n    const { __scopeTooltip, ...triggerProps } = props;\n    const context = useTooltipContext(TRIGGER_NAME, __scopeTooltip);\n    const providerContext = useTooltipProviderContext(TRIGGER_NAME, __scopeTooltip);\n    const popperScope = usePopperScope(__scopeTooltip);\n    const ref = React.useRef<TooltipTriggerElement>(null);\n    const composedRefs = useComposedRefs(forwardedRef, ref, context.onTriggerChange);\n    const isPointerDownRef = React.useRef(false);\n    const hasPointerMoveOpenedRef = React.useRef(false);\n    const handlePointerUp = React.useCallback(() => (isPointerDownRef.current = false), []);\n\n    React.useEffect(() => {\n      return () => document.removeEventListener('pointerup', handlePointerUp);\n    }, [handlePointerUp]);\n\n    return (\n      <PopperPrimitive.Anchor asChild {...popperScope}>\n        <Primitive.button\n          // We purposefully avoid adding `type=button` here because tooltip triggers are also\n          // commonly anchors and the anchor `type` attribute signifies MIME type.\n          aria-describedby={context.open ? context.contentId : undefined}\n          data-state={context.stateAttribute}\n          {...triggerProps}\n          ref={composedRefs}\n          onPointerMove={composeEventHandlers(props.onPointerMove, (event) => {\n            if (event.pointerType === 'touch') return;\n            if (\n              !hasPointerMoveOpenedRef.current &&\n              !providerContext.isPointerInTransitRef.current\n            ) {\n              context.onTriggerEnter();\n              hasPointerMoveOpenedRef.current = true;\n            }\n          })}\n          onPointerLeave={composeEventHandlers(props.onPointerLeave, () => {\n            context.onTriggerLeave();\n            hasPointerMoveOpenedRef.current = false;\n          })}\n          onPointerDown={composeEventHandlers(props.onPointerDown, () => {\n            isPointerDownRef.current = true;\n            document.addEventListener('pointerup', handlePointerUp, { once: true });\n          })}\n          onFocus={composeEventHandlers(props.onFocus, () => {\n            if (!isPointerDownRef.current) context.onOpen();\n          })}\n          onBlur={composeEventHandlers(props.onBlur, context.onClose)}\n          onClick={composeEventHandlers(props.onClick, context.onClose)}\n        />\n      </PopperPrimitive.Anchor>\n    );\n  }\n);\n\nTooltipTrigger.displayName = TRIGGER_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * TooltipPortal\n * -----------------------------------------------------------------------------------------------*/\n\nconst PORTAL_NAME = 'TooltipPortal';\n\ntype PortalContextValue = { forceMount?: true };\nconst [PortalProvider, usePortalContext] = createTooltipContext<PortalContextValue>(PORTAL_NAME, {\n  forceMount: undefined,\n});\n\ntype PortalProps = React.ComponentPropsWithoutRef<typeof PortalPrimitive>;\ninterface TooltipPortalProps {\n  children?: React.ReactNode;\n  /**\n   * Specify a container element to portal the content into.\n   */\n  container?: PortalProps['container'];\n  /**\n   * Used to force mounting when more control is needed. Useful when\n   * controlling animation with React animation libraries.\n   */\n  forceMount?: true;\n}\n\nconst TooltipPortal: React.FC<TooltipPortalProps> = (props: ScopedProps<TooltipPortalProps>) => {\n  const { __scopeTooltip, forceMount, children, container } = props;\n  const context = useTooltipContext(PORTAL_NAME, __scopeTooltip);\n  return (\n    <PortalProvider scope={__scopeTooltip} forceMount={forceMount}>\n      <Presence present={forceMount || context.open}>\n        <PortalPrimitive asChild container={container}>\n          {children}\n        </PortalPrimitive>\n      </Presence>\n    </PortalProvider>\n  );\n};\n\nTooltipPortal.displayName = PORTAL_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * TooltipContent\n * -----------------------------------------------------------------------------------------------*/\n\nconst CONTENT_NAME = 'TooltipContent';\n\ntype TooltipContentElement = TooltipContentImplElement;\ninterface TooltipContentProps extends TooltipContentImplProps {\n  /**\n   * Used to force mounting when more control is needed. Useful when\n   * controlling animation with React animation libraries.\n   */\n  forceMount?: true;\n}\n\nconst TooltipContent = React.forwardRef<TooltipContentElement, TooltipContentProps>(\n  (props: ScopedProps<TooltipContentProps>, forwardedRef) => {\n    const portalContext = usePortalContext(CONTENT_NAME, props.__scopeTooltip);\n    const { forceMount = portalContext.forceMount, side = 'top', ...contentProps } = props;\n    const context = useTooltipContext(CONTENT_NAME, props.__scopeTooltip);\n\n    return (\n      <Presence present={forceMount || context.open}>\n        {context.disableHoverableContent ? (\n          <TooltipContentImpl side={side} {...contentProps} ref={forwardedRef} />\n        ) : (\n          <TooltipContentHoverable side={side} {...contentProps} ref={forwardedRef} />\n        )}\n      </Presence>\n    );\n  }\n);\n\ntype Point = { x: number; y: number };\ntype Polygon = Point[];\n\ntype TooltipContentHoverableElement = TooltipContentImplElement;\ninterface TooltipContentHoverableProps extends TooltipContentImplProps {}\n\nconst TooltipContentHoverable = React.forwardRef<\n  TooltipContentHoverableElement,\n  TooltipContentHoverableProps\n>((props: ScopedProps<TooltipContentHoverableProps>, forwardedRef) => {\n  const context = useTooltipContext(CONTENT_NAME, props.__scopeTooltip);\n  const providerContext = useTooltipProviderContext(CONTENT_NAME, props.__scopeTooltip);\n  const ref = React.useRef<TooltipContentHoverableElement>(null);\n  const composedRefs = useComposedRefs(forwardedRef, ref);\n  const [pointerGraceArea, setPointerGraceArea] = React.useState<Polygon | null>(null);\n\n  const { trigger, onClose } = context;\n  const content = ref.current;\n\n  const { onPointerInTransitChange } = providerContext;\n\n  const handleRemoveGraceArea = React.useCallback(() => {\n    setPointerGraceArea(null);\n    onPointerInTransitChange(false);\n  }, [onPointerInTransitChange]);\n\n  const handleCreateGraceArea = React.useCallback(\n    (event: PointerEvent, hoverTarget: HTMLElement) => {\n      const currentTarget = event.currentTarget as HTMLElement;\n      const exitPoint = { x: event.clientX, y: event.clientY };\n      const exitSide = getExitSideFromRect(exitPoint, currentTarget.getBoundingClientRect());\n      const paddedExitPoints = getPaddedExitPoints(exitPoint, exitSide);\n      const hoverTargetPoints = getPointsFromRect(hoverTarget.getBoundingClientRect());\n      const graceArea = getHull([...paddedExitPoints, ...hoverTargetPoints]);\n      setPointerGraceArea(graceArea);\n      onPointerInTransitChange(true);\n    },\n    [onPointerInTransitChange]\n  );\n\n  React.useEffect(() => {\n    return () => handleRemoveGraceArea();\n  }, [handleRemoveGraceArea]);\n\n  React.useEffect(() => {\n    if (trigger && content) {\n      const handleTriggerLeave = (event: PointerEvent) => handleCreateGraceArea(event, content);\n      const handleContentLeave = (event: PointerEvent) => handleCreateGraceArea(event, trigger);\n\n      trigger.addEventListener('pointerleave', handleTriggerLeave);\n      content.addEventListener('pointerleave', handleContentLeave);\n      return () => {\n        trigger.removeEventListener('pointerleave', handleTriggerLeave);\n        content.removeEventListener('pointerleave', handleContentLeave);\n      };\n    }\n  }, [trigger, content, handleCreateGraceArea, handleRemoveGraceArea]);\n\n  React.useEffect(() => {\n    if (pointerGraceArea) {\n      const handleTrackPointerGrace = (event: PointerEvent) => {\n        const target = event.target as HTMLElement;\n        const pointerPosition = { x: event.clientX, y: event.clientY };\n        const hasEnteredTarget = trigger?.contains(target) || content?.contains(target);\n        const isPointerOutsideGraceArea = !isPointInPolygon(pointerPosition, pointerGraceArea);\n\n        if (hasEnteredTarget) {\n          handleRemoveGraceArea();\n        } else if (isPointerOutsideGraceArea) {\n          handleRemoveGraceArea();\n          onClose();\n        }\n      };\n      document.addEventListener('pointermove', handleTrackPointerGrace);\n      return () => document.removeEventListener('pointermove', handleTrackPointerGrace);\n    }\n  }, [trigger, content, pointerGraceArea, onClose, handleRemoveGraceArea]);\n\n  return <TooltipContentImpl {...props} ref={composedRefs} />;\n});\n\nconst [VisuallyHiddenContentContextProvider, useVisuallyHiddenContentContext] =\n  createTooltipContext(TOOLTIP_NAME, { isInside: false });\n\ntype TooltipContentImplElement = React.ElementRef<typeof PopperPrimitive.Content>;\ntype DismissableLayerProps = React.ComponentPropsWithoutRef<typeof DismissableLayer>;\ntype PopperContentProps = React.ComponentPropsWithoutRef<typeof PopperPrimitive.Content>;\ninterface TooltipContentImplProps extends Omit<PopperContentProps, 'onPlaced'> {\n  /**\n   * A more descriptive label for accessibility purpose\n   */\n  'aria-label'?: string;\n\n  /**\n   * Event handler called when the escape key is down.\n   * Can be prevented.\n   */\n  onEscapeKeyDown?: DismissableLayerProps['onEscapeKeyDown'];\n  /**\n   * Event handler called when the a `pointerdown` event happens outside of the `Tooltip`.\n   * Can be prevented.\n   */\n  onPointerDownOutside?: DismissableLayerProps['onPointerDownOutside'];\n}\n\nconst TooltipContentImpl = React.forwardRef<TooltipContentImplElement, TooltipContentImplProps>(\n  (props: ScopedProps<TooltipContentImplProps>, forwardedRef) => {\n    const {\n      __scopeTooltip,\n      children,\n      'aria-label': ariaLabel,\n      onEscapeKeyDown,\n      onPointerDownOutside,\n      ...contentProps\n    } = props;\n    const context = useTooltipContext(CONTENT_NAME, __scopeTooltip);\n    const popperScope = usePopperScope(__scopeTooltip);\n    const { onClose } = context;\n\n    // Close this tooltip if another one opens\n    React.useEffect(() => {\n      document.addEventListener(TOOLTIP_OPEN, onClose);\n      return () => document.removeEventListener(TOOLTIP_OPEN, onClose);\n    }, [onClose]);\n\n    // Close the tooltip if the trigger is scrolled\n    React.useEffect(() => {\n      if (context.trigger) {\n        const handleScroll = (event: Event) => {\n          const target = event.target as HTMLElement;\n          if (target?.contains(context.trigger)) onClose();\n        };\n        window.addEventListener('scroll', handleScroll, { capture: true });\n        return () => window.removeEventListener('scroll', handleScroll, { capture: true });\n      }\n    }, [context.trigger, onClose]);\n\n    return (\n      <DismissableLayer\n        asChild\n        disableOutsidePointerEvents={false}\n        onEscapeKeyDown={onEscapeKeyDown}\n        onPointerDownOutside={onPointerDownOutside}\n        onFocusOutside={(event) => event.preventDefault()}\n        onDismiss={onClose}\n      >\n        <PopperPrimitive.Content\n          data-state={context.stateAttribute}\n          {...popperScope}\n          {...contentProps}\n          ref={forwardedRef}\n          style={{\n            ...contentProps.style,\n            // re-namespace exposed content custom properties\n            ...{\n              '--radix-tooltip-content-transform-origin': 'var(--radix-popper-transform-origin)',\n              '--radix-tooltip-content-available-width': 'var(--radix-popper-available-width)',\n              '--radix-tooltip-content-available-height': 'var(--radix-popper-available-height)',\n              '--radix-tooltip-trigger-width': 'var(--radix-popper-anchor-width)',\n              '--radix-tooltip-trigger-height': 'var(--radix-popper-anchor-height)',\n            },\n          }}\n        >\n          <Slottable>{children}</Slottable>\n          <VisuallyHiddenContentContextProvider scope={__scopeTooltip} isInside={true}>\n            <VisuallyHiddenPrimitive.Root id={context.contentId} role=\"tooltip\">\n              {ariaLabel || children}\n            </VisuallyHiddenPrimitive.Root>\n          </VisuallyHiddenContentContextProvider>\n        </PopperPrimitive.Content>\n      </DismissableLayer>\n    );\n  }\n);\n\nTooltipContent.displayName = CONTENT_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * TooltipArrow\n * -----------------------------------------------------------------------------------------------*/\n\nconst ARROW_NAME = 'TooltipArrow';\n\ntype TooltipArrowElement = React.ElementRef<typeof PopperPrimitive.Arrow>;\ntype PopperArrowProps = React.ComponentPropsWithoutRef<typeof PopperPrimitive.Arrow>;\ninterface TooltipArrowProps extends PopperArrowProps {}\n\nconst TooltipArrow = React.forwardRef<TooltipArrowElement, TooltipArrowProps>(\n  (props: ScopedProps<TooltipArrowProps>, forwardedRef) => {\n    const { __scopeTooltip, ...arrowProps } = props;\n    const popperScope = usePopperScope(__scopeTooltip);\n    const visuallyHiddenContentContext = useVisuallyHiddenContentContext(\n      ARROW_NAME,\n      __scopeTooltip\n    );\n    // if the arrow is inside the `VisuallyHidden`, we don't want to render it all to\n    // prevent issues in positioning the arrow due to the duplicate\n    return visuallyHiddenContentContext.isInside ? null : (\n      <PopperPrimitive.Arrow {...popperScope} {...arrowProps} ref={forwardedRef} />\n    );\n  }\n);\n\nTooltipArrow.displayName = ARROW_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\ntype Side = NonNullable<TooltipContentProps['side']>;\n\nfunction getExitSideFromRect(point: Point, rect: DOMRect): Side {\n  const top = Math.abs(rect.top - point.y);\n  const bottom = Math.abs(rect.bottom - point.y);\n  const right = Math.abs(rect.right - point.x);\n  const left = Math.abs(rect.left - point.x);\n\n  switch (Math.min(top, bottom, right, left)) {\n    case left:\n      return 'left';\n    case right:\n      return 'right';\n    case top:\n      return 'top';\n    case bottom:\n      return 'bottom';\n    default:\n      throw new Error('unreachable');\n  }\n}\n\nfunction getPaddedExitPoints(exitPoint: Point, exitSide: Side, padding = 5) {\n  const paddedExitPoints: Point[] = [];\n  switch (exitSide) {\n    case 'top':\n      paddedExitPoints.push(\n        { x: exitPoint.x - padding, y: exitPoint.y + padding },\n        { x: exitPoint.x + padding, y: exitPoint.y + padding }\n      );\n      break;\n    case 'bottom':\n      paddedExitPoints.push(\n        { x: exitPoint.x - padding, y: exitPoint.y - padding },\n        { x: exitPoint.x + padding, y: exitPoint.y - padding }\n      );\n      break;\n    case 'left':\n      paddedExitPoints.push(\n        { x: exitPoint.x + padding, y: exitPoint.y - padding },\n        { x: exitPoint.x + padding, y: exitPoint.y + padding }\n      );\n      break;\n    case 'right':\n      paddedExitPoints.push(\n        { x: exitPoint.x - padding, y: exitPoint.y - padding },\n        { x: exitPoint.x - padding, y: exitPoint.y + padding }\n      );\n      break;\n  }\n  return paddedExitPoints;\n}\n\nfunction getPointsFromRect(rect: DOMRect) {\n  const { top, right, bottom, left } = rect;\n  return [\n    { x: left, y: top },\n    { x: right, y: top },\n    { x: right, y: bottom },\n    { x: left, y: bottom },\n  ];\n}\n\n// Determine if a point is inside of a polygon.\n// Based on https://github.com/substack/point-in-polygon\nfunction isPointInPolygon(point: Point, polygon: Polygon) {\n  const { x, y } = point;\n  let inside = false;\n  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {\n    const xi = polygon[i].x;\n    const yi = polygon[i].y;\n    const xj = polygon[j].x;\n    const yj = polygon[j].y;\n\n    // prettier-ignore\n    const intersect = ((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);\n    if (intersect) inside = !inside;\n  }\n\n  return inside;\n}\n\n// Returns a new array of points representing the convex hull of the given set of points.\n// https://www.nayuki.io/page/convex-hull-algorithm\nfunction getHull<P extends Point>(points: Readonly<Array<P>>): Array<P> {\n  const newPoints: Array<P> = points.slice();\n  newPoints.sort((a: Point, b: Point) => {\n    if (a.x < b.x) return -1;\n    else if (a.x > b.x) return +1;\n    else if (a.y < b.y) return -1;\n    else if (a.y > b.y) return +1;\n    else return 0;\n  });\n  return getHullPresorted(newPoints);\n}\n\n// Returns the convex hull, assuming that each points[i] <= points[i + 1]. Runs in O(n) time.\nfunction getHullPresorted<P extends Point>(points: Readonly<Array<P>>): Array<P> {\n  if (points.length <= 1) return points.slice();\n\n  const upperHull: Array<P> = [];\n  for (let i = 0; i < points.length; i++) {\n    const p = points[i];\n    while (upperHull.length >= 2) {\n      const q = upperHull[upperHull.length - 1];\n      const r = upperHull[upperHull.length - 2];\n      if ((q.x - r.x) * (p.y - r.y) >= (q.y - r.y) * (p.x - r.x)) upperHull.pop();\n      else break;\n    }\n    upperHull.push(p);\n  }\n  upperHull.pop();\n\n  const lowerHull: Array<P> = [];\n  for (let i = points.length - 1; i >= 0; i--) {\n    const p = points[i];\n    while (lowerHull.length >= 2) {\n      const q = lowerHull[lowerHull.length - 1];\n      const r = lowerHull[lowerHull.length - 2];\n      if ((q.x - r.x) * (p.y - r.y) >= (q.y - r.y) * (p.x - r.x)) lowerHull.pop();\n      else break;\n    }\n    lowerHull.push(p);\n  }\n  lowerHull.pop();\n\n  if (\n    upperHull.length === 1 &&\n    lowerHull.length === 1 &&\n    upperHull[0].x === lowerHull[0].x &&\n    upperHull[0].y === lowerHull[0].y\n  ) {\n    return upperHull;\n  } else {\n    return upperHull.concat(lowerHull);\n  }\n}\n\nconst Provider = TooltipProvider;\nconst Root = Tooltip;\nconst Trigger = TooltipTrigger;\nconst Portal = TooltipPortal;\nconst Content = TooltipContent;\nconst Arrow = TooltipArrow;\n\nexport {\n  createTooltipScope,\n  //\n  TooltipProvider,\n  Tooltip,\n  TooltipTrigger,\n  TooltipPortal,\n  TooltipContent,\n  TooltipArrow,\n  //\n  Provider,\n  Root,\n  Trigger,\n  Portal,\n  Content,\n  Arrow,\n};\nexport type {\n  TooltipProviderProps,\n  TooltipProps,\n  TooltipTriggerProps,\n  TooltipPortalProps,\n  TooltipContentProps,\n  TooltipArrowProps,\n};\n"],"names":["assign","searchParamsToUrlQuery","urlQueryToSearchParams","searchParams","query","key","value","entries","existing","Array","isArray","push","stringifyUrlQueryParam","param","isNaN","String","URLSearchParams","Object","item","append","set","target","searchParamsList","keys","delete","formatUrl","formatWithValidation","urlObjectKeys","slashedProtocols","urlObj","auth","hostname","protocol","pathname","hash","host","encodeURIComponent","replace","indexOf","port","querystring","search","endsWith","slashes","test","url","process","env","NODE_ENV","forEach","includes","console","warn","DecodeError","MiddlewareNotFoundError","MissingStaticPage","NormalizeError","PageNotFoundError","SP","ST","WEB_VITALS","execOnce","getDisplayName","getLocationOrigin","getURL","isAbsoluteUrl","isResSent","loadGetInitialProps","normalizeRepeatedSlashes","stringifyError","fn","used","result","args","ABSOLUTE_URL_REGEX","window","location","href","origin","substring","length","Component","displayName","name","res","finished","headersSent","urlParts","split","urlNoQuery","slice","join","App","ctx","prototype","getInitialProps","message","Error","pageProps","props","performance","every","method","constructor","page","code","error","JSON","stringify","stack","parsePath","path","hashIndex","queryIndex","hasQuery","undefined","addPathPrefix","prefix","startsWith","removeTrailingSlash","route","normalizePathTrailingSlash","__NEXT_MANUAL_TRAILING_SLASH","__NEXT_TRAILING_SLASH","addBasePath","basePath","__NEXT_ROUTER_BASEPATH","required","__NEXT_MANUAL_CLIENT_BASE_PATH","FetchStrategy","NavigationResultTag","PrefetchPriority","createCacheKey","originalHref","nextUrl","originalUrl","URL","cacheKey","HasLoadingBoundary","matchSegment","existingSegment","segment","ACTION_HEADER","FLIGHT_HEADERS","NEXT_ACTION_NOT_FOUND_HEADER","NEXT_DID_POSTPONE_HEADER","NEXT_HMR_REFRESH_HASH_COOKIE","NEXT_HMR_REFRESH_HEADER","NEXT_HTML_REQUEST_ID_HEADER","NEXT_IS_PRERENDER_HEADER","NEXT_REQUEST_ID_HEADER","NEXT_REWRITTEN_PATH_HEADER","NEXT_REWRITTEN_QUERY_HEADER","NEXT_ROUTER_PREFETCH_HEADER","NEXT_ROUTER_SEGMENT_PREFETCH_HEADER","NEXT_ROUTER_STALE_TIME_HEADER","NEXT_ROUTER_STATE_TREE_HEADER","NEXT_RSC_UNION_QUERY","NEXT_URL","RSC_CONTENT_TYPE_HEADER","RSC_HEADER","ACTION_HMR_REFRESH","ACTION_NAVIGATE","ACTION_REFRESH","ACTION_RESTORE","ACTION_SERVER_ACTION","ACTION_SERVER_PATCH","PrefetchKind","isThenable","promise","then","dispatchAppRouterAction","useActionQueue","dispatch","action","__DEV__","promisesWithDebugInfo","WeakMap","actionQueue","state","setState","React","useState","useAppDevRenderingIndicator","require","appDevRenderingIndicator","stateWithDebugInfo","useMemo","promiseWithDebugInfo","get","debugInfo","Promise","resolve","asyncState","_debugInfo","use","callServer","actionId","actionArgs","reject","startTransition","type","findSourceMapURL","filename","document","HEAD_REQUEST_KEY","ROOT_SEGMENT_REQUEST_KEY","appendSegmentRequestKeyPart","convertSegmentPathToStaticExportFilename","createSegmentRequestKeyPart","PAGE_SEGMENT_KEY","safeName","encodeToFilesystemAndURLSafeString","paramType","encodedName","parentRequestKey","parallelRouteKey","childRequestKeyPart","slotKey","simpleParamValueRegex","base64url","btoa","segmentPath","doesStaticSegmentAppearInURL","getCacheKeyForDynamicParam","getParamValueFromCacheKey","getRenderedPathname","getRenderedSearch","parseDynamicParamFromURLPart","urlSearchParamsToParsedUrlQuery","urlToUrlWithoutFlightMarker","response","rewrittenQuery","headers","rewrittenPath","pathnameParts","partIndex","map","s","i","DEFAULT_SEGMENT_KEY","paramValue","renderedSearch","pageSegmentWithSearchParams","addSearchParamsIfPageSegment","fromEntries","urlWithoutFlightParameters","__NEXT_CONFIG_OUTPUT","paramCacheKey","isCatchAll","createHrefFromUrl","includeHash","createInitialRSCPayloadFromFallbackPrerender","getFlightDataPartsFromPath","getNextFlightSegmentPath","normalizeFlightData","prepareFlightRouterStateForRequest","flightDataPath","flightDataPathLength","tree","seedData","head","isHeadPartial","pathToSegment","isRootRender","fallbackInitialRSCPayload","renderedPathname","canonicalUrl","originalFlightDataPath","f","originalFlightRouterState","b","c","q","fillInFallbackFlightRouterState","m","G","S","flightRouterState","filter","p","index","fillInFallbackFlightRouterStateImpl","pathnamePartsIndex","originalSegment","newSegment","doesAppearInURL","paramName","childPathnamePartsIndex","children","newChildren","childFlightRouterState","newState","flightSegmentPath","flightData","isHmrRefresh","stripClientOnlyDataFromFlightRouterState","parallelRoutes","_url","refreshMarker","isRootLayout","hasLoadingBoundary","cleanedSegment","stripSearchParamsFromPageSegment","cleanedParallelRoutes","childState","shouldPreserveRefreshMarker","Boolean","getAppBuildId","setAppBuildId","globalBuildId","buildId","djb2Hash","hexHash","str","char","charCodeAt","toString","computeCacheBustingSearchParam","prefetchHeader","segmentPrefetchHeader","stateTreeHeader","nextUrlHeader","setCacheBustingSearchParam","setCacheBustingSearchParamWithHash","uniqueCacheKey","existingSearch","rawQuery","pairs","pair","createFetch","createFromNextReadableStream","fetchServerResponse","createFromReadableStream","createFromReadableStreamBrowser","createFromFetch","createFromFetchBrowser","createDebugChannel","__NEXT_REACT_DEBUG_CHANNEL","doMpaNavigation","abortController","AbortController","addEventListener","abort","options","prefetchKind","AUTO","fetchPriority","TEMPORARY","isLegacyPPR","__NEXT_PPR","__NEXT_CACHE_COMPONENTS","shouldImmediatelyDecode","signal","responseUrl","redirected","contentType","interception","postponed","staleTimeHeaderSeconds","staleTime","parseInt","isFlightResponse","ok","body","TURBOPACK","waitForWebpackRuntimeHotUpdate","flightResponsePromise","flightResponse","flightStream","createUnclosingPrefetchStream","normalizedFlightData","couldBeIntercepted","prerendered","err","aborted","__NEXT_TEST_MODE","NEXT_DEPLOYMENT_ID","self","__next_r","crypto","getRandomValues","Uint32Array","fetchOptions","credentials","priority","fetchUrl","fetchPromise","fetch","createFromNextFetch","browserResponse","__NEXT_CLIENT_VALIDATE_RSC_REQUEST_HEADERS","MAX_REDIRECTS","n","rscResponse","status","requestHeaders","debugChannel","promiseForResponse","originalFlightStream","reader","getReader","ReadableStream","pull","controller","done","read","enqueue","deleteFromLru","lruPut","updateLruSize","didScheduleCleanup","lruSize","maxLruSize","node","prev","next","size","ensureCleanupIsScheduled","tail","newNodeSize","prevNodeSize","deleted","requestCleanupCallback","cleanup","ninetyPercentMax","deleteFromCacheMap","requestIdleCallback","cb","setTimeout","Fallback","createCacheMap","getFromCacheMap","isValueExpired","setInCacheMap","setSizeInCacheMap","Revalidation","cacheMap","parent","getOrInitialize","isRevalidation","entry","remainingKeys","previousKey","existingEntry","Map","newEntry","now","currentCacheVersion","rootEntry","getEntryWithFallbackImpl","staleAt","version","lazilyEvictIfNeeded","deleteMapEntry","fallbackEntry","setMapEntryValue","dropRef","emptyEntry","fillEmptyReference","oldEntry","ref","fullEntry","parentMap","revalidatingEntry","appendLayoutVaryPath","clonePageVaryPathWithNewSearchParams","finalizeLayoutVaryPath","finalizeMetadataVaryPath","finalizePageVaryPath","getFulfilledRouteVaryPath","getRouteVaryPath","getSegmentVaryPathForRequest","varyPath","parentPath","varyPathPart","requestKey","layoutVaryPath","pageVaryPath","pageRequestKey","fetchStrategy","originalVaryPath","isPage","doesVaryOnSearchParams","Full","PPRRuntime","searchParamsVaryPath","pathParamsVaryPath","patchedVaryPath","newSearch","clonedVaryPath","ensureLeadingSlash","normalizeAppPath","normalizeRscURL","reduce","segments","isGroupSegment","INTERCEPTION_ROUTE_MARKERS","extractInterceptionRouteInformation","isInterceptionRouteAppPath","find","interceptingRoute","marker","interceptedRoute","concat","splitInterceptingRoute","computeChangedPath","extractPathFromFlightRouterState","getSelectedParams","removeLeadingSlash","segmentToPathname","normalizeSegments","acc","some","childrenPath","childPath","computeChangedPathImpl","treeA","treeB","segmentA","parallelRoutesA","segmentB","parallelRoutesB","normalizedSegmentA","normalizedSegmentB","parallelRouterKey","changedPath","currentTree","params","parallelRoute","values","isDynamicParameter","segmentValue","handleMutable","isNotUndefined","mutable","shouldScroll","previousNextUrl","patchedTree","pushRef","pendingPush","mpaNavigation","preserveCustomHistoryState","focusAndScrollRef","apply","scrollableSegments","onlyHashChange","hashFragment","decodeURIComponent","segmentPaths","cache","collectedDebugInfo","createRouterCacheKey","withoutSearchParameters","isNavigatingToNewRootLayout","nextTree","currentTreeSegment","nextTreeSegment","currentTreeChild","nextTreeChild","abortTask","listenForDynamicRequest","startPPRNavigation","updateCacheNodeOnPopstateRestoration","MPA_NAVIGATION_TASK","dynamicRequestTree","navigatedAt","oldUrl","oldCacheNode","oldRouterState","newRouterState","prefetchData","prefetchHead","isPrefetchHeadPartial","isSamePageNavigation","scrollableSegmentsResult","updateCacheNodeOnNavigation","didFindRootLayout","oldRouterStateChildren","newRouterStateChildren","prefetchDataChildren","oldParallelRoutes","prefetchParallelRoutes","patchedRouterStateChildren","taskChildren","needsDynamicRequest","dynamicRequestTreeChildren","newRouterStateChild","oldRouterStateChild","oldSegmentMapChild","prefetchDataChild","newSegmentChild","newSegmentPathChild","newSegmentKeyChild","oldSegmentChild","oldCacheNodeChild","taskChild","reuseActiveSegmentInDefaultSlot","beginRenderingNewRouteTree","newCacheNodeChild","newSegmentMapChild","taskChildRoute","dynamicRequestTreeChild","newCacheNode","lazyData","rsc","prefetchRsc","loading","patchRouterStateWithNewChildren","existingCacheNode","possiblyPartialPrefetchHead","createCacheNodeOnNavigation","routerState","routerStateChildren","isLeafSegment","cacheNodeNavigatedAt","DYNAMIC_STALETIME_MS","isPrefetchRscPartial","spawnPendingTask","existingCacheNodeChildren","cacheNodeChildren","routerStateChild","existingSegmentMapChild","segmentChild","segmentPathChild","segmentKeyChild","existingCacheNodeChild","baseRouterState","clone","newTask","createPendingCacheNode","reusedRouterState","oldRefreshMarker","task","responsePromise","serverRouterState","dynamicData","dynamicHead","writeDynamicDataIntoPendingTask","rootTask","taskSegment","finishTaskUsingDynamicDataPayload","taskNode","finishPendingCacheNode","serverChildren","dynamicDataChildren","serverRouterStateChild","dynamicDataChild","maybePrefetchRsc","createDeferredRsc","cacheNode","taskState","serverState","taskStateChildren","serverStateChildren","dataChildren","taskStateChild","serverStateChild","dataChild","segmentMapChild","taskSegmentChild","taskSegmentKeyChild","cacheNodeChild","abortPendingCacheNode","dynamicSegmentData","isDeferredRsc","dynamicLoading","newParallelRoutes","shouldUsePrefetch","DEFERRED","Symbol","tag","pendingRsc","rej","responseDebugInfo","fulfilledRsc","rejectedRsc","reason","navigate","currentUrl","currentCacheNode","currentFlightRouterState","accumulation","Date","readRouteCacheEntry","EntryStatus","Fulfilled","snapshot","readRenderSnapshotFromCache","prefetchFlightRouterState","prefetchSeedData","headSnapshot","readHeadSnapshotFromCache","isPartial","newCanonicalUrl","navigateUsingPrefetchedRouteTree","Rejected","optimisticRoute","requestOptimisticRouteCacheEntry","newRenderedSearch","Async","data","navigateDynamicallyWithNoPrefetch","promiseForDynamicServerResponse","navigationTaskToResult","NoOp","MPA","Success","childRouterStates","childSeedDatas","slots","childTree","childResult","segmentEntry","readSegmentCacheEntry","Pending","promiseForFulfilledEntry","waitForSegmentCacheEntry","Empty","hasRuntimePrefetch","metadata","newUrl","debugInfoFromResponse","simulatePrefetchTreeUsingDynamicTreePatch","hasDynamicHoles","baseTree","treePatch","canMutateInPlace","simulatePrefetchTreeUsingDynamicTreePatchImpl","patch","updatedParallelRouteKey","baseChildren","childBaseRouterState","STATIC_STALETIME_MS","generateSegmentsFromPatch","handleExternalUrl","navigateReducer","Number","__NEXT_CLIENT_ROUTER_DYNAMIC_STALETIME","getStaleTimeMs","__NEXT_CLIENT_ROUTER_STATIC_STALETIME","flightRouterPatch","childSegment","handleNavigationResult","asyncResult","isExternalUrl","navigateType","getElementById","navigateUsingSegmentCache","DOC_PREFETCH_RANGE_HEADER_VALUE","doesExportedHtmlMatchBuildId","insertBuildIdComment","DOCTYPE_PREFIX","MAX_BUILD_ID_LENGTH","escapeBuildId","truncated","originalHtml","partialHtmlDocument","canNewFetchStrategyProvideMoreContent","convertRouteTreeToFlightRouterState","createDetachedSegmentCacheEntry","fetchRouteOnCacheMiss","fetchSegmentOnCacheMiss","fetchSegmentPrefetchesUsingDynamicRequest","getCurrentCacheVersion","overwriteRevalidatingSegmentCacheEntry","pingInvalidationListeners","readOrCreateRevalidatingSegmentEntry","readOrCreateRouteCacheEntry","readOrCreateSegmentCacheEntry","revalidateEntireCache","upgradeToPendingSegment","upsertSegmentEntry","staleTimeSeconds","Math","max","isOutputExportMode","MetadataOnlyRequestTree","routeCacheMap","segmentCacheMap","invalidationListeners","startRevalidationCooldown","pingVisibleLinks","attachInvalidationListener","onInvalidate","Set","add","notifyInvalidationListener","reportError","tasks","isPrefetchTaskDirty","readRevalidatingSegmentCacheEntry","pendingEntry","promiseWithResolvers","createPromiseWithResolvers","blockedTasks","isPPREnabled","Infinity","requestedUrl","requestedSearch","urlWithoutSearchParams","routeWithNoSearchParams","createPrefetchRequestKey","canonicalUrlForRouteWithNoSearchParams","optimisticCanonicalSearch","optimisticRenderedSearch","optimisticUrl","optimisticCanonicalUrl","optimisticRouteTree","createOptimisticRouteTree","optimisticMetadataTree","optimisticEntry","clonedSlots","originalSlots","varyPathForRequest","candidateEntry","rejectedEntry","PPR","pingBlockedTasks","pingPrefetchTask","fulfillRouteCacheEntry","metadataVaryPath","SubtreeHasNoLoadingBoundary","fulfilledEntry","fulfillSegmentCacheEntry","segmentCacheEntry","rejectRouteCacheEntry","rejectSegmentCacheEntry","convertRootTreePrefetchToRouteTree","rootTree","rootSegment","convertTreePrefetchToRouteTree","prefetch","partialVaryPath","prefetchSlots","childPrefetch","childParamName","childParamType","childServerSentParamKey","paramKey","childDoesAppearInURL","childPartialVaryPath","childParamValue","childParamKey","childRequestKey","SegmentHasLoadingBoundary","convertRootFlightRouterStateToRouteTree","convertFlightRouterStateToRouteTree","parentPartialVaryPath","childRouterState","routeTree","urlAfterRedirects","htmlResponse","Range","partialHtml","text","fetchPrefetchResponse","addSegmentPathToUrlInOutputExportMode","varyHeader","closed","routeIsPPREnabled","prefetchStream","createPrefetchResponseStream","onResponseSizeUpdate","serverData","staleTimeMs","writeDynamicTreeResponseIntoCache","LoadingBoundary","fulfilledVaryPath","routeKey","normalizedRequestKey","requestUrl","spawnedEntries","has","rejectSegmentEntriesIfStillPending","fulfilledEntries","totalBytesReceivedSoFar","averageSize","isResponsePartial","rp","writeDynamicRenderResponseIntoCache","normalizedFlightDataResult","flightDatas","writeSeedDataIntoCache","fulfillEntrySpawnedByRuntimePrefetch","entriesOwnedByCurrentTask","seedDataChildren","childSeedData","ownedEntry","possiblyNewEntry","onStreamClose","totalByteLength","byteLength","staticUrl","routeDir","staticExportFilename","currentStrategy","newStrategy","cancelPrefetchTask","reschedulePrefetchTask","schedulePrefetchTask","scheduleMicrotask","queueMicrotask","catch","taskHeap","inProgressRequests","sortIdCounter","didScheduleMicrotask","mostRecentlyHoveredLink","REVALIDATION_COOLDOWN_MS","revalidationCooldownTimeoutHandle","clearTimeout","ensureWorkIsScheduled","treeAtTimeOfPrefetch","cacheVersion","phase","hasBackgroundWork","spawnedRuntimePrefetches","sortId","isCanceled","_heapIndex","trackMostRecentlyHoveredLink","heapPush","heapDelete","Intent","heapResift","Background","Default","processQueueInMicrotask","hasNetworkBandwidth","spawnPrefetchSubtask","prefetchSubtask","onPrefetchConnectionClosed","heapPeek","exitStatus","pingRoute","heapPop","background","pingRootRouteTree","keyWithoutSearch","routeWithoutSearch","pingStaticHead","pingSharedPartOfCacheComponentsTree","pingRuntimeHead","requestTree","pingRuntimePrefetches","diffRouteTreeAgainstCurrent","pingStaticSegmentData","pingRouteTreeAndIncludeDynamicData","oldTree","newTree","oldTreeChildren","newTreeChildren","newTreeChild","newTreeChildSegment","oldTreeChild","oldTreeChildSegment","childExitStatus","doesCurrentSegmentMatchCachedSegment","pingNewPartOfCacheComponentsTree","requestTreeChildren","requestTreeChild","subtreeHasLoadingBoundary","pingPPRDisabledRouteTreeUpToLoadingBoundary","refetchMarkerContext","refetchMarker","segmentHasLoadingBoundary","isInsideRefetchingParent","spawnedSegment","pingFullSegmentRevalidation","pingPPRSegmentRevalidation","revalidatingSegment","upsertSegmentOnCompletion","pendingSegment","nonEmptyRevalidatingSegment","emptySegment","noop","fulfilled","currentSegment","cachedSegment","compareQueuePriority","a","priorityDiff","phaseDiff","heap","heapSiftUp","first","last","pop","heapSiftDown","parentIndex","halfLength","leftIndex","left","rightIndex","right","IDLE_LINK_STATUS","PENDING_LINK_STATUS","mountFormInstance","mountLinkInstance","onLinkVisibilityChanged","onNavigationIntent","setLinkForCurrentNavigation","unmountLinkForCurrentNavigation","unmountPrefetchableInstance","linkForMostRecentNavigation","pending","link","setOptimisticLinkStatus","prefetchable","prefetchableAndVisible","observer","IntersectionObserver","handleIntersect","rootMargin","observeVisibility","element","instance","existingInstance","observe","coercePrefetchableUrl","createPrefetchURL","reportErrorFn","router","prefetchEnabled","prefetchURL","isVisible","prefetchTask","prefetchHref","unobserve","intersectionRatio","rescheduleLinkPrefetch","unstable_upgradeToDynamicPrefetch","__NEXT_DYNAMIC_ON_HOVER","existingPrefetchTask","getCurrentAppRouterState","appRouterState","scheduleSegmentPrefetchTask","pathHasPrefix","hasBasePath","isLocalURL","locationOrigin","resolved","_","errorOnce","errors","msg","LinkComponent","useLinkStatus","isModifiedEvent","event","eventTarget","currentTarget","getAttribute","metaKey","ctrlKey","shiftKey","altKey","nativeEvent","which","linkClicked","e","as","linkInstanceRef","scroll","onNavigate","nodeName","isAnchorNodeName","toUpperCase","hasAttribute","preventDefault","isDefaultPrevented","dispatchNavigateAction","current","formatStringOrUrl","urlObjOrString","linkStatus","useOptimistic","useRef","hrefProp","asProp","childrenProp","prefetchProp","passHref","shallow","onClick","onMouseEnter","onMouseEnterProp","onTouchStart","onTouchStartProp","legacyBehavior","forwardedRef","unstable_dynamicOnHover","restProps","useContext","AppRouterContext","getFetchStrategyFromPrefetchProp","createPropError","expected","actual","requiredPropsGuard","requiredProps","optionalPropsGuard","optionalProps","valType","locale","warnOnce","hasDynamicSegment","resolvedHref","child","$$typeof","for","Children","only","childRef","observeLinkVisibilityOnMount","useCallback","mergedRef","useMergedRef","childProps","defaultPrevented","upgradeToDynamicPrefetch","__NEXT_LINK_NO_TOUCH_START","cloneElement","LinkStatusContext","Provider","createContext"],"mappings":"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","ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,51,52,53,54,59,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78]}